<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hurried1y</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-15T14:07:18.426Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hurried1y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简易RPC框架 - 4</title>
    <link href="http://example.com/2023/05/15/rpc-framework-4/"/>
    <id>http://example.com/2023/05/15/rpc-framework-4/</id>
    <published>2023-05-15T11:44:29.000Z</published>
    <updated>2023-05-15T14:07:18.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简易RPC框架-网络传输模块"><a href="#简易RPC框架-网络传输模块" class="headerlink" title="简易RPC框架 - 网络传输模块"></a>简易RPC框架 - 网络传输模块</h3><h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>我们在前面的文章中说到了客户端通过代理对象进行远程调用，其中通过Channel与服务端进行网络通信，其实就是通过网络请求来传递类信息、方法信息以及方法参数等数据到服务端。其中网络传输的具体实现在本项目中我们使用的是基于NIO的网络编程框架Netty。</p><h4 id="2、网络传输"><a href="#2、网络传输" class="headerlink" title="2、网络传输"></a>2、网络传输</h4><h5 id="1）网络传输实体类"><a href="#1）网络传输实体类" class="headerlink" title="1）网络传输实体类"></a>1）网络传输实体类</h5><p>在此我们先定义了一些在网络传输中的数据格式：</p><p>RpcRequest请求类，当你要调用远程方法时，需要将你要调用的方法的详细信息传输到服务器端，然后服务端就能根据这些信息去获取方法对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRpcServiceName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getInterfaceName() + getGroup() + getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcResponse响应类，服务端执行完请求后，就可以将响应信息封装成响应类传输给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">//response code</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">//response message</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//response body</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data, String requestId)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(RpcResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(RpcResponseCode.SUCCESS.getMessage());</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setData(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">fail</span><span class="params">(RpcResponseCodeEnum rpcResponseCodeEnum)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(rpcResponseCodeEnum.getCode());</span><br><span class="line">        response.setMessage(rpcResponseCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但真正在网络中传输不是仅仅是传输这个对象就行了，还有可能出现很多问题，比如在TCP传输过程中的黏包半包问题。</p><p>粘包和半包问题是数据传输中比较常见的问题，所谓的<strong>粘包问题是指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包。</strong>比如发送了两条消息，分别为“ABC”和“DEF”，那么正常情况下接收端也应该收到两条消息“ABC”和“DEF”，但接收端却收到的是“ABCD”，像这种情况就叫做粘包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/uuu.png" alt="uuu"></p><p>半包问题是指接收端只收到了部分数据，而非完整的数据的情况就叫做半包。比如发送了一条消息是“ABC”，而接收端却收到的是“AB”和“C”两条信息，这种情况就叫做半包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/yyy.png" alt="yyy"></p><p>为什么会出现黏包半包问题？粘包问题发生在 TCP/IP 协议中，<strong>因为 TCP 是面向连接的传输协议，它是以“流”的形式传输数据的，而“流”数据是没有明确的开始和结尾边界的，所以就会出现粘包问题</strong>。</p><h5 id="2）自定义传输协议"><a href="#2）自定义传输协议" class="headerlink" title="2）自定义传输协议"></a>2）自定义传输协议</h5><p>那要什么解决这个问题呢？我们采用自定义传输协议，并对数据进行相应的编码解码以解决这个问题。简单来说，我们通过设计传输协议，定义需要传输的数据以及其需要占多少字节的数据，当我们在收到传输数据后，就可以根据我们设计的传输协议去解析出正确的数据。</p><p>首先我们定义真正在网络中进行传输的对象，RpcMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessage</span> &#123;</span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> messageType;</span><br><span class="line">    <span class="comment">//序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> codec;</span><br><span class="line">    <span class="comment">//压缩类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> compress;</span><br><span class="line">    <span class="comment">//请求id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requestId;</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessage中的data就是上面的RpcRequest和RpcResponse，接下来我们详细讲解一下自定义的协议</p><p><img src="/2023/05/15/rpc-framework-4/Github_Blog\blog\source_posts\rpc-framework-4\aaa.png" alt="aaa"></p><ol><li>magic code 魔数：判断是否是遵循同一协议的数据，用来校验数据包有效性，占4byte</li><li>version 版本信息：后续可以用于协议的版本迭代，占1byte</li><li>full length 消息长度：请求头+请求体的总长度，占4byte</li><li>messageType 消息类型：消息可分为请求和相应两类，占1byte</li><li>compress 压缩类型：数据的压缩类型，占1byte</li><li>codec 序列化类型：RpcRequest和RpcResponse的序列化类型，占1byte</li><li>requestId 请求Id：请求Id，用于后续的消息跟踪，占4byte</li><li>body 请求体：RpcRequest或RpcResponse序列化后的byte数据</li></ol><h5 id="3）编解码器"><a href="#3）编解码器" class="headerlink" title="3）编解码器"></a>3）编解码器</h5><p>RpcMessageEncoder，自定义编码器，负责处理“出站”消息，将消息转换为字节数组然后写入到 <strong>ByteBuf</strong> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line">    <span class="comment">// 原子类，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ATOMIC_INTEGER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage rpcMessage, ByteBuf out)</span> &#123;</span><br><span class="line">        <span class="comment">//将RpcMessage对象转换为字节流，写入到ByteBuf中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入魔数</span></span><br><span class="line">            out.writeBytes(RpcConstants.MAGIC_NUMBER);</span><br><span class="line">            <span class="comment">//写入版本号</span></span><br><span class="line">            out.writeByte(RpcConstants.VERSION);</span><br><span class="line">            <span class="comment">//写入消息长度，先占位，后面再写入</span></span><br><span class="line">            out.writerIndex(out.writerIndex() + <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//写入消息类型</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> rpcMessage.getMessageType();</span><br><span class="line">            out.writeByte(messageType);</span><br><span class="line">            <span class="comment">//写入序列化类型</span></span><br><span class="line">            out.writeByte(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//写入压缩类型</span></span><br><span class="line">            out.writeByte(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">            <span class="comment">//写入requestId，相当于请求序号，为了全双工通信，提供异步能力</span></span><br><span class="line">            out.writeInt(ATOMIC_INTEGER.getAndIncrement());</span><br><span class="line">            <span class="comment">//获取消息长度和消息体</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//初始消息长度为消息头长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> RpcConstants.HEAD_LENGTH;</span><br><span class="line">            <span class="comment">//如果消息类型不是心跳包, fullLength = head length + body length</span></span><br><span class="line">            <span class="keyword">if</span> (messageType != RpcConstants.HEARTBEAT_REQUEST_TYPE</span><br><span class="line">                    &amp;&amp; messageType != RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">                <span class="comment">//获取序列化类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">                <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">                <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//                Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(codecName);</span></span><br><span class="line">                <span class="comment">//序列化消息体</span></span><br><span class="line">                bodyBytes = serializer.serialize(rpcMessage.getData());</span><br><span class="line">                <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">                <span class="comment">//获取压缩类型</span></span><br><span class="line"><span class="comment">//                String compressName = CompressTypeEnum.getName(rpcMessage.getCompress());</span></span><br><span class="line"><span class="comment">//                Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(compressName);</span></span><br><span class="line">                <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line">                <span class="comment">//压缩消息体</span></span><br><span class="line">                bodyBytes = compress.compress(bodyBytes);</span><br><span class="line">                <span class="comment">//最终消息长度 = 消息头长度 + 消息体长度</span></span><br><span class="line">                fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bodyBytes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//写入消息体</span></span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取写入索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> out.writerIndex();</span><br><span class="line">            <span class="comment">//回到消息长度的占位符位置：当前索引 - 消息长度占位符长度 + 魔数长度 + version长度</span></span><br><span class="line">            out.writerIndex(writeIndex - fullLength + RpcConstants.MAGIC_NUMBER.length + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//写入消息长度</span></span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            <span class="comment">//回到写入索引位置</span></span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Encode request error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessageDecoder，自定义解码器，负责“入站”数据，将 <strong>ByteBuf</strong> 中的字节数组转换为对应的消息数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// lengthFieldOffset = 魔数(4B) + 版本(1B) = 5B</span></span><br><span class="line">        <span class="comment">// lengthFieldLength = 消息长度 int(4B)</span></span><br><span class="line">        <span class="comment">// lengthAdjustment = -9，因为我们的长度域是从魔数开始的，所以我们需要调整长度域的偏移量</span></span><br><span class="line">        <span class="comment">// initialBytesToStrip = 0，我们会手动检查魔数和版本，所以不需要跳过任何字节</span></span><br><span class="line">        <span class="built_in">this</span>(RpcConstants.MAX_FRAME_LENGTH, <span class="number">5</span>, <span class="number">4</span>, -<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength      最大帧长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset   长度域(消息长度)的偏移量，简单而言就是偏移几个字节后才是长度域</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength   长度域的所占的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment    长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离值，Netty在解码时会根据该值计算消息体的开始位置，默认为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 最后解析结果中需要剥离的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">decoded</span> <span class="operator">=</span> <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decoded <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">frame</span> <span class="operator">=</span> (ByteBuf) decoded;</span><br><span class="line">            <span class="keyword">if</span> (frame.readableBytes() &gt;= RpcConstants.TOTAL_LENGTH) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> decodeFrame(frame);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Decode frame error!&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    frame.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> decoded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">decodeFrame</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序读取魔数、版本、消息长度</span></span><br><span class="line">        <span class="comment">//读取魔数并比较</span></span><br><span class="line">        checkMagicNumber(in);</span><br><span class="line">        <span class="comment">//读取版本并比较</span></span><br><span class="line">        checkVersion(in);</span><br><span class="line">        <span class="comment">//读取4字节消息长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//读取1字节消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节序列化类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">codecType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节压缩类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">compressType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取4字节请求ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//构建RpcMessage对象</span></span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder()</span><br><span class="line">                .codec(codecType)</span><br><span class="line">                .requestId(requestId)</span><br><span class="line">                .messageType(messageType).build();</span><br><span class="line">        <span class="comment">//根据消息类型解析消息</span></span><br><span class="line">        <span class="comment">//心跳消息</span></span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//普通消息</span></span><br><span class="line">        <span class="comment">//读取消息体长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> fullLength - RpcConstants.HEAD_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">            <span class="comment">//读取消息体</span></span><br><span class="line">            in.readBytes(bs);</span><br><span class="line">            <span class="comment">//解压缩</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">compressName</span> <span class="operator">=</span> CompressTypeEnum.getName(compressType);</span><br><span class="line">            <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">            <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line"><span class="comment">//            Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(compressName);</span></span><br><span class="line">            bs = compress.decompress(bs);</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">            <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//            Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(codecName);</span></span><br><span class="line">            <span class="comment">//根据消息类型反序列化</span></span><br><span class="line">            <span class="keyword">if</span> (messageType == RpcConstants.REQUEST_TYPE) &#123;</span><br><span class="line">                <span class="type">RpcRequest</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcRequest.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcResponse.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcMessage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkVersion</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取第5个字节，比较版本</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="keyword">if</span> (version != RpcConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;version isn&#x27;t compatible&quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkMagicNumber</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取前4个字节，比较魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> RpcConstants.MAGIC_NUMBER.length;</span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        in.readBytes(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] != RpcConstants.MAGIC_NUMBER[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、Netty"><a href="#3、Netty" class="headerlink" title="3、Netty"></a>3、Netty</h4><h5 id="1）客户端"><a href="#1）客户端" class="headerlink" title="1）客户端"></a>1）客户端</h5><p>Netty客户端主要提供了以下方法：</p><ul><li>initClientApplication() 用于初始化客户端</li><li>doSubscribeService(Class serviceBean)  服务订阅，将标注了@Reference的属性缓存到本地，之后统一建立Channel</li><li>doConnectServer() 让客户端与@Reference对应的服务端建立Channel</li><li>sendRpcRequest() 发送RpcRequest数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcClient</span> <span class="keyword">implements</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> ClientConfig clientConfig;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bootstrap <span class="title function_">getBootstrap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initClientApplication</span><span class="params">()</span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        bootstrap.group(worker);</span><br><span class="line">        <span class="comment">//添加 ChannelHandler 以处理每个 Channel 的日志消息</span></span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//                ch.pipeline().addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                <span class="comment">//添加自定义的ChannelHandler</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcClientHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//TODO 从配置文件中读取服务发现类</span></span><br><span class="line">        <span class="built_in">this</span>.serviceDiscovery = <span class="keyword">new</span> <span class="title class_">ZkServiceDiscoveryImpl</span>();</span><br><span class="line"><span class="comment">//        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());</span></span><br><span class="line">        <span class="built_in">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">        <span class="built_in">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = PropertiesBootstrap.loadClientConfigFromLocal();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> <span class="title class_">ZkServiceRegistryImpl</span>();</span><br><span class="line">        CLIENT_CONFIG = clientConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务订阅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceBean 标注了<span class="doctag">@RpcReference</span>的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSubscribeService</span><span class="params">(Class serviceBean)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>();</span><br><span class="line">        url.setServiceName(serviceBean.getName());</span><br><span class="line">        url.setApplicationName(clientConfig.getApplicationName());</span><br><span class="line">        url.addParameter(<span class="string">&quot;host&quot;</span>, InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        <span class="comment">//subscribe：将URL存入SUBSCRIBE_SERVICE_LIST</span></span><br><span class="line">        serviceRegistry.subscribe(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始与各个provider建立连接，TODO 同时监听各个providerNode节点的变化（child变化和nodeData的变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnectServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//SUBSCRIBE_SERVICE_LIST 为所有标注了@RpcReference的属性的信息集合</span></span><br><span class="line">        <span class="keyword">for</span> (URL providerURL : SUBSCRIBE_SERVICE_LIST) &#123;</span><br><span class="line">            <span class="comment">//根据标注了@RpcReference的serviceName去Zookeeper上获取其对应的地址</span></span><br><span class="line">            List&lt;String&gt; providerIps = serviceDiscovery.lookupService(providerURL.getServiceName());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                相当于@RpcReference客户端与对应的每一个服务提供者建立连接</span></span><br><span class="line"><span class="comment">                @RpcReference</span></span><br><span class="line"><span class="comment">                OrderService orderService;</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8081</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8082</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String providerIp : providerIps) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ConnectionHandler.connect(providerURL.getServiceName(), providerIp);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据serviceName获取Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(rpcRequest.getInterfaceName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(channel.isActive())&#123;</span><br><span class="line">            <span class="comment">//将未处理的请求放入map中</span></span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            <span class="comment">//构建RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder().data(rpcRequest)</span><br><span class="line">                    .codec(SerializationTypeEnum.KYRO.getCode())</span><br><span class="line">                    .compress(CompressTypeEnum.GZIP.getCode())</span><br><span class="line">                    .messageType(RpcConstants.REQUEST_TYPE).build();</span><br><span class="line">            <span class="comment">//将请求发送给服务器</span></span><br><span class="line">            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;客户端发送消息: [&#123;&#125;]&quot;</span>, rpcMessage);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future.cause());</span><br><span class="line">                    log.error(<span class="string">&quot;发送消息时发生错误: &quot;</span>, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">(String interfaceName)</span>&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelProvider.get(interfaceName);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）服务端"><a href="#2）服务端" class="headerlink" title="2）服务端"></a>2）服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerConfig serverConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceProvider</span> <span class="variable">serviceProvider</span> <span class="operator">=</span> SingletonFactory.getInstance(ZkServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        CustomShutdownHook.getCustomShutdownHook().clearAll();</span><br><span class="line">        <span class="comment">//创建bossGroup和workerGroup</span></span><br><span class="line">        <span class="comment">//bossGroup只负责连接请求，workerGroup负责读写请求</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">//创建服务端启动对象</span></span><br><span class="line">        <span class="type">DefaultEventExecutorGroup</span> <span class="variable">serviceHandlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(</span><br><span class="line">                <span class="comment">//cpu核心数*2</span></span><br><span class="line">                Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">                <span class="comment">//创建线程工厂</span></span><br><span class="line">                ThreadPoolFactoryUtil.createThreadFactory(<span class="string">&quot;service-handler-group&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取本机ip</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line"><span class="comment">//                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span></span><br><span class="line">                    <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 当客户端第一次进行请求的时候才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="comment">//                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoEncoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoDecoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                            p.addLast(serviceHandlerGroup, <span class="keyword">new</span> <span class="title class_">NettyRpcServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//绑定端口，启动服务，sync()同步等待绑定成功，然后获取到ChannelFuture</span></span><br><span class="line">            bootstrap.bind(host, serverConfig.getServerPort()).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;启动NettyRpcServer服务时发生错误: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            log.info(<span class="string">&quot;断开NettyRpcServer服务&quot;</span>);</span><br><span class="line"><span class="comment">//            bossGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            workerGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            serviceHandlerGroup.shutdownGracefully();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴露服务 -- 如 127.0.0.1:8080 下的UserService、ProductService...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcServiceConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exposeService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        registerService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initServerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> PropertiesBootstrap.loadServerConfigFromLocal();</span><br><span class="line">        <span class="built_in">this</span>.setServerConfig(serverConfig);</span><br><span class="line">        SERVER_CONFIG = serverConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简易RPC框架-网络传输模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-网络传输模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 网络传输模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 网络传输模块&lt;/h3&gt;&lt;h4 id=&quot;1、前言&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 3</title>
    <link href="http://example.com/2023/05/14/rpc-framework-3/"/>
    <id>http://example.com/2023/05/14/rpc-framework-3/</id>
    <published>2023-05-14T14:21:03.000Z</published>
    <updated>2023-05-15T07:55:26.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简易RPC框架-服务订阅、发现模块"><a href="#简易RPC框架-服务订阅、发现模块" class="headerlink" title="简易RPC框架 - 服务订阅、发现模块"></a>简易RPC框架 - 服务订阅、发现模块</h3><h4 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h4><p>首先先看Rpc客户端的设计思路：</p><p><img src="/2023/05/14/rpc-framework-3/ttt.png" alt="ttt"></p><h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><p>这里也是直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyRpcClient client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">needInitClient</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasInitClientConfig</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = bean.getClass();</span><br><span class="line">        <span class="keyword">final</span> Field[] declaredFields = targetClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(RpcReference.class))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hasInitClientConfig) &#123;</span><br><span class="line">                    <span class="comment">//每个Reference对应一个RpcClient</span></span><br><span class="line">                    client = <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">                    client.initClientApplication();</span><br><span class="line">                    hasInitClientConfig = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                needInitClient = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcReference</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> RpcServiceConfig.builder()</span><br><span class="line">                        .group(annotation.group())</span><br><span class="line">                        .version(annotation.version())</span><br><span class="line">                        .build();</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">RpcClientProxy</span> <span class="variable">rpcClientProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClientProxy</span>(client, rpcServiceConfig);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> rpcClientProxy.getProxy(field.getType());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//代理类替换</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                    <span class="comment">//服务订阅</span></span><br><span class="line">                    client.doSubscribeService(field.getType());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务启动后，自动连接服务端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationReadyEvent 服务启动事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent applicationReadyEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needInitClient &amp;&amp; client != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot; ================== [&#123;&#125;] started success ================== &quot;</span>, client.getClass().getName());</span><br><span class="line">            ConnectionHandler.setBootstrap(client.getBootstrap());</span><br><span class="line">            <span class="comment">//将Client与每个服务提供者连接</span></span><br><span class="line">            client.doConnectServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们这里用到了ApplicationContext的事件机制，因为需要需要实现通道连接时保证所有的@Reference都已进行服务订阅，查了很多资料，学到了这个方法。首先该类实现了ApplicationListener，那么每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。我们这里监听的是ApplicationReadyEvent事件，当上下文已经准备完毕的时候触发onApplicationEvent()方法。</p><p>通过ApplicationContext的事件机制，我们就可以实现这个效果：Spring扫描整个类的@Reference属性，然后进行服务订阅，将@Reference对应的信息封装成URL对象。当上下文准备完毕，意味着所有的@Reference属性都已进行订阅，此时会触发onApplicationEvent()方法，将Client与每个@Reference属性对应的RpcServer建立一个Channel，之后当需要远程调用时，就可以在代理类中获取对应的Channel进行通信。</p><p>在这里，将URL和代理类贴出来，方便大家理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URL</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里面可以自定义不限进行扩展</span></span><br><span class="line"><span class="comment">     * 分组</span></span><br><span class="line"><span class="comment">     * 权重</span></span><br><span class="line"><span class="comment">     * 服务提供者的地址</span></span><br><span class="line"><span class="comment">     * 服务提供者的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParameter</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameters.putIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTERFACE_NAME</span> <span class="operator">=</span> <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestTransport rpcRequestTransport;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServiceConfig rpcServiceConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientProxy</span><span class="params">(RpcRequestTransport rpcRequestTransport, RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestTransport = rpcRequestTransport;</span><br><span class="line">        <span class="built_in">this</span>.rpcServiceConfig = rpcServiceConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 代理类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行方法: [&#123;&#125;]&quot;</span>, method.getName());</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .requestId(UUID.randomUUID().toString())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .group(rpcServiceConfig.getGroup())</span><br><span class="line">                .version(rpcServiceConfig.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">        RpcResponse&lt;Object&gt; rpcResponse = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//通过当前服务对应的唯一channel向服务器发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (rpcRequestTransport <span class="keyword">instanceof</span> NettyRpcClient) &#123;</span><br><span class="line">            CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">            rpcResponse = completableFuture.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcRequestTransport <span class="keyword">instanceof</span> SocketRpcClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!rpcResponse.getRequestId().equals(rpcRequest.getRequestId()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.REQUEST_NOT_MATCH_RESPONSE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse.getCode() == <span class="literal">null</span> || !rpcResponse.getCode().equals(RpcResponseCode.SUCCESS.getCode()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于服务订阅、通道连接的代码大家可以根据自己的需要进行设计，我这里就不再描述了。</p><p>至于负载均衡，可以在通道连接的时候设计，也可以按大家的想法来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简易RPC框架-服务订阅、发现模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务订阅、发现模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务订阅、发现模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务订阅、发现模块&lt;/h3&gt;&lt;h4 id=&quot;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 2</title>
    <link href="http://example.com/2023/05/12/rpc-framework-2/"/>
    <id>http://example.com/2023/05/12/rpc-framework-2/</id>
    <published>2023-05-12T06:18:57.000Z</published>
    <updated>2023-05-15T00:16:19.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简易RPC框架-服务注册模块"><a href="#简易RPC框架-服务注册模块" class="headerlink" title="简易RPC框架 - 服务注册模块"></a>简易RPC框架 - 服务注册模块</h3><h4 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h4><p>紧接上文，结合框架结构图进行讲解：</p><p><img src="/2023/05/12/rpc-framework-2/xxx.jpg" alt="xxx"></p><p>本节主要讲解服务注册的细节，首先定义了三个注解：@RpcService、@RpcReference、@RpcScan</p><p>@RpcService用于标注服务提供者，@RpcReference用于标注服务消费者，@RpcScan用于扫描特定的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcScan &#123;</span><br><span class="line">    String[] basePackage() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><p>首先服务端执行的大致流程如下：</p><p><img src="/2023/05/12/rpc-framework-2/xxxx.png" alt="xxxx"></p><p>服务注册模块采用注解加包扫描的方式去实现，将标注了@RpcService服务的元信息注册到Zookeeper，然后客户端要向服务端发送消息时，就可以从Zookeeper中获取远程服务的信息完成服务的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; beanMap = applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span>(beanMap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明当前应用内部不需要对外暴露服务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NettyRpcServer</span> <span class="variable">nettyRpcServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">        nettyRpcServer.initServerConfig();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanMap.keySet()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;]&quot;</span>, beanName, RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">//build RpcServiceProperties</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanMap.get(beanName);</span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//构建暴露的服务的信息</span></span><br><span class="line">                rpcServiceConfig = RpcServiceConfig.builder()</span><br><span class="line">                        .host(InetAddress.getLocalHost().getHostAddress())</span><br><span class="line">                        .group(rpcService.group())</span><br><span class="line">                        .version(rpcService.version())</span><br><span class="line">                        .service(bean)</span><br><span class="line">                        .port(SERVER_CONFIG.getServerPort()).build();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            nettyRpcServer.exposeService(rpcServiceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动服务端，监听配置文件中定义的IP:PORT</span></span><br><span class="line">        nettyRpcServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中服务注册到Zookeeper的代码我就不放上来了，大家可以根据自己的需要自己定义规则。需要注意的是，在注册时我们还定义了一个服务端缓存类，用于存储服务端提供的类信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonServerCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServerConfig SERVER_CONFIG;</span><br><span class="line">    <span class="comment">//服务端发布的服务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; SERVICE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注册时需要把暴露的服务缓存到本地，后面才能为客户端提供服务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcServiceName</span> <span class="operator">=</span> rpcServiceConfig.getRpcServiceName();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> rpcServiceConfig.getService();</span><br><span class="line">    <span class="comment">//将服务名称和服务对象放入map中</span></span><br><span class="line">    <span class="keyword">if</span>(SERVICE_MAP.containsKey(rpcServiceName))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SERVICE_MAP.put(rpcServiceName, service);</span><br><span class="line">    log.info(<span class="string">&quot;服务注册 - 成功注册服务: &#123;&#125; 和接口: &#123;&#125;&quot;</span>, rpcServiceName, service.getClass().getInterfaces());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于客户端调用（服务订阅、服务发现）的细节我们会在后续的文章中进行讲解。</p><p>包扫描的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line">    <span class="comment">//扫描框架项目的bean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_BEAN_BASE_PACKAGE</span> <span class="operator">=</span> <span class="string">&quot;com.hurried1y&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PACKAGE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">&quot;basePackage&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注解属性</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(RpcScan.class.getName()));</span><br><span class="line">        <span class="comment">//获取注解属性中的basePackage</span></span><br><span class="line">        String[] rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(annotationAttributes != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = annotationAttributes.getStringArray(BASE_PACKAGE_ATTRIBUTE_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有指定扫描包，则默认扫描当前类所在的包</span></span><br><span class="line">        <span class="keyword">if</span>(rpcScanBasePackages.length == <span class="number">0</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) importingClassMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, RpcService.class);</span><br><span class="line">        <span class="comment">//扫描 Component 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">componentScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, Component.class);</span><br><span class="line">        <span class="comment">//设置扫描包</span></span><br><span class="line">        <span class="keyword">if</span>(resourceLoader != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(resourceLoader);</span><br><span class="line">            componentScanner.setResourceLoader(resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">springBeanAmount</span> <span class="operator">=</span> componentScanner.scan(SPRING_BEAN_BASE_PACKAGE);</span><br><span class="line">        log.info(<span class="string">&quot;springBeanScanner扫描的数量 [&#123;&#125;]&quot;</span>, springBeanAmount);</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rpcServiceCount</span> <span class="operator">=</span> rpcServiceScanner.scan(rpcScanBasePackages);</span><br><span class="line">        log.info(<span class="string">&quot;rpcServiceScanner扫描的数量 [&#123;&#125;]&quot;</span>, rpcServiceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简易RPC框架-服务注册模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务注册模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务注册模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务注册模块&lt;/h3&gt;&lt;h4 id=&quot;1、结构设计&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 1</title>
    <link href="http://example.com/2023/05/12/rpc-framework-1/"/>
    <id>http://example.com/2023/05/12/rpc-framework-1/</id>
    <published>2023-05-12T05:24:57.000Z</published>
    <updated>2023-05-15T00:16:22.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简易RPC框架-前言"><a href="#简易RPC框架-前言" class="headerlink" title="简易RPC框架 - 前言"></a>简易RPC框架 - 前言</h3><h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>Rpc框架想必大家都不陌生，常见的开源RPC框架如Dubbo、gRpc、Thrift等，为啥想到要手动实现一个Rpc框架，主要是本人对网络编程很感兴趣，想通过这个来加强自己对Java以及网络编程的理解，也能体验一下钻研的快乐。</p><h4 id="2、基础设计"><a href="#2、基础设计" class="headerlink" title="2、基础设计"></a>2、基础设计</h4><p>这个Rpc框架的最初设计大概如下图：</p><p><img src="/2023/05/12/rpc-framework-1/image-20230512133521798.png" alt="image-20230512133521798"></p><p>最初是尝试通过NIO去实现的，每个服务对应一个Client，即每个服务绑定一个Channel，然后通过Selector轮巡监听服务端的消息。服务端再这里扮演的是一个消息中转站的角色。显而易见的，这个设计存在着一个致命的问题，服务端怎么去分辨Selector上的每个通道对应的是哪个服务，查了很多资料都没有较好的办法，这个方案就不了了之了（最初测试的时候，我试过直接把服务端发布的服务对象序列化到Redis，但存在一些问题，比如当发布的服务中有不可序列化的属性时，就会出现问题）。</p><p>这个方案行不通，之后研究了一下Dubbo服务注册的大概思路，结合掘金里DannyIdea（小林）的<a href="https://juejin.cn/book/7047357110337667076/section">Java开发者的RPC实战课</a> 里对服务注册、订阅的讲解，对原本的设计进行了改进。</p><p>以下是Dubbo的基本架构图：</p><p><img src="/2023/05/12/rpc-framework-1/u=341734470,1171504543&fm=253&fmt=auto&app=138&f=JPEG.jpg" alt="u=341734470,1171504543&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG"></p><p>以下是现在对于框架的设计思路：</p><p><img src="/2023/05/12/rpc-framework-1/xxx.jpg" alt="xxx"></p><p>目前通信方式也由最初的NIO换成了Netty，实现自定义协议进行编码解码，解决了黏包半包等问题，后续可以扩展不同的序列化方式。</p><p>项目的地址在本人的gitee和github仓库：<a href="https://github.com/Hurried1y/rpc-framework/%EF%BC%8Chttps://gitee.com/hurried1y/rpc-framework">https://github.com/Hurried1y/rpc-framework/，https://gitee.com/hurried1y/rpc-framework</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简易RPC框架-前言&quot;&gt;&lt;a href=&quot;#简易RPC框架-前言&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 前言&quot;&gt;&lt;/a&gt;简易RPC框架 - 前言&lt;/h3&gt;&lt;h4 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring本地事务失效问题</title>
    <link href="http://example.com/2023/01/14/local-transaction-logs/"/>
    <id>http://example.com/2023/01/14/local-transaction-logs/</id>
    <published>2023-01-14T13:01:16.000Z</published>
    <updated>2023-01-14T13:01:55.734Z</updated>
    
    <content type="html"><![CDATA[<p>​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在spring中，事务的默认传播模式是propagation = Propagation.REQUIRED，即当b()方法需要一个事务，a()方法的事务会默认传递给b()方法，那么当a()方法中任何一处抛出异常，都会连同b()方法一起回滚。但存在的问题是。此时在b()方法中不论对事务做了什么设置，都是无效的，因为用的是a()方法的事务。再看c()方法，声明了propagation = Propagation.REQUIRES_NEW，即使用一个新事务，这样虽然配置能生效，但当a()方法抛出异常时，c()方法不会跟着一起回滚，显然达不到业务需求。</p><p>​        造成上面的原因是，同一个对象内的事务方法互相调用，绕过了代理对象。因为spring中的事务是通过代理对象实现的，那么能不能这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过代理对象调用方法，虽然配置会生效，但这会出现循环依赖问题，显然也不行。</p><p>正确的解决方法是使用代理对象来解决：</p><ol><li><p>引入aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在启动类标注@EnableAspectJAutoProxy(exposeProxy = true)</p><p>spring aop中有两种代理模式，一种是jdk动态代理，另外一种是cglib代理。</p><p>​        jdk动态代理是<code>JDK</code>原生的，不需要任何依赖即可使用，缺点是如果要使用<code>JDK</code>动态代理，被代理的类必须实现了接口，否则无法代理；<code>JDK</code>动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，<code>Spring</code>仍然会使用<code>JDK</code>的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。<code>JDK</code>动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低。</p><p>​        cglib代理的优点是，使用<code>CGLib</code>代理的类，不需要实现接口，因为<code>CGLib</code>生成的代理类是直接继承自需要被代理的类；<code>CGLib</code>生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；<code>CGLib</code>生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理。</p><p>​        在这里我们使用cglib代理，并配置对外暴露代理对象</p></li></ol><p>做好这些配置后，回到我们最初的场景，这时候我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Service&#123;</span><br><span class="line">@Transactional(timeout = 30)</span><br><span class="line">    public void a()&#123;</span><br><span class="line">    //拿到当前类的代理对象</span><br><span class="line">    Service service = (Service)AopContext.currentProxy();</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void b()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void c()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Feign远程调用遇到的坑</title>
    <link href="http://example.com/2023/01/14/feign-logs/"/>
    <id>http://example.com/2023/01/14/feign-logs/</id>
    <published>2023-01-14T12:58:07.000Z</published>
    <updated>2023-01-14T13:02:00.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Feign远程调用丢失请求头问题"><a href="#1、Feign远程调用丢失请求头问题" class="headerlink" title="1、Feign远程调用丢失请求头问题"></a>1、Feign远程调用丢失请求头问题</h4><p>​    在订单服务向购物车服务发起远程调用时，在购物车服务中获取不到用户信息，原因是用户的信息是基于SpringSession保存在redis中，key存在于浏览器的cookie中，当在浏览器中发起请求时，由于请求会默认带上cookie，所以可以正常获取到数据信息，但在这个业务中是由Feign发起的远程调用走到购物车服务，Feign远程调用时会创建一个新的request，里面没有cookie数据，所以在购物车服务中获取不到用户数据。</p><p>​    解决办法，由于Feign在远程调用之前都会调用很多拦截器(默认没有拦截器)，可以写一个Feign的请求拦截器扩展Feign的功能，在新的request中加入cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">                <span class="comment">//通过上下文环境保持器拿到当前请求的所有属性RequestAttributes -&gt;</span></span><br><span class="line"><span class="comment">//                RequestAttributes attributes = RequestContextHolder.getRequestAttributes();</span></span><br><span class="line">                <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">                <span class="comment">//同步请求头数据</span></span><br><span class="line">                template.header(<span class="string">&quot;Cookie&quot;</span>, request.getHeader(<span class="string">&quot;Cookie&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、Feign异步情况丢失上下文问题"><a href="#2、Feign异步情况丢失上下文问题" class="headerlink" title="2、Feign异步情况丢失上下文问题"></a>2、Feign异步情况丢失上下文问题</h4><p>​    在上一个问题中，对于Feign的远程调用请求头丢失问题，引入了RequestInterceptor来解决，但这种办法只能针对同步问题，当使用异步编排发起Feign远程调用时，ServletRequestAttributes中就回去不到原来线程的request数据，就会报空指针异常。</p><p><img src="/2023/01/14/feign-logs/image-20230108205538489.png" alt="image-20230108205538489"></p><p>​    如上图所示，RequestContextHolder是利用ThreadLocal共享数据，所以会发生这种问题。</p><p>​    解决办法是在异步编排之前，先获取主线程的上下文，在进入新线程后再把主线程的上下文放到新线程里面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、Feign远程调用丢失请求头问题&quot;&gt;&lt;a href=&quot;#1、Feign远程调用丢失请求头问题&quot; class=&quot;headerlink&quot; title=&quot;1、Feign远程调用丢失请求头问题&quot;&gt;&lt;/a&gt;1、Feign远程调用丢失请求头问题&lt;/h4&gt;&lt;p&gt;​    在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>frp内网穿透</title>
    <link href="http://example.com/2023/01/14/frp/"/>
    <id>http://example.com/2023/01/14/frp/</id>
    <published>2023-01-14T12:54:16.000Z</published>
    <updated>2023-01-14T13:02:04.947Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​    简单介绍一下，frp主要有两个部分，客户端(frpc)和服务端(frps)，服务端需要部署在具有公网ip的机器上（也就是我们自己买的云服务器），客户端就是我们需要进行穿透的电脑（本地机器）。</p><h4 id="二、服务端配置"><a href="#二、服务端配置" class="headerlink" title="二、服务端配置"></a>二、服务端配置</h4><p>​    首先需要在服务端下载frp并解压。输入命令<code>arch</code>查看处理器架构，根据此去github下载对应的frp版本，然后下载解压完就行。</p><p>​    这里我们只需要修改frps.ini文件的配置就可以了，其他与frpc相关的文件都可删去。由于只需要进行Web服务的穿透访问，这里只配置Web，其他配置按需百度添加即可，重点是成功搭建并运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">#frp监听的端口，即与本地机器建立通信的端口，默认是7000，可以改成其他的（不建议动）</span><br><span class="line">bind_port = 7000</span><br><span class="line">#该端口就是以后访问web服务需要用到的端口，可自定义</span><br><span class="line">vhost_http_port = 3000</span><br><span class="line">#授权码，建议不要太简单。这个token之后在客户端会用到</span><br><span class="line">#注意:不要再token后面加#注释进行注释，也会被算上token内容，导致认证失败!写注释最好单独一行</span><br><span class="line">token = 123456</span><br><span class="line"></span><br><span class="line">#frp管理后台端口,请按自己需求更改，这个东西并不是一定要，这里还是提一下</span><br><span class="line">dashboard_ _port = 7508</span><br><span class="line">#frp管理后台用户名和密码,请改成自己的</span><br><span class="line">dashboard_user =</span><br><span class="line">dashboard_pwd =</span><br><span class="line">enable_prometheus = true</span><br></pre></td></tr></table></figure><p>配置好后就可以启动了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><p>这里可以用systemctl执行，附上配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps daemon</span><br><span class="line">After=syslog.target  network.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini</span><br><span class="line">Restart= always</span><br><span class="line">RestartSec=1min</span><br><span class="line">ExecStop=/usr/bin/killall frps</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="三、客户端配置"><a href="#三、客户端配置" class="headerlink" title="三、客户端配置"></a>三、客户端配置</h4><p>​    和服务端一样，下载解压。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">#服务器的ip地址</span><br><span class="line">server_addr =</span><br><span class="line">#服务器监听的端口，即frps.ini里的bind_port</span><br><span class="line">server_port = 7000</span><br><span class="line">#授权码</span><br><span class="line">token =</span><br><span class="line"></span><br><span class="line">#配置http服务，可用于第三方接口（java开发、小程序开发等）等远程调试</span><br><span class="line">[web]</span><br><span class="line">#服务类型</span><br><span class="line">type = http</span><br><span class="line">#需要被穿透的本地ip，不用改，相当于localhost</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">#本地项目运行服务提供的端口，根据项目自定义</span><br><span class="line">local_port = 3000</span><br><span class="line">#web域名</span><br><span class="line">custom_domains =</span><br><span class="line">#远程服务器监听web服务的端口，需要即frps.ini里的vhost_http_port</span><br><span class="line">remote_port = 3000</span><br></pre></td></tr></table></figure><p>客户端的话，以windows系统为例，在cmd终端cd进frp目录，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><p>也可以将执行命令打成bat脚本，这里也附上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;%1&quot; == &quot;h&quot; goto begin</span><br><span class="line">mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit</span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line">D:</span><br><span class="line">cd Tools\frp</span><br><span class="line">.\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;​    简单介绍一下，frp主要有两个部分，客户端(frpc)和服务端(frps)，服务端需要部署在具有公网ip的机器上（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建redis哨兵集群</title>
    <link href="http://example.com/2022/11/05/sentinel-colony/"/>
    <id>http://example.com/2022/11/05/sentinel-colony/</id>
    <published>2022-11-05T09:06:28.000Z</published>
    <updated>2022-11-05T11:28:46.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h1><h2 id="1-集群结构"><a href="#1-集群结构" class="headerlink" title="1.集群结构"></a>1.集群结构</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><h4 id="1-1哨兵的作用"><a href="#1-1哨兵的作用" class="headerlink" title="1.1哨兵的作用"></a>1.1哨兵的作用</h4><ul><li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p></li></ul><h4 id="1-2服务状态监控"><a href="#1-2服务状态监控" class="headerlink" title="1.2服务状态监控"></a>1.2服务状态监控</h4><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul><h4 id="1-3选举新的master"><a href="#1-3选举新的master" class="headerlink" title="1.3选举新的master"></a>1.3选举新的master</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><h4 id="1-2如何实现故障转移"><a href="#1-2如何实现故障转移" class="headerlink" title="1.2如何实现故障转移"></a>1.2如何实现故障转移</h4><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.237.131 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p><img src="/2022/11/05/sentinel-colony/image-20210701215227018.png" alt="image-20210701215227018"></p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.237.131</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.237.131</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.237.131</td><td align="center">27003</td></tr></tbody></table><h2 id="2-准备实例和配置"><a href="#2-准备实例和配置" class="headerlink" title="2.准备实例和配置"></a>2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在usr/local/redis-colony文件夹内创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> s1 s2 s3</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105170909619.png" alt="image-20221105170909619"></p><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.237.131</span><br><span class="line">sentinel monitor mymaster 192.168.237.131 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/usr/local/redis-colony/s1&quot;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.237.131 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.237.131 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值，此时配了3台sentinel，有两台以上就认为挂了</li></ul></li></ul><p>然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h2><p>先启动redis主从集群</p><p>7002</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190006728.png" alt="image-20221105190006728"></p><p>7003</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190038169.png" alt="image-20221105190038169"></p><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure><p>启动后：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105181013812.png" alt="image-20221105181013812"></p><p><img src="/2022/11/05/sentinel-colony/image-20221105181040781.png" alt="image-20221105181040781"></p><p><img src="/2022/11/05/sentinel-colony/image-20221105181059522.png" alt="image-20221105181059522"></p><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4.测试"></a>3.4.测试</h2><p>尝试让master节点7001宕机</p><p><img src="/2022/11/05/sentinel-colony/image-20221105181244740.png" alt="image-20221105181244740"></p><p>查看sentinel27002的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190717411.png" alt="image-20221105190717411"></p><ol><li>第一行，+sdown，sentinel主观认为7001下线</li><li>第三行，+vote-for-leader，sentinel选出一个leader，选出的sentinel实例去执行故障切换</li><li>第四行，+odown，quorum达标，sentinel客观认为7001下线</li><li>第七行，+switch-master，选7003为新的master</li></ol><p>查看27003的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190809034.png" alt="image-20221105190809034"></p><p>查看7002的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190856348.png" alt="image-20221105190856348"></p><ol><li>第一行，7002与其主机7001之间的连接断开</li><li>第三行，由于sentinel实例执行了故障切换，把7003选举为新的master，所以自动更改7002的配置</li><li>第四行，Connecting to master 192.168.237.131:7003 建立7002与其新master7003之间的连接</li><li>第八行，Trying a partial…，重新执行数据同步psync</li></ol><p>查看7003的日志</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190927905.png" alt="image-20221105190927905"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建哨兵集群&quot;&gt;&lt;a href=&quot;#搭建哨兵集群&quot; class=&quot;headerlink&quot; title=&quot;搭建哨兵集群&quot;&gt;&lt;/a&gt;搭建哨兵集群&lt;/h1&gt;&lt;h2 id=&quot;1-集群结构&quot;&gt;&lt;a href=&quot;#1-集群结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建redis主从集群</title>
    <link href="http://example.com/2022/11/05/redis-colony/"/>
    <id>http://example.com/2022/11/05/redis-colony/</id>
    <published>2022-11-05T08:00:08.000Z</published>
    <updated>2022-11-05T09:03:44.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从集群"><a href="#Redis主从集群" class="headerlink" title="Redis主从集群"></a>Redis主从集群</h1><h2 id="1-集群结构"><a href="#1-集群结构" class="headerlink" title="1.集群结构"></a>1.集群结构</h2><p>我们搭建的主从集群结构如图：</p><p><img src="/2022/11/05/redis-colony/image-20210630111505799.png" alt="image-20210630111505799"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.237.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.237.101</td><td align="center">7002</td><td align="center">slave</td></tr><tr><td align="center">192.168.237.101</td><td align="center">7003</td><td align="center">slave</td></tr></tbody></table><h2 id="2-准备实例和配置"><a href="#2-准备实例和配置" class="headerlink" title="2.准备实例和配置"></a>2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在usr/local/redis-colony文件夹内创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/11/05/redis-colony/image-20221105162330778.png" alt="image-20221105162330778"></p><p>2）恢复原始配置</p><p>修改redis-5.0.5/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启RDB</span></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="attr">save</span> <span class="string">3600 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 100</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 关闭AOF</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-5.0.5/redis.conf文件拷贝到三个目录中（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7001</span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7002</span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7003</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 | xargs -t -n 1 ../redis-5.0.5/redis.conf</span><br></pre></td></tr></table></figure><p>4）修改每个实例的端口、工作目录</p><p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7003\//g&#x27;</span> 7003/redis.conf</span><br></pre></td></tr></table></figure><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># redis实例的声明 IP</span><br><span class="line">replica-announce-ip 192.168.237.131</span><br></pre></td></tr></table></figure><p>每个目录都要改，我们一键完成修改（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一执行</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者一键修改</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7001/redis.conf</span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line">redis-server 7003/redis.conf</span><br></pre></td></tr></table></figure><p>启动后：</p><p><img src="/2022/11/05/redis-colony/image-20221105163747112.png" alt="image-20221105163747112"></p><p>如果要一键停止，可以运行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure><h2 id="4-开启主从关系"><a href="#4-开启主从关系" class="headerlink" title="4.开启主从关系"></a>4.开启主从关系</h2><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure></li></ul><p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>这里我们为了演示方便，使用方式二。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7002</span></span><br><span class="line">redis-cli -p 7002</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure><p>通过redis-cli命令连接7003，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7003</span></span><br><span class="line">redis-cli -p 7003</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure><p>然后连接 7001节点，查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/11/05/redis-colony/image-20221105165646834.png" alt="image-20221105165646834"></p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 100 </code></p><p><img src="/2022/11/05/redis-colony/image-20221105165820844.png" alt="image-20221105165820844"></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p><p><img src="/2022/11/05/redis-colony/image-20221105165907462.png" alt="image-20221105165907462"></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，而slave节点只能执行读操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis主从集群&quot;&gt;&lt;a href=&quot;#Redis主从集群&quot; class=&quot;headerlink&quot; title=&quot;Redis主从集群&quot;&gt;&lt;/a&gt;Redis主从集群&lt;/h1&gt;&lt;h2 id=&quot;1-集群结构&quot;&gt;&lt;a href=&quot;#1-集群结构&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>著名的三色标记法</title>
    <link href="http://example.com/2022/10/17/Tri-colour-marking/"/>
    <id>http://example.com/2022/10/17/Tri-colour-marking/</id>
    <published>2022-10-17T12:44:16.000Z</published>
    <updated>2022-10-17T13:57:38.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行（STW）。</p><p>在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。包含“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。</p><h2 id="二、三色标记法"><a href="#二、三色标记法" class="headerlink" title="二、三色标记法"></a>二、三色标记法</h2><p>顾名思义，用三种颜色进行标记，其用在CMS垃圾回收器工作的并发标记阶段。</p><hr><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达(白色对象会被当成垃圾对象)。</li></ul><ul><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用（子对象）都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象(黑色对象不会当成垃圾对象)。</li></ul><ul><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。当垃圾回收线程从暂停中再次回来，不会扫描灰色对象，而是直接扫描灰色对象的引用。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li><p>初始时，全部对象都是白色的</p></li><li><p>GC Roots直接引用的对象变成灰色</p></li><li><p>从灰色集合中获取元素：</p><p>3.1 将本对象直接引用的对象标记为灰色</p><p>3.2 将本对象标记为黑色</p></li><li><p>重复步骤3，直到灰色的对象集合变为空</p></li><li><p>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</p></li></ol><p>当Stop The Word时，对象间的引用是不会发生变化的，因为用户线程中断了，可以轻松完成标记，但是在并发标记的时候，标记期间用户线程还在跑，对象间的引用可能发生变化，多标和漏标的情况就可能会发生</p><p><strong>多标(又叫浮动垃圾)</strong></p><p>假设此时我们遍历到了D对象，此时D被标记成了灰色</p><p><img src="/2022/10/17/Tri-colour-marking/img1.png" alt="img1"></p><p> 此时线程发生B取消了对D的引用</p><p><img src="/2022/10/17/Tri-colour-marking/img4.png" alt="img4"></p><p>这时候B-&gt;D的引用没了，D应该是白色，但是因为先前D已经被标记成灰色了，所以D对象仍然会被当成存活对象遍历下去。最终结果：这部分对象仍然会被标记为存活对象，本轮GC不会回收他们的内存。这部分因为并发而造成的本应该回收但是没有回收的对象被称为”浮动垃圾”，我们稍微一想也能想到，<strong>浮动垃圾不会影响应用程序的正确性，只需要等到下一轮GC到来就会被回收了</strong>。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p><strong>漏标(读写屏障)</strong></p><p>假设GC线程已经遍历到D对象，此时D被标记为灰色 </p><p><img src="/2022/10/17/Tri-colour-marking/img2.png" alt="img2"></p><p>但是此时有代码执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/17/Tri-colour-marking/img3.png" alt="img3"></p><p>此时D到E的引用消失，B生成了对E的引用。当GC线程继续时，因为D已经没有了对E的引用，所以不会遍历到E，E也就不会标志为灰色，同时B已经标志为黑色了，不会再被遍历，那么也就导致E一直是白色的，最后被当成垃圾处理，这显然与事实不符，E是可打的，但是因为并发的影响漏标了E，使得E被垃圾回收，明显影响了应用程序的正确性，这是不可接受的。</p><p>分析一下，漏标只有同时满足以下两个条件时才会发生：</p><ol><li><p>灰色对象断开了白色对象的引用</p></li><li><p>黑色对象重新引用了该白色对象</p></li></ol><p>从代码角度看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p>只要在上面三步中修改任意一步就可以将丢失的E记录下来，然后当作灰色对象继续遍历</p><p>根据以上思路有两种解决办法：</p><h5 id="一、写屏障-阻止第二步和第三步"><a href="#一、写屏障-阻止第二步和第三步" class="headerlink" title="一、写屏障(阻止第二步和第三步)"></a>一、写屏障(阻止第二步和第三步)</h5><p>1.写屏障 + SATB</p><p>当对象D的引用发生变化时，利用写屏障，将D原来的引用对象记录下来，这样可以尝试保留开始时的对象图，保证标记依然按照原本的路线走</p><p>2.写屏障 + 增量更新</p><p>当对象B的引用发生变化时，利用写屏障，将B新的引用对象E记录下来</p><p>即当有新的引用插入进来时，记录下新的引用</p><p>这种思路不要求保留原始对象图，而是针对新的引用记录下来等待遍历即增量更新</p><h5 id="二、读屏障-阻止第一步"><a href="#二、读屏障-阻止第一步" class="headerlink" title="二、读屏障(阻止第一步)"></a>二、读屏障(阻止第一步)</h5><p>读屏障针对第一步，当读取引用对象的时候，一律记录下来，显然这种方法非常保守，但是安全。</p><p>将记录下的引用遍历就是了</p><p>在现代的垃圾回收器当中可达性分析算法的垃圾回收器几乎都借鉴了三色标记法的思想。</p><p>在Java HotSpot VM中</p><p>CMS采用的是：写屏障 + 增量更新</p><p>G1采用的是：写屏障 + SATB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用的垃圾回收算法和垃圾回收器</title>
    <link href="http://example.com/2022/10/17/GC/"/>
    <id>http://example.com/2022/10/17/GC/</id>
    <published>2022-10-17T10:07:37.000Z</published>
    <updated>2022-10-17T13:03:27.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收器，能实现内存垃圾的自动回收，虽然牺牲了一定的运行效率，但大大地提高了开发效率，那么问题来了，常用的GC都有哪些？常用的GC算法都有哪些？GC是如何定义和定位垃圾的呢？</p><h4 id="二、What-is-Garbage"><a href="#二、What-is-Garbage" class="headerlink" title="二、What is Garbage"></a>二、What is Garbage</h4><p>​        在谈论垃圾回收算法和垃圾回收器之前，我们得先了解一下垃圾的基本概念。</p><h5 id="（1）Garbage的定义"><a href="#（1）Garbage的定义" class="headerlink" title="（1）Garbage的定义"></a>（1）Garbage的定义</h5><p>​        在高级语言中通常将没有引用指向的内存定义为垃圾。</p><h5 id="（2）Garbage的定位"><a href="#（2）Garbage的定位" class="headerlink" title="（2）Garbage的定位"></a>（2）Garbage的定位</h5><p>​        在python中，采用的是垃圾定位算法是reference count引用计数法，即记录每块内存被引用指向的数量，当指向某块内存的数量为0时，就把这块内存定义为垃圾，被GC自动释放（这让我想起了拓扑排序0.0），但这种算法有一个弊端，其无法解决“闭环”的情况，即多块内存相互引用形成闭环，与其他内存块无依赖。</p><p>​        而在java中，则使用Root Searching根可达算法来定位垃圾，从程序的根（如main方法）开始，若无法抵达某块内存，就把该块内存判作垃圾，由GC进行释放，该算法很好的解决了”内存闭环“问题。</p><h4 id="三、GC-Algorithms"><a href="#三、GC-Algorithms" class="headerlink" title="三、GC Algorithms"></a>三、GC Algorithms</h4><h5 id="（1）Mark-Sweep"><a href="#（1）Mark-Sweep" class="headerlink" title="（1）Mark-Sweep"></a>（1）Mark-Sweep</h5><p>​        标记清除法，将某块内存标记为垃圾，然后清除。算法的缺点，会产生碎片空间。</p><p><img src="/2022/10/17/GC/Mark-Sweep.png" alt="Mark-Sweep"></p><h5 id="（2）Copying"><a href="#（2）Copying" class="headerlink" title="（2）Copying"></a>（2）Copying</h5><p>​        拷贝法，将内存区分两半，每次运行时在一半中找出所有存活对象，然后整体性的复制到另外半边，同时排列好，然后把原来半边整体回收。算法的缺点是浪费内存。</p><p><img src="/2022/10/17/GC/Copying.png" alt="Copying"></p><h5 id="（3）Mark-Compact"><a href="#（3）Mark-Compact" class="headerlink" title="（3）Mark-Compact"></a>（3）Mark-Compact</h5><p>​        标记压缩法，将标记为垃圾的内存回收，并且排列好。缺点是效率相对较低。</p><p><img src="/2022/10/17/GC/Mark-Compact.png" alt="Mark-Compact"></p><h4 id="四、Garbage-Collector"><a href="#四、Garbage-Collector" class="headerlink" title="四、Garbage Collector"></a>四、Garbage Collector</h4><p>​        三种GC算法都有自己的缺点和优点，三种的综合运用，诞生了各种各样的垃圾回收器。</p><p><img src="/2022/10/17/GC/Garbage-Collector.png" alt="Garbage-Collector"></p><h5 id="（1）Serial（单线程STW垃圾回收，处理-lt-100MB）"><a href="#（1）Serial（单线程STW垃圾回收，处理-lt-100MB）" class="headerlink" title="（1）Serial（单线程STW垃圾回收，处理&lt;100MB）"></a>（1）Serial（单线程STW垃圾回收，处理&lt;100MB）</h5><p>​        New：A stop-the-world（STW），copying collector which uses a single GC thread.<br>​        Old：A stop-the-world（STW），mark-sweep-compact collector that uses a single GC thread.</p><p>​        即当Serial工作时，内存中所有的业务线程都停止，等Serial清扫完后继续。</p><h5 id="（2）Parallel（并行多线程PS-PO，处理-lt-1G）"><a href="#（2）Parallel（并行多线程PS-PO，处理-lt-1G）" class="headerlink" title="（2）Parallel（并行多线程PS+PO，处理&lt;1G）"></a>（2）Parallel（并行多线程PS+PO，处理&lt;1G）</h5><p>​        Parallel Scavenge：A stop-the-world（STW），copying collector which uses multiple GC threads.</p><p>​        Parallel Old：A stop-the-world（STW），mark-sweep-compact collector that uses multiple GC threads.</p><p>​        与Serial的区别在于多个GC并行处理。</p><h5 id="（3）Concurrent-GC（处理几十G）"><a href="#（3）Concurrent-GC（处理几十G）" class="headerlink" title="（3）Concurrent GC（处理几十G）"></a>（3）Concurrent GC（处理几十G）</h5><p>​        从线程角度理解Concurrent GC，即GC和业务线程能同时运行。 </p><p>​        ParNew：A stop-the-world（STW），copying collector which uses multiple GC threads.<br>               It differs from “Parallel Scavenge” in that it has enhancements that make it useable with CMS<br>​<br>       CMS：垃圾回收历史的重要节点！</p><h4 id="五、java的垃圾回收机制"><a href="#五、java的垃圾回收机制" class="headerlink" title="五、java的垃圾回收机制"></a>五、java的垃圾回收机制</h4><p>​        如果要将一整块内存用统一的一种算法解决，其实是比较困难的，所以在jdk中，将内存划分为两个“年代”，new（新生代）和old（老年代），综合运用不同的垃圾回收器来管理内存空间。</p><p>​        一个内存块在诞生时会被优先划分到新生代的eden区，在新生代区使用的GC算法是Copying算法，其中一次年轻代的清扫被称为YGC，其中90%的垃圾都会被回收，所以划分两个Copying区域没必要按照1:1的比例，其采用8:1:1的比例，清扫不掉的垃圾会被划分到survivor区。</p><p>​        若某个垃圾很顽固，经历了多次清扫仍然存活，就会被划分到old老年区，因为老年区中的都是顽固垃圾，没必要再去一遍遍清扫，等到内存装不下了再用Mark Compact算法进行回收。</p><p><img src="/2022/10/17/GC/jdk-and-GC.png" alt="jdk-and-GC"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从底层理解堆和栈的概念以及问题</title>
    <link href="http://example.com/2022/10/17/heap-and-stack/"/>
    <id>http://example.com/2022/10/17/heap-and-stack/</id>
    <published>2022-10-17T10:05:37.000Z</published>
    <updated>2022-10-17T10:07:13.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/17/heap-and-stack/img.jpg" alt="img">        </p><h4 id="（1）栈的概念"><a href="#（1）栈的概念" class="headerlink" title="（1）栈的概念"></a>（1）栈的概念</h4><p>​        在java程序中，存储main方法、Object o变量和m()方法的调用的结构，是一个先进后出的栈（每个线程单独占用一个栈），栈中的每块数据（m、main）由一个栈帧（stack frame指向）。</p><p>​        当每个程序块结束运行，会移到下一个栈帧，而栈中上一个程序块以及其里面的数据会被自动释放，如main方法中的Object o，虽然其会占用一定的空间，但当main程序执行完，不需要程序员手动释放。</p><h4 id="（2）堆的概念及其管理问题"><a href="#（2）堆的概念及其管理问题" class="headerlink" title="（2）堆的概念及其管理问题"></a>（2）堆的概念及其管理问题</h4><p>​        存储程序执行过程被手动new出来的对象的结构叫做堆。new出来的对象会占用堆的空间，若一直一直new对象，会产生爆内存的情况。堆与栈的最主要区别是，堆中的数据由程序员自己分配创建，而且得手动回收（将某处空间标记为可用）。</p><p>​        而对堆空间的处理，不同的语言使用不同的方法去管理，在对堆空间的处理过程中往往会伴随着两个最难调试的bug，野指针问题和并发问题。。</p><p>​        c/c++使用的是手工管理内存（malloc free/new delete）。若忘记释放，会产生memory leak内存泄漏问题（空间存在，但无法被使用），泄漏严重会演变为out of memory内存移除问题，可采用最朴素的调优方式–重启来解决；若多次释放，可能会产生并发线程问题，一个线程空间莫名其妙被另一个线程释放。</p><p>​        在java、python和go等高级语言中，引入了GC（Garbage Collector）垃圾回收器，用于管理堆中垃圾的释放问题，程序员只需要负责分配，而那些错综复杂互相依赖的空间将由GC进行释放，所以相对c/c++来说开发效率更高，大大地降低了程序员的门槛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/10/17/heap-and-stack/img.jpg&quot; alt=&quot;img&quot;&gt;        &lt;/p&gt;
&lt;h4 id=&quot;（1）栈的概念&quot;&gt;&lt;a href=&quot;#（1）栈的概念&quot; class=&quot;headerlink&quot; title=&quot;（1）栈的概</summary>
      
    
    
    
    
  </entry>
  
</feed>
