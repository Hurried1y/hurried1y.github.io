<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>常用的垃圾回收算法和垃圾回收器</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hurried1y" type="application/atom+xml">
</head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="../img/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">Hurried1y</a></div><div class="about-me">时间扑面而来，我们终将释怀</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="../img/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/Hurried1y"></span><a href="https://github.com/Hurried1y" target="_blank" title="https://github.com/Hurried1y">https://github.com/Hurried1y</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="3049478157@qq.com"></span><span>3049478157@qq.com</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">常用的垃圾回收算法和垃圾回收器</div><div class="date">写于2022年10月17日</div><div class="content"><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收器，能实现内存垃圾的自动回收，虽然牺牲了一定的运行效率，但大大地提高了开发效率，那么问题来了，常用的GC都有哪些？常用的GC算法都有哪些？GC是如何定义和定位垃圾的呢？</p>
<h4 id="二、What-is-Garbage"><a href="#二、What-is-Garbage" class="headerlink" title="二、What is Garbage"></a>二、What is Garbage</h4><p>​        在谈论垃圾回收算法和垃圾回收器之前，我们得先了解一下垃圾的基本概念。</p>
<h5 id="（1）Garbage的定义"><a href="#（1）Garbage的定义" class="headerlink" title="（1）Garbage的定义"></a>（1）Garbage的定义</h5><p>​        在高级语言中通常将没有引用指向的内存定义为垃圾。</p>
<h5 id="（2）Garbage的定位"><a href="#（2）Garbage的定位" class="headerlink" title="（2）Garbage的定位"></a>（2）Garbage的定位</h5><p>​        在python中，采用的是垃圾定位算法是reference count引用计数法，即记录每块内存被引用指向的数量，当指向某块内存的数量为0时，就把这块内存定义为垃圾，被GC自动释放（这让我想起了拓扑排序0.0），但这种算法有一个弊端，其无法解决“闭环”的情况，即多块内存相互引用形成闭环，与其他内存块无依赖。</p>
<p>​        而在java中，则使用Root Searching根可达算法来定位垃圾，从程序的根（如main方法）开始，若无法抵达某块内存，就把该块内存判作垃圾，由GC进行释放，该算法很好的解决了”内存闭环“问题。</p>
<h4 id="三、GC-Algorithms"><a href="#三、GC-Algorithms" class="headerlink" title="三、GC Algorithms"></a>三、GC Algorithms</h4><h5 id="（1）Mark-Sweep"><a href="#（1）Mark-Sweep" class="headerlink" title="（1）Mark-Sweep"></a>（1）Mark-Sweep</h5><p>​        标记清除法，将某块内存标记为垃圾，然后清除。算法的缺点，会产生碎片空间。</p>
<p><img src="/2022/10/17/GC/Mark-Sweep.png" alt="Mark-Sweep"></p>
<h5 id="（2）Copying"><a href="#（2）Copying" class="headerlink" title="（2）Copying"></a>（2）Copying</h5><p>​        拷贝法，将内存区分两半，每次运行时在一半中找出所有存活对象，然后整体性的复制到另外半边，同时排列好，然后把原来半边整体回收。算法的缺点是浪费内存。</p>
<p><img src="/2022/10/17/GC/Copying.png" alt="Copying"></p>
<h5 id="（3）Mark-Compact"><a href="#（3）Mark-Compact" class="headerlink" title="（3）Mark-Compact"></a>（3）Mark-Compact</h5><p>​        标记压缩法，将标记为垃圾的内存回收，并且排列好。缺点是效率相对较低。</p>
<p><img src="/2022/10/17/GC/Mark-Compact.png" alt="Mark-Compact"></p>
<h4 id="四、Garbage-Collector"><a href="#四、Garbage-Collector" class="headerlink" title="四、Garbage Collector"></a>四、Garbage Collector</h4><p>​        三种GC算法都有自己的缺点和优点，三种的综合运用，诞生了各种各样的垃圾回收器。</p>
<p><img src="/2022/10/17/GC/Garbage-Collector.png" alt="Garbage-Collector"></p>
<h5 id="（1）Serial（单线程STW垃圾回收，处理-lt-100MB）"><a href="#（1）Serial（单线程STW垃圾回收，处理-lt-100MB）" class="headerlink" title="（1）Serial（单线程STW垃圾回收，处理&lt;100MB）"></a>（1）Serial（单线程STW垃圾回收，处理&lt;100MB）</h5><p>​        New：A stop-the-world（STW），copying collector which uses a single GC thread.<br>​        Old：A stop-the-world（STW），mark-sweep-compact collector that uses a single GC thread.</p>
<p>​        即当Serial工作时，内存中所有的业务线程都停止，等Serial清扫完后继续。</p>
<h5 id="（2）Parallel（并行多线程PS-PO，处理-lt-1G）"><a href="#（2）Parallel（并行多线程PS-PO，处理-lt-1G）" class="headerlink" title="（2）Parallel（并行多线程PS+PO，处理&lt;1G）"></a>（2）Parallel（并行多线程PS+PO，处理&lt;1G）</h5><p>​        Parallel Scavenge：A stop-the-world（STW），copying collector which uses multiple GC threads.</p>
<p>​        Parallel Old：A stop-the-world（STW），mark-sweep-compact collector that uses multiple GC threads.</p>
<p>​        与Serial的区别在于多个GC并行处理。</p>
<h5 id="（3）Concurrent-GC（处理几十G）"><a href="#（3）Concurrent-GC（处理几十G）" class="headerlink" title="（3）Concurrent GC（处理几十G）"></a>（3）Concurrent GC（处理几十G）</h5><p>​        从线程角度理解Concurrent GC，即GC和业务线程能同时运行。 </p>
<p>​        ParNew：A stop-the-world（STW），copying collector which uses multiple GC threads.<br>               It differs from “Parallel Scavenge” in that it has enhancements that make it useable with CMS<br>​<br>       CMS：垃圾回收历史的重要节点！</p>
<h4 id="五、java的垃圾回收机制"><a href="#五、java的垃圾回收机制" class="headerlink" title="五、java的垃圾回收机制"></a>五、java的垃圾回收机制</h4><p>​        如果要将一整块内存用统一的一种算法解决，其实是比较困难的，所以在jdk中，将内存划分为两个“年代”，new（新生代）和old（老年代），综合运用不同的垃圾回收器来管理内存空间。</p>
<p>​        一个内存块在诞生时会被优先划分到新生代的eden区，在新生代区使用的GC算法是Copying算法，其中一次年轻代的清扫被称为YGC，其中90%的垃圾都会被回收，所以划分两个Copying区域没必要按照1:1的比例，其采用8:1:1的比例，清扫不掉的垃圾会被划分到survivor区。</p>
<p>​        若某个垃圾很顽固，经历了多次清扫仍然存活，就会被划分到old老年区，因为老年区中的都是顽固垃圾，没必要再去一遍遍清扫，等到内存装不下了再用Mark Compact算法进行回收。</p>
<p><img src="/2022/10/17/GC/jdk-and-GC.png" alt="jdk-and-GC"></p>
</div><div class="tags"></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2022/10/17/Tri-colour-marking/">著名的三色标记法</a></li><li>下一篇：<a href="/2022/10/17/heap-and-stack/">从底层理解堆和栈的概念以及问题</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script>
<script src="/script/post.js"></script>
</body></html>