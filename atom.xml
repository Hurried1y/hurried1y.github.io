<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hurried1y</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-17T13:53:39.591Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hurried1y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>著名的三色标记法</title>
    <link href="http://example.com/2022/10/17/Tri-colour-marking/"/>
    <id>http://example.com/2022/10/17/Tri-colour-marking/</id>
    <published>2022-10-17T12:44:16.000Z</published>
    <updated>2022-10-17T13:53:39.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行（STW）。</p><p>在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。包含“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。</p><h2 id="二、三色标记法"><a href="#二、三色标记法" class="headerlink" title="二、三色标记法"></a>二、三色标记法</h2><p>顾名思义，用三种颜色进行标记，其用在CMS垃圾回收器工作的并发标记阶段。</p><hr><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达(白色对象会被当成垃圾对象)。</li></ul><ul><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用（子对象）都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象(黑色对象不会当成垃圾对象)。</li></ul><ul><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。当垃圾回收线程从暂停中再次回来，不会扫描灰色对象，而是直接扫描灰色对象的引用。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li><p>初始时，全部对象都是白色的</p></li><li><p>GC Roots直接引用的对象变成灰色</p></li><li><p>从灰色集合中获取元素：</p><p>3.1 将本对象直接引用的对象标记为灰色</p><p>3.2 将本对象标记为黑色</p></li><li><p>重复步骤3，直到灰色的对象集合变为空</p></li><li><p>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</p></li></ol><p>当Stop The Word时，对象间的引用是不会发生变化的，因为用户线程中断了，可以轻松完成标记，但是在并发标记的时候，标记期间用户线程还在跑，对象间的引用可能发生变化，多标和漏标的情况就可能会发生</p><p><strong>多标(又叫浮动垃圾)</strong></p><p>假设此时我们遍历到了D对象，此时D被标记成了灰色</p><p><img src="/2022/10/17/Tri-colour-marking/mg1.png" alt="img1"></p><p> 此时线程发生B取消了对D的引用</p><p><img src="/2022/10/17/Tri-colour-marking/Users\A\AppData\Roaming\Typora\typora-user-images\image-20221017213218546.png" alt="image-20221017213218546"></p><p>这时候B-&gt;D的引用没了，D应该是白色，但是因为先前D已经被标记成灰色了，所以D对象仍然会被当成存活对象遍历下去。最终结果：这部分对象仍然会被标记为存活对象，本轮GC不会回收他们的内存。这部分因为并发而造成的本应该回收但是没有回收的对象被称为”浮动垃圾”，我们稍微一想也能想到，<strong>浮动垃圾不会影响应用程序的正确性，只需要等到下一轮GC到来就会被回收了</strong>。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p><strong>漏标(读写屏障)</strong></p><p>假设GC线程已经遍历到D对象，此时D被标记为灰色 </p><p><img src="/2022/10/17/Tri-colour-marking/img2.png" alt="img2"></p><p>但是此时有代码执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/17/Tri-colour-marking/img3.png" alt="img3"></p><p>此时D到E的引用消失，B生成了对E的引用。当GC线程继续时，因为D已经没有了对E的引用，所以不会遍历到E，E也就不会标志为灰色，同时B已经标志为黑色了，不会再被遍历，那么也就导致E一直是白色的，最后被当成垃圾处理，这显然与事实不符，E是可打的，但是因为并发的影响漏标了E，使得E被垃圾回收，明显影响了应用程序的正确性，这是不可接受的。</p><p>分析一下，漏标只有同时满足以下两个条件时才会发生：</p><ol><li><p>灰色对象断开了白色对象的引用</p></li><li><p>黑色对象重新引用了该白色对象</p></li></ol><p>从代码角度看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p>只要在上面三步中修改任意一步就可以将丢失的E记录下来，然后当作灰色对象继续遍历</p><p>根据以上思路有两种解决办法：</p><h5 id="一、写屏障-阻止第二步和第三步"><a href="#一、写屏障-阻止第二步和第三步" class="headerlink" title="一、写屏障(阻止第二步和第三步)"></a>一、写屏障(阻止第二步和第三步)</h5><p>1.写屏障 + SATB</p><p>当对象D的引用发生变化时，利用写屏障，将D原来的引用对象记录下来，这样可以尝试保留开始时的对象图，保证标记依然按照原本的路线走</p><p>2.写屏障 + 增量更新</p><p>当对象B的引用发生变化时，利用写屏障，将B新的引用对象E记录下来</p><p>即当有新的引用插入进来时，记录下新的引用</p><p>这种思路不要求保留原始对象图，而是针对新的引用记录下来等待遍历即增量更新</p><h5 id="二、读屏障-阻止第一步"><a href="#二、读屏障-阻止第一步" class="headerlink" title="二、读屏障(阻止第一步)"></a>二、读屏障(阻止第一步)</h5><p>读屏障针对第一步，当读取引用对象的时候，一律记录下来，显然这种方法非常保守，但是安全。</p><p>将记录下的引用遍历就是了</p><p>在现代的垃圾回收器当中可达性分析算法的垃圾回收器几乎都借鉴了三色标记法的思想。</p><p>在Java HotSpot VM中</p><p>CMS采用的是：写屏障 + 增量更新</p><p>G1采用的是：写屏障 + SATB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用的垃圾回收算法和垃圾回收器</title>
    <link href="http://example.com/2022/10/17/GC/"/>
    <id>http://example.com/2022/10/17/GC/</id>
    <published>2022-10-17T10:07:37.000Z</published>
    <updated>2022-10-17T13:03:27.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收器，能实现内存垃圾的自动回收，虽然牺牲了一定的运行效率，但大大地提高了开发效率，那么问题来了，常用的GC都有哪些？常用的GC算法都有哪些？GC是如何定义和定位垃圾的呢？</p><h4 id="二、What-is-Garbage"><a href="#二、What-is-Garbage" class="headerlink" title="二、What is Garbage"></a>二、What is Garbage</h4><p>​        在谈论垃圾回收算法和垃圾回收器之前，我们得先了解一下垃圾的基本概念。</p><h5 id="（1）Garbage的定义"><a href="#（1）Garbage的定义" class="headerlink" title="（1）Garbage的定义"></a>（1）Garbage的定义</h5><p>​        在高级语言中通常将没有引用指向的内存定义为垃圾。</p><h5 id="（2）Garbage的定位"><a href="#（2）Garbage的定位" class="headerlink" title="（2）Garbage的定位"></a>（2）Garbage的定位</h5><p>​        在python中，采用的是垃圾定位算法是reference count引用计数法，即记录每块内存被引用指向的数量，当指向某块内存的数量为0时，就把这块内存定义为垃圾，被GC自动释放（这让我想起了拓扑排序0.0），但这种算法有一个弊端，其无法解决“闭环”的情况，即多块内存相互引用形成闭环，与其他内存块无依赖。</p><p>​        而在java中，则使用Root Searching根可达算法来定位垃圾，从程序的根（如main方法）开始，若无法抵达某块内存，就把该块内存判作垃圾，由GC进行释放，该算法很好的解决了”内存闭环“问题。</p><h4 id="三、GC-Algorithms"><a href="#三、GC-Algorithms" class="headerlink" title="三、GC Algorithms"></a>三、GC Algorithms</h4><h5 id="（1）Mark-Sweep"><a href="#（1）Mark-Sweep" class="headerlink" title="（1）Mark-Sweep"></a>（1）Mark-Sweep</h5><p>​        标记清除法，将某块内存标记为垃圾，然后清除。算法的缺点，会产生碎片空间。</p><p><img src="/2022/10/17/GC/Mark-Sweep.png" alt="Mark-Sweep"></p><h5 id="（2）Copying"><a href="#（2）Copying" class="headerlink" title="（2）Copying"></a>（2）Copying</h5><p>​        拷贝法，将内存区分两半，每次运行时在一半中找出所有存活对象，然后整体性的复制到另外半边，同时排列好，然后把原来半边整体回收。算法的缺点是浪费内存。</p><p><img src="/2022/10/17/GC/Copying.png" alt="Copying"></p><h5 id="（3）Mark-Compact"><a href="#（3）Mark-Compact" class="headerlink" title="（3）Mark-Compact"></a>（3）Mark-Compact</h5><p>​        标记压缩法，将标记为垃圾的内存回收，并且排列好。缺点是效率相对较低。</p><p><img src="/2022/10/17/GC/Mark-Compact.png" alt="Mark-Compact"></p><h4 id="四、Garbage-Collector"><a href="#四、Garbage-Collector" class="headerlink" title="四、Garbage Collector"></a>四、Garbage Collector</h4><p>​        三种GC算法都有自己的缺点和优点，三种的综合运用，诞生了各种各样的垃圾回收器。</p><p><img src="/2022/10/17/GC/Garbage-Collector.png" alt="Garbage-Collector"></p><h5 id="（1）Serial（单线程STW垃圾回收，处理-lt-100MB）"><a href="#（1）Serial（单线程STW垃圾回收，处理-lt-100MB）" class="headerlink" title="（1）Serial（单线程STW垃圾回收，处理&lt;100MB）"></a>（1）Serial（单线程STW垃圾回收，处理&lt;100MB）</h5><p>​        New：A stop-the-world（STW），copying collector which uses a single GC thread.<br>​        Old：A stop-the-world（STW），mark-sweep-compact collector that uses a single GC thread.</p><p>​        即当Serial工作时，内存中所有的业务线程都停止，等Serial清扫完后继续。</p><h5 id="（2）Parallel（并行多线程PS-PO，处理-lt-1G）"><a href="#（2）Parallel（并行多线程PS-PO，处理-lt-1G）" class="headerlink" title="（2）Parallel（并行多线程PS+PO，处理&lt;1G）"></a>（2）Parallel（并行多线程PS+PO，处理&lt;1G）</h5><p>​        Parallel Scavenge：A stop-the-world（STW），copying collector which uses multiple GC threads.</p><p>​        Parallel Old：A stop-the-world（STW），mark-sweep-compact collector that uses multiple GC threads.</p><p>​        与Serial的区别在于多个GC并行处理。</p><h5 id="（3）Concurrent-GC（处理几十G）"><a href="#（3）Concurrent-GC（处理几十G）" class="headerlink" title="（3）Concurrent GC（处理几十G）"></a>（3）Concurrent GC（处理几十G）</h5><p>​        从线程角度理解Concurrent GC，即GC和业务线程能同时运行。 </p><p>​        ParNew：A stop-the-world（STW），copying collector which uses multiple GC threads.<br>               It differs from “Parallel Scavenge” in that it has enhancements that make it useable with CMS<br>​<br>       CMS：垃圾回收历史的重要节点！</p><h4 id="五、java的垃圾回收机制"><a href="#五、java的垃圾回收机制" class="headerlink" title="五、java的垃圾回收机制"></a>五、java的垃圾回收机制</h4><p>​        如果要将一整块内存用统一的一种算法解决，其实是比较困难的，所以在jdk中，将内存划分为两个“年代”，new（新生代）和old（老年代），综合运用不同的垃圾回收器来管理内存空间。</p><p>​        一个内存块在诞生时会被优先划分到新生代的eden区，在新生代区使用的GC算法是Copying算法，其中一次年轻代的清扫被称为YGC，其中90%的垃圾都会被回收，所以划分两个Copying区域没必要按照1:1的比例，其采用8:1:1的比例，清扫不掉的垃圾会被划分到survivor区。</p><p>​        若某个垃圾很顽固，经历了多次清扫仍然存活，就会被划分到old老年区，因为老年区中的都是顽固垃圾，没必要再去一遍遍清扫，等到内存装不下了再用Mark Compact算法进行回收。</p><p><img src="/2022/10/17/GC/jdk-and-GC.png" alt="jdk-and-GC"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从底层理解堆和栈的概念以及问题</title>
    <link href="http://example.com/2022/10/17/heap-and-stack/"/>
    <id>http://example.com/2022/10/17/heap-and-stack/</id>
    <published>2022-10-17T10:05:37.000Z</published>
    <updated>2022-10-17T10:07:13.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/17/heap-and-stack/img.jpg" alt="img">        </p><h4 id="（1）栈的概念"><a href="#（1）栈的概念" class="headerlink" title="（1）栈的概念"></a>（1）栈的概念</h4><p>​        在java程序中，存储main方法、Object o变量和m()方法的调用的结构，是一个先进后出的栈（每个线程单独占用一个栈），栈中的每块数据（m、main）由一个栈帧（stack frame指向）。</p><p>​        当每个程序块结束运行，会移到下一个栈帧，而栈中上一个程序块以及其里面的数据会被自动释放，如main方法中的Object o，虽然其会占用一定的空间，但当main程序执行完，不需要程序员手动释放。</p><h4 id="（2）堆的概念及其管理问题"><a href="#（2）堆的概念及其管理问题" class="headerlink" title="（2）堆的概念及其管理问题"></a>（2）堆的概念及其管理问题</h4><p>​        存储程序执行过程被手动new出来的对象的结构叫做堆。new出来的对象会占用堆的空间，若一直一直new对象，会产生爆内存的情况。堆与栈的最主要区别是，堆中的数据由程序员自己分配创建，而且得手动回收（将某处空间标记为可用）。</p><p>​        而对堆空间的处理，不同的语言使用不同的方法去管理，在对堆空间的处理过程中往往会伴随着两个最难调试的bug，野指针问题和并发问题。。</p><p>​        c/c++使用的是手工管理内存（malloc free/new delete）。若忘记释放，会产生memory leak内存泄漏问题（空间存在，但无法被使用），泄漏严重会演变为out of memory内存移除问题，可采用最朴素的调优方式–重启来解决；若多次释放，可能会产生并发线程问题，一个线程空间莫名其妙被另一个线程释放。</p><p>​        在java、python和go等高级语言中，引入了GC（Garbage Collector）垃圾回收器，用于管理堆中垃圾的释放问题，程序员只需要负责分配，而那些错综复杂互相依赖的空间将由GC进行释放，所以相对c/c++来说开发效率更高，大大地降低了程序员的门槛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/10/17/heap-and-stack/img.jpg&quot; alt=&quot;img&quot;&gt;        &lt;/p&gt;
&lt;h4 id=&quot;（1）栈的概念&quot;&gt;&lt;a href=&quot;#（1）栈的概念&quot; class=&quot;headerlink&quot; title=&quot;（1）栈的概</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/15/hello-world/"/>
    <id>http://example.com/2022/10/15/hello-world/</id>
    <published>2022-10-15T13:04:24.908Z</published>
    <updated>2022-10-15T12:37:26.942Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
