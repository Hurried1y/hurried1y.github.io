<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hurried1y</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-26T11:24:04.214Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hurried1y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos Server Register and Discovery</title>
    <link href="http://example.com/2023/12/26/nacos-discovery/"/>
    <id>http://example.com/2023/12/26/nacos-discovery/</id>
    <published>2023-12-26T11:00:22.000Z</published>
    <updated>2023-12-26T11:24:04.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Server-Register-and-Discovery"><a href="#Nacos-Server-Register-and-Discovery" class="headerlink" title="Nacos  Server Register and Discovery"></a>Nacos  Server Register and Discovery</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前尝试去简单梳理了一下RocketMQ的两个模块的初始执行流程，感觉还是没有做到与客户端结合，很多点停留在表面，并没有深入地去思考其为什么要这么写，后续还要继续完善。因为之前的一个个人项目中用到了Zookeeper作为注册中心，就想深入地去看一下同为注册中心的Nacos，这篇文章参考了Nacos的官方文档，从其数据模型到实现逻辑一一展开。</p><h2 id="Nacos-注册中心的设计原理"><a href="#Nacos-注册中心的设计原理" class="headerlink" title="Nacos 注册中心的设计原理"></a>Nacos 注册中心的设计原理</h2><h3 id="一、数据模型"><a href="#一、数据模型" class="headerlink" title="一、数据模型"></a>一、数据模型</h3><p>在讲服务注册与发现的源码之前，我们先要对 Nacos 中的数据模型有一个简单了印象。注册中心的核心数据是服务的名字和它对应的网络地址，其还包括了实例的健康状态、权限、权重等等信息。Nacos 采用的是一种服务-集群-实例的分级模型，这样基本可以满足服务在所有场景下的数据存储和管理。</p><p><img src="/2023/12/26/nacos-discovery/i1.png" alt="image-20231221103337563"></p><p>除此之外，Nacos 提供了四层的数据逻辑隔离模型，用户账号对应的可能是⼀个企业或者独立的个体，这个数据⼀般情况下不会透传到服务注册中心。⼀个用户账号可以新建多个命名空间，每个命名空间对应 ⼀个客户端实例，这个命名空间对应的注册中心物理集群是可以根据规则进行路由的，这样可以让注册中心内部的升级和迁移对用户是无感知的，同时可以根据用户的级别，为用户提供不同服务级别的物理集群。再往下是服务分组和服务名组成的二维服务标识，可以满足接口级别的服务隔离。</p><p><img src="/2023/12/26/nacos-discovery/i2.png" alt="image-20231221104722338"></p><p>Nacos 的数据模型很复杂，为了适配各种场景，其中存在非常多的属性，但在大多数场景下，我们可以忽略一些数据属性，只关注于我们场景需要的，如当我们不配置 Group 时，Nacos 会为我们分配一个默认 group。</p><h3 id="二、Nacos-服务注册与发现源码解读"><a href="#二、Nacos-服务注册与发现源码解读" class="headerlink" title="二、Nacos 服务注册与发现源码解读"></a>二、Nacos 服务注册与发现源码解读</h3><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>既然是服务注册，那我们肯定要从客户端开始看起。这里用到了 SpringBoot 的自动装配，就不在多赘述了，每一个 Nacos 客户端都会引入这些启动类，顾名思义，NacosDiscoveryAutoConfiguration 应该就是总的入口了，我们继续看。</p><p><img src="/2023/12/26/nacos-discovery/i3.png" alt="image-20231221105823461"></p><p>我们跟进来，就可以看到 NacosServiceRegistry，很明显这个应该就是服务注册的入口了。</p><p><img src="/2023/12/26/nacos-discovery/i4.png" alt="image-20231221105823461"></p><p>我们跟进入就会看到服务注册的核心方法，这里我们可以看到，Instance 其实就是服务的单个实例，其中包含了很多数据，此时我们就可从中初见 Nacos 的服务分级模型，Service - Cluster - Instance，这里有些数据我们在配置的时候故意忽略了，但其都有一个默认初始值，也就是之前说的，只需要关注我们场景中需要的属性即可。</p><p><img src="/2023/12/26/nacos-discovery/i5.png" alt="image-20231221110812123"></p><p>我们继续跟进去，在这里可以看到 addBeatInfo() 方法，顾名思义，这个应该就是客户端心跳机制的实现了，但这里我们先不看，专注于服务注册，后续再展开。</p><p><img src="/2023/12/26/nacos-discovery/i6.png" alt="image-20231221111452795"></p><p>这里就是客户端的服务注册核心逻辑，将 Instance 转为 Map，然后通过 HTTP 请求发送给 Nacos 服务端。</p><p><img src="/2023/12/26/nacos-discovery/i7.png" alt="image-20231221111622398"></p><p>这个接口我们在 Nacos 官方文档中也可以看到。</p><p><img src="/2023/12/26/nacos-discovery/i8.png" alt="image-20231221111854984"></p><p>此时 Nacos 客户端的服务注册的任务就完成了，我们接着看服务端是怎样处理的。我提前把 Nacos 2.3 的源码给拉下来了，进去之后你就会发现，Nacos 本质也是一个 Web 项目，其中 console 就是 Nacos 的核心启动入口。naming 就是服务注册与发现的核心模块，在里面我们就可以找到服务注册的 POST 接口。</p><p><img src="/2023/12/26/nacos-discovery/i9.png" alt="image-20231221112148896"></p><p>这里应该很熟悉了，SpringBoot 项目的Controller。我们抓着主线看，在这里首先把客户端传的 Map 转换为 Instance，然后通过getInstanceOperator().registerInstance() 注册服务。</p><p><img src="/2023/12/26/nacos-discovery/i10.png" alt="image-20231221112718283"></p><p>值得一提的是，在 Nacos2.0 后将是否持久化的数据抽象至服务级别，且不再允许⼀个服务同时存在持久化实例和非持久化实例，实例的持久化属性继承自服务的持久化属性。这是官方的说法，意味着一个服务下面的实例只能是临时的 or 持久的，一般默认是 ephemeral，即临时实例。这里我们演示的是临时实例的注册逻辑，就看 EphemeralClientOperationServiceImpl 中 registerInstance 的具体实现。</p><p><img src="/2023/12/26/nacos-discovery/i11.png" alt="image-20231221113307273"></p><p>在这里可以看到有两个对象，Client和Service。Service就是注册的服务，一般会维护命名空间、组名、服务名、临时客户端标识等信息，服务下面就是实例集合。Nacos在2.0 版本之后新增了Client模型，每个Client都有自身唯一的ClientId，一个gRPC长连接对应一个Client。Client负责管理一个客户端的服务实例注册Publish和服务订阅Subscribe。</p><p><img src="/2023/12/26/nacos-discovery/i14.png" alt="image-20231226095730590"></p><h5 id="Client的创建及gRPC连接"><a href="#Client的创建及gRPC连接" class="headerlink" title="Client的创建及gRPC连接"></a>Client的创建及gRPC连接</h5><p>这就是Client接口的具体方法，我们根据方法名大概就能猜出其作用，主要是维护客户端的一些信息。</p><p><img src="/2023/12/26/nacos-discovery/i15.png" alt="image-20231226101254894"></p><p>我们进到 createIpPortClientIfAbsent 方法里，就可以看到其主要逻辑，这里用到了 ClientManager，这是用来管理 Client的创建、获取、释放的接口，可以看到 ClientManager 也对实例类型做了不同的实现类。</p><p><img src="/2023/12/26/nacos-discovery/i16.png" alt="image-20231226102134724"></p><p><img src="/2023/12/26/nacos-discovery/i17.png" alt="image-20231226102412507"></p><p><img src="/2023/12/26/nacos-discovery/i18.png" alt="image-20231226102606320"></p><p>我们这里就看看临时实例是怎么实现的，这里还有个 ClientFactory<IpPortBasedClient> clientFactory，这个是创建 Client 的工厂，底层实现也会区分临时、持久实例等，就不再展开。clientConnected 方法接收 clientFactory 创建的 Client 对象后，就会初始化 Client 的心跳检查定时任务，再把其放在名为 clients 的Map中。</IpPortBasedClient></p><p><img src="/2023/12/26/nacos-discovery/i19.png" alt="image-20231226103036339"></p><p><img src="/2023/12/26/nacos-discovery/i20.png" alt="image-20231226103852620"></p><p><img src="/2023/12/26/nacos-discovery/i21.png" alt="image-20231226104146758"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, IpPortBasedClient&gt; clients = new ConcurrentHashMap&lt;&gt;()</span><br></pre></td></tr></table></figure><h5 id="Service的创建与注册"><a href="#Service的创建与注册" class="headerlink" title="Service的创建与注册"></a>Service的创建与注册</h5><p>Service的创建其实没什么好说的，就是根据客户端的参数去 new 一个 Service 对象。</p><p><img src="/2023/12/26/nacos-discovery/i22.png" alt="image-20231226105214671"></p><p>后续的操作是通过 clientOperationService.registerInstance 进行，ClientOperationService 接口也基于不同的服务进行了区分，我们直接看 EphemeralClientOperationServiceImpl 中对 registerInstance 的具体实现。</p><p><img src="/2023/12/26/nacos-discovery/i12.png" alt="image-20231221113904857"></p><p>这里是先通过 ServiceManager 获取了一个单例的 Service 对象，维护了两个 Map，当我们需要的 Service 在Map中不存在时，就发布 ServiceMetadataEvent 事件，最终将其放到对应的Map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储Service的单例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Service, Service&gt; singletonRepository;</span><br><span class="line"><span class="comment">//存储某个namespace下的所有的Service</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Service&gt;&gt; namespaceSingletonMaps;</span><br></pre></td></tr></table></figure><p><img src="/2023/12/26/nacos-discovery/i23.png" alt="image-20231226110152253"></p><p>之后就通过 clientId 从 ClientManager 中获取对应的 Client，这一步其实是从 ClientManager 中的Map clients 中获取的，而且获取到的是 Client 的实现类 AbstractClient。AbstractClient 负责存储当前客户端的服务注册表，即Service与Instance的映射关系。对于单个客户端来说，同一个服务只能注册一个实例。</p><p>下面就是真正注册实例的逻辑，先把服务与实例的映射关系保存在 publishers 中，然后通过 NotifyCenter 发布一个 ClientChangedEvent 服务注册事件。</p><p><img src="/2023/12/26/nacos-discovery/i13.png" alt="image-20231226111454940"></p><h5 id="服务注册事件的处理"><a href="#服务注册事件的处理" class="headerlink" title="服务注册事件的处理"></a>服务注册事件的处理</h5><p>我们进到 NotifyCenter 的 publishEvent 方法中，可以看到其最终是通过 EventPublisher 将事件发布出去。EventPublisher 是事件发布的上层接口，上面定义了基本的方法，比如发布事件，通知订阅者处理事件等。服务注册实际上最终走的是 NamingEventPublisher 中的逻辑。</p><p><img src="/2023/12/26/nacos-discovery/i24.png" alt="image-20231226112403694"></p><p><img src="/2023/12/26/nacos-discovery/i25.png" alt="image-20231226112606316"></p><p>我们进到 NamingEventPublisher 中，就可以看到其主要逻辑，发布事件实际上是把事件存入 BlockingQueue 中，使用 BlockingQueue 有一个好处就是，对数据进行存取的时候，如果有数据就返回，没有数据就会让出 CPU 的控制权，而不会一直阻塞住线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Event&gt; queue</span><br></pre></td></tr></table></figure><p><img src="/2023/12/26/nacos-discovery/i26.png" alt="image-20231226112730163"></p><p>我们回到 NamingEventPublisher 本身来看，可以看到其继承了 Thread 类，这样我们直接去看其 run 方法。</p><p><img src="/2023/12/26/nacos-discovery/i27.png" alt="image-20231226113614645"></p><p>在 run 方法中，我们就可以看到，先是要等待所有事件订阅者初始化完成，内部是碰到没有初始化的直接调用 ThreadUtils.<strong>sleep</strong>(1000L) 方法阻塞线程。当所有订阅者都初始化完成后，就调用 handleEvents 去处理事件。</p><p><img src="/2023/12/26/nacos-discovery/i28.png" alt="image-20231226113723773"></p><p>可以看到，handleEvents 方法中会轮训事件队列，当获取到一个 event 后，就进行处理事件。</p><p><img src="/2023/12/26/nacos-discovery/i29.png" alt="image-20231226114004807"></p><p>拿到事件的类型，之后获取订阅了该类型的所有订阅者，通知每一个订阅者去处理该事件。</p><p><img src="/2023/12/26/nacos-discovery/i30.png" alt="image-20231226114214774"></p><p>通过线程池或者直接 new 一个线程去执行订阅者的处理事件。</p><p><img src="/2023/12/26/nacos-discovery/i31.png" alt="image-20231226114531560"></p><p>服务注册事件最终是通过 ClientServiceIndexesManager 去处理的，我们进到里面可以看到其订阅的事件。</p><p><img src="/2023/12/26/nacos-discovery/i32.png" alt="image-20231226115125039"></p><p>我们看看 ClientServiceIndexesManager 是怎么处理服务注册事件的，handleClientDisconnect 方法是处理服务下线事件的，handleClientOperation 就是具体的客户端操作了。</p><p><img src="/2023/12/26/nacos-discovery/i33.png" alt="image-20231226115253929"></p><p>可以看到大概是将客户端与服务的映射关系存入一个Map中，这里的 publisherIndexes 就是注册表，然后发布了一个 ServiceChangedEvent 注册表变更事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * publisherIndexes:</span></span><br><span class="line"><span class="comment"> *  维护Service与发布clientId列表的映射关系，</span></span><br><span class="line"><span class="comment"> *  当有新的clientId注册，将clientId添加到clientId列表中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; publisherIndexes = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * subscriberIndexes:</span></span><br><span class="line"><span class="comment"> *  维护Service与订阅clientId列表的映射关系，</span></span><br><span class="line"><span class="comment"> *  当有clientId断开连接或取消订阅，将clientId从clientId列表中移除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; subscriberIndexes = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="/2023/12/26/nacos-discovery/i34.png" alt="image-20231226115402661"></p><p><img src="/2023/12/26/nacos-discovery/i35.png" alt="image-20231226115528003"></p><p>服务注册表变更事件最终是由 NamingSubscriberServiceV2Impl 进行处理的，之后就是进行通知订阅的客户端，这里是新建一个 PushDelayTask 延时任务，将当前服务的变更全量信息推送给所有订阅了该事件的客户端去更新服务信息。</p><p><img src="/2023/12/26/nacos-discovery/i36.png" alt="image-20231226123230501"></p><p><img src="/2023/12/26/nacos-discovery/i37.png" alt="image-20231226123302736"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos-Server-Register-and-Discovery&quot;&gt;&lt;a href=&quot;#Nacos-Server-Register-and-Discovery&quot; class=&quot;headerlink&quot; title=&quot;Nacos  Server Register</summary>
      
    
    
    
    <category term="注册中心" scheme="http://example.com/categories/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Nacos" scheme="http://example.com/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ梳理 - broker</title>
    <link href="http://example.com/2023/12/06/rocketmq-broker/"/>
    <id>http://example.com/2023/12/06/rocketmq-broker/</id>
    <published>2023-12-06T11:00:12.000Z</published>
    <updated>2023-12-06T11:54:33.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ梳理-broker"><a href="#RocketMQ梳理-broker" class="headerlink" title="RocketMQ梳理 - broker"></a>RocketMQ梳理 - broker</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>上一篇文章简单的过了一遍namesrv的流程，其中很多的细节都没有进行展开，整篇文章抓不住重点，权当流程速览了。在这篇文章中将会尝试对rocketmq的流程进行简单的分析。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="1、启动流程分析"><a href="#1、启动流程分析" class="headerlink" title="1、启动流程分析"></a>1、启动流程分析</h4><p>下图就是broker的启动类，在namesrv中，有着一个<code>NamesrvController</code>，负责<strong>管理Name Server节点的状态</strong>、<strong>消息的路由注册</strong>与<strong>查询</strong>等功能，在broker中也有类似的BrokerController，负责管理broker的核心逻辑和状态。在<code>brokerController</code>中，包含了对消息存储、消息发送和接收、消息队列管理等方面的处理逻辑。</p><p><img src="/2023/12/06/rocketmq-broker/i1.png" alt="image-20231201102505627"></p><p>broker的启动流程跟namesrv差不多，可以大致分为 <strong>initialize</strong>、<strong>start</strong>，我们先来看initialize初始化。</p><h5 id="1）BrokerController-initialize"><a href="#1）BrokerController-initialize" class="headerlink" title="1）BrokerController initialize"></a>1）BrokerController initialize</h5><p>initialize可以分为两部分，初始化broker的元数据和broker中的消息存储的一些配置(比如commitLog、storePath等)。</p><p><img src="/2023/12/06/rocketmq-broker/i20.png" alt="image-20231201103338259"></p><p>可以看到，第一步初始化元数据，就是从文件中加载配置信息，此处还分了<code>topicConfigManager</code>、<code>topicQueueMappingManager</code>、<code>consumerOffsetManager</code>等，主要做了职责细分，比如topicConfigManager.load()，topicConfigManager 会从磁盘上的存储文件（通常是<code>$&#123;ROCKETMQ_HOME&#125;/store/config/topics.json</code>）中读取Topic的配置信息。这些配置信息包括Topic的名称、队列数、读写权限等。一旦加载完成，<code>TopicConfigManager</code>会将这些配置信息存储在内存中，以便快速访问和查询。</p><p><img src="/2023/12/06/rocketmq-broker/i3.png" alt="image-20231201104132856"></p><p><img src="/2023/12/06/rocketmq-broker/i4.png" alt="image-20231201104330642"></p><p>接下来我们看initializeMessageStore，<code>DefaultMessageStore</code>是Broker的核心组件之一，负责管理消息的存储和读取。<code>initializeMessageStore()</code>方法用于初始化消息存储相关的组件和数据结构，确保消息存储的正常运行。</p><p>其内部主要进行这几个工作，<strong>初始化消息钩子</strong>、<strong>加载存储插件</strong>等，主要就是初始化<code>messageStore</code>这个服务。</p><p><img src="/2023/12/06/rocketmq-broker/i5.png" alt="image-20231201104942256"></p><p>这些组件都创建完后就进入到<strong>存储组件配置的加载</strong>、<strong>消息加载</strong>等步骤。</p><p><img src="/2023/12/06/rocketmq-broker/i23.png" alt="image-20231205172720014"></p><p><img src="/2023/12/06/rocketmq-broker/i24.png" alt="image-20231205172741212"></p><h5 id="2）brokerController-start"><a href="#2）brokerController-start" class="headerlink" title="2）brokerController start"></a>2）brokerController start</h5><p>当调用 <code>brokerController.start()</code>时，会执行一系列的初始化操作和启动流程，包括但不限于：</p><ol><li><strong>加载配置文件</strong>：读取Broker的配置文件，包括Broker的角色、监听端口、存储路径等配置信息。</li><li><strong>初始化存储服务</strong>：根据配置信息初始化消息存储服务，包括创建存储目录、加载存储索引等操作。</li><li><strong>注册Broker</strong>：将当前Broker注册到NameServer，以便Client端可以发现和连接到该Broker。</li><li><strong>启动网络服务</strong>：启动监听端口，接收来自Producer和Consumer的请求。</li><li><strong>启动定时任务</strong>：启动定时任务服务，包括消息延时投递、定时消息等功能。</li><li><strong>启动消息消费服务</strong>：启动消息消费线程池，负责处理消息的消费和投递。</li><li><strong>启动消息拉取服务</strong>：启动消息拉取线程池，负责从存储中拉取消息给Consumer消费。</li></ol><p><img src="/2023/12/06/rocketmq-broker/i6.png" alt="image-20231201110942999"></p><p>此处就先启动一系列的基础服务，如<strong>消息存储</strong>，<strong>定时存储</strong>、<strong>文件监听</strong>、<strong>心跳处理</strong>、<strong>路由管理</strong>等等。</p><p><img src="/2023/12/06/rocketmq-broker/i7.png" alt="image-20231201111635266"></p><p>之后启动一系列定时任务，如<strong>心跳维护</strong>、<strong>元数据刷新</strong>等。</p><p><img src="/2023/12/06/rocketmq-broker/i8.png" alt="image-20231201111954763"></p><p><img src="/2023/12/06/rocketmq-broker/i9.png" alt="image-20231201112011736"></p><p><img src="/2023/12/06/rocketmq-broker/i10.png" alt="image-20231201112020639"></p><h4 id="2、消息存储设计"><a href="#2、消息存储设计" class="headerlink" title="2、消息存储设计"></a>2、消息存储设计</h4><p>RocketMQ是一个高性能的消息中间件，其在消息写入时追求极致的效率，采用的策略是顺序写入，所有的消息都写入到<code>commitLog</code>文件中，再在文件内部去维护消息的详细信息，如topic、msgBody等等，这就区别于<code>Kafka</code>，kafka在topic之下还存在<code>分区(Partition)</code>，消息的写入会随着partition的增多而变得分散，这里便不再对其详细展开。除了<code>CommitLog</code>，rocketmq的消息存储系统还包括了<code>ConsumeQueue</code>、<code>IndexFile</code>和<code>Config</code>，下面我们逐一展开。</p><p><img src="/2023/12/06/rocketmq-broker/i17.png" alt="image-20231205170543849"></p><h5 id="1）CommitLog"><a href="#1）CommitLog" class="headerlink" title="1）CommitLog"></a>1）CommitLog</h5><p><code>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容</code>。消息存放的物理文件，每台broker上的commitLog被本机所有的queue共享，不做任何区分。</p><p><img src="/2023/12/06/rocketmq-broker/i11.png" alt="image-20231205163633045"></p><p><img src="/2023/12/06/rocketmq-broker/i30.png" alt="image-20231206104637478"></p><h5 id="2）ConsumeQueue"><a href="#2）ConsumeQueue" class="headerlink" title="2）ConsumeQueue"></a>2）ConsumeQueue</h5><p><code>consumeQueue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commitLog上的位置。</code>其中包含了这个MessageQueue在CommitLog中的起始物理位置偏移量offset，消息实体内容的大小和Message Tag的哈希值。从实际物理存储来说，<code>ConsumeQueue对应每个Topic和QueuId下面的文件</code>。单个文件大小约5.72M，每个文件由30W条数据组成，每个文件默认大小为600万个字节，当一个ConsumeQueue类型的文件写满了，则写入下一个文件。</p><p><img src="/2023/12/06/rocketmq-broker/i12.png" alt="image-20231205164252133"></p><p><img src="/2023/12/06/rocketmq-broker/i13.png" alt="image-20231205164315021"></p><p><img src="/2023/12/06/rocketmq-broker/i14.png" alt="image-20231205164358006"></p><p><img src="/2023/12/06/rocketmq-broker/i29.png" alt="image-20231206104451012"></p><h5 id="3）IndexFile"><a href="#3）IndexFile" class="headerlink" title="3）IndexFile"></a>3）IndexFile</h5><p><code>IndexFile：</code>用于为生成的索引文件提供访问服务，<code>通过消息Key值查询消息真正的实体内容</code>。在实际的物理存储上，文件名则是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引。</p><p><img src="/2023/12/06/rocketmq-broker/i15.png" alt="image-20231205165922541"></p><p><img src="/2023/12/06/rocketmq-broker/i28.png" alt="image-20231206104307435"></p><h5 id="4）Config"><a href="#4）Config" class="headerlink" title="4）Config"></a>4）Config</h5><p>config 文件夹中 存储着Topic和Consumer等相关信息。主题和消费者群组相关的信息就存在在此。</p><ol><li><code>topics.json</code> ： topic 配置属性。</li><li><code>subscriptionGroup.json</code> ：消息消费组配置信息。</li><li><code>delayOffset.json </code>：延时消息队列拉取进度。</li><li><code>consumerOffset.json </code>：集群消费模式消息消进度。</li><li><code>consumerFilter.json</code> ：主题消息过滤信息。</li></ol><p><img src="/2023/12/06/rocketmq-broker/i16.png" alt="image-20231205170306191"></p><h5 id="5）消息存储设计小结"><a href="#5）消息存储设计小结" class="headerlink" title="5）消息存储设计小结"></a>5）消息存储设计小结</h5><p>这些数据前面我们也隐晦的谈到过，比如config里面文件的加载就是发生在broker初始化的时候。</p><p><img src="/2023/12/06/rocketmq-broker/i20.png" alt="image-20231205171933084"></p><p><img src="/2023/12/06/rocketmq-broker/i18.png" alt="image-20231205170858242"></p><p><img src="/2023/12/06/rocketmq-broker/i19.png" alt="image-20231205170941739"></p><p>而对commitLog和ConsumeQueue的加载也可以从源码中看到。</p><p><img src="/2023/12/06/rocketmq-broker/i21.png" alt="image-20231205172101035"></p><p><img src="/2023/12/06/rocketmq-broker/i22.png" alt="image-20231205172129342"></p><p>值得注意的是，RocketMQ在对commitLog、IndexFile等文件进行数据读写的时候，除了用到了<code>读写锁</code>外 ，还用到了<code>零拷贝技术（MMAP）</code>。具体到代码里面就是利用JDK里面NIO的MapperByteBuffer的map()函数，来先将磁盘文件（CommitLog文件、consumeQueue文件等）映射到内存里来。</p><p>假如没有使用mmap技术的时候，使用最传统和基本普通文件进行io操作会产生数据多拷贝问题。比如<strong>从磁盘上把数据读取到内核IO缓冲区</strong>里面，然后再<strong>从内核IO缓冲区中读取到用户进程私有空间</strong>里去，然后我们才能拿到这个数据，如下图（以下两张图均来自<a href="https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#mmap-write">小林coding</a>）。</p><p>这里的DMA，指的是<code>直接内存访问（Direct Memory Access）</code> 技术，简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p><img src="/2023/12/06/rocketmq-broker/i32.png" alt="image-20231206102441861"></p><p>MMAP内存映射是在<strong>硬盘上文件的位置</strong>和<code>应用程序缓冲区(application buffers)</code>进行映射（建立一种对应关系），当应用进程调用了<code>mmap()</code>后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核共享这个缓冲区。由于mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。之后的写文件，应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，从这可以看到，实际上只用到了一次CPU拷贝。</p><p><img src="/2023/12/06/rocketmq-broker/i31.png" alt="image-20231206102441861"></p><p>在RocketMQ中，我们可以在DefaultMappedFile类中的init方法中看到其应用：</p><p><img src="/2023/12/06/rocketmq-broker/i33.png" alt="image-20231206111036576"></p><h4 id="3、消息写入流程"><a href="#3、消息写入流程" class="headerlink" title="3、消息写入流程"></a>3、消息写入流程</h4><p>RocketMQ使用Netty处理网络，broker收到消息写入的请求就会进入<code>SendMessageProcessor</code>类中processRequest方法。</p><p><img src="/2023/12/06/rocketmq-broker/i25.png" alt="image-20231206102441861"></p><p>我们进入sendMessage中，就可以看到其逻辑，最终调用putMessage方法进行消息处理逻辑，当然如果开启了异步发送，就调用相应的异步处理逻辑。</p><p><img src="/2023/12/06/rocketmq-broker/i26.png" alt="image-20231206102749089"></p><p>我们再跟下去，就可以发现其最终是调用commitLog的写入逻辑，将消息存储到本地文件commitLog中。</p><p><img src="/2023/12/06/rocketmq-broker/i27.png" alt="image-20231206103055443"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ梳理-broker&quot;&gt;&lt;a href=&quot;#RocketMQ梳理-broker&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ梳理 - broker&quot;&gt;&lt;/a&gt;RocketMQ梳理 - broker&lt;/h1&gt;&lt;h3 id=&quot;一</summary>
      
    
    
    
    <category term="消息中间件" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="RocketMQ" scheme="http://example.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ梳理 - namesrv</title>
    <link href="http://example.com/2023/11/27/rocketmq-namesrv/"/>
    <id>http://example.com/2023/11/27/rocketmq-namesrv/</id>
    <published>2023-11-27T12:30:26.000Z</published>
    <updated>2023-11-27T12:38:18.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ梳理-namesrv"><a href="#RocketMQ梳理-namesrv" class="headerlink" title="RocketMQ梳理 - namesrv"></a>RocketMQ梳理 - namesrv</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近实习用到了rocketmq，在完成项目后，心血来潮，突然想深入地了解一下rocketmq，特在此记录一下。</p><p>本文结合rocketmq官方文档和网上的一些零零散散的资料，常识去简单梳理rocketmq整体执行流程，作为个人学习历程的记录。</p><h3 id="二、整体模块如下"><a href="#二、整体模块如下" class="headerlink" title="二、整体模块如下"></a>二、整体模块如下</h3><p><img src="/2023/11/27/rocketmq-namesrv/i1.png" alt="image-20231127105106106"></p><p>这是从gitHub上down下来的rocketmq源码，可以大致分为以下模块：</p><ol><li><strong>rocketmq-namesrv</strong>：namesrv服务，更新和路由发现 broker服务。</li><li><strong>rocketmq-broker</strong>：mq的核心，主要做消息存储，可以接收consumer和producer的请求，然后通过调用<strong>rocketmq-store</strong>服务对消息进行处理。</li><li><strong>rocketmq-store</strong>：存储层实现。</li><li><strong>rocketmq-remoting</strong>：基于netty的底层通信实现，rocketmq的底层实现。</li><li><strong>rocketmq-common</strong>：common服务，比如一些配置文件、常量。</li><li><strong>rocketmq-client</strong>：java版本的mq客户端。</li><li><strong>rocketmq-filter</strong>：消息过滤服务，相当于在broker和consumer中间加入了一个filter代理。</li><li><strong>rocketmq-srvutil</strong>：解析命令行的工具类ServerUtil。</li><li><strong>rocketmq-tools</strong>： mq集群管理工具，查询rocketmq的一些信息，如topic、message等</li></ol><h3 id="三、NameSrv源码分析"><a href="#三、NameSrv源码分析" class="headerlink" title="三、NameSrv源码分析"></a>三、NameSrv源码分析</h3><p>以下是namesrv的总入口，主要是要初始化两个类，<strong>NamesrvController</strong>与<strong>ControllerManager</strong>。</p><ol><li><strong>NamesrvController</strong>：NamesrvController是RocketMQ中的Name Server模块的控制器，负责<strong>管理Name Server节点的状态</strong>、<strong>消息的路由注册</strong>与<strong>查询</strong>等功能。它通过监控集群中所有的Name Server节点，并维护一张<strong>路由信息表</strong>，用于提供消息发送者和接收者之间的消息路由信息。NamesrvController还负责处理新的Name Server<strong>节点加入和退出集群时的动态路由更新</strong>。</li><li><strong>ControllerManager</strong>：ControllerManager是RocketMQ中的Controller模块的管理器，负责管理Broker、Topic、Cluster等<strong>元数据信息的变更和路由计算</strong>。ControllerManager通过选举产生一个Controller节点，该节点负责管理整个集群的元数据信息，并保证集群中各个Broker节点之间的<strong>状态一致性</strong>。ControllerManager通过<strong>心跳检测</strong>和<strong>元数据同步</strong>等机制来实现集群中<strong>元数据的一致性和可靠性</strong>。</li></ol><p>总的来说，NamesrvController主要负责<strong>管理Name Server节点的状态和消息路由信息</strong>，而ControllerManager则负责<strong>管理整个集群的元数据信息和路由计算</strong>。它们分别在RocketMQ的Name Server和Broker集群中扮演着重要的角色，确保了RocketMQ集群的稳定性和可靠性。</p><p><img src="/2023/11/27/rocketmq-namesrv/i2.png" alt="image-20231127110500654"></p><p>我们先来看NamesrvController的初始化，先是读取命令行和配置文件信息，为后续初始化做铺垫。</p><p><img src="/2023/11/27/rocketmq-namesrv/i4.png" alt="image-20231127111432393"></p><p><img src="/2023/11/27/rocketmq-namesrv/i3.png" alt="image-20231127111155609"></p><p>之后进行一系列基础组件的初始化，此处的loadConfig，就是依赖前面的namesrvConfig，之后就是初始化网络组件、线程池、registerProcessor等。</p><p><img src="/2023/11/27/rocketmq-namesrv/image-20231127111559360.png" alt="image-20231127111559360"></p><p>这里主要说一下上面的定时任务，我们知道namesrv是靠<strong>心跳机制</strong>去感知broker的，namesrv启动后，会一直监听，等待broker、producer、comsumer连接。broker在<strong>启动时向所有namesrv注册</strong>，生产者在发送消息之前先<strong>从namesrv获取broker服务器地址列表</strong>，然后根据<strong>负载均衡</strong>算法从列表中选择一台服务器进行消息发送。消费者在订阅某个主题的消息之前从namesrv获取broker服务器地址列表（有可能是集群），但是消费者选择从broker中订阅消息，订阅规则由 broker 配置决定。</p><p>可以说namesrv就是rocketmq的大脑，用于把broker、producer、consumer三者串联起来，这里就涉及到路由注册了。因为broker启动后向所有namesrv发送路由，然后通过心跳机制与namesrv之间维持一个<strong>长连接</strong>，当broker挂了后就需要把它从namesrv中剔除掉。</p><p><img src="/2023/11/27/rocketmq-namesrv/i5.png" alt="image-20231127112449538"></p><p><img src="/2023/11/27/rocketmq-namesrv/i6.png" alt="image-20231127112518324"></p><p>可以看到，namesrv每10s都会去brokerLiveTable去找超时的broker，并把相应的channel给关闭，然后将其从路由表中去除掉。</p><p>之后就是启动namesrv了，本质就是启动nettyServer与nettyClient。</p><p><img src="/2023/11/27/rocketmq-namesrv/i7.png" alt="image-20231127113109613"></p><p>这里我们看看这个<strong>routeInfoManager</strong>，因为我们之前namesrv剔除超时的broker时也用到了它。routeInfoManager主要用于路由管理，消息发送时客户端会从namesrv获取路由信息，同时broker会定时更新namesrv的路由信息。</p><p><img src="/2023/11/27/rocketmq-namesrv/i8.png" alt="image-20231127114006995"></p><p><img src="/2023/11/27/rocketmq-namesrv/i9.png" alt="image-20231127114042195"></p><p><img src="/2023/11/27/rocketmq-namesrv/i10.png" alt="image-20231127114110407"></p><p>我们从routeInfoManager中随便截了几个方法，可以看到它们都有一个共同点，都用到了锁，而且是<strong>读写锁</strong>。</p><p>因为我们之前说过，路由表上的操作可能非常频繁，消费者发送消息时需要获取topic列表，broker需要定时向namesrv发送心跳以维持长连接，需要频繁地读写路由表，所以这里用到了读写锁。</p><p>我们还可以观察到routeInfoManager了很多信息，topic消息队列路由信息、broker地址、cluster等等，但它们都有一个共同特点，就是<strong>内存存储</strong>，我们在前面分析模块时提到过，rocketmq-broker借助rocketmq-store模块做持久化存储，<strong>rocketmq-namesrv是没有持久化的功能的</strong>，这样设计可以提高namesrv的处理能力，专注于其“大脑”的功能。</p><p><img src="/2023/11/27/rocketmq-namesrv/i11.png" alt="image-20231127115444987"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ梳理-namesrv&quot;&gt;&lt;a href=&quot;#RocketMQ梳理-namesrv&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ梳理 - namesrv&quot;&gt;&lt;/a&gt;RocketMQ梳理 - namesrv&lt;/h1&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="消息中间件" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="RocketMQ" scheme="http://example.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop核心组件—Yarn的工作流程</title>
    <link href="http://example.com/2023/09/26/yarn-workflow/"/>
    <id>http://example.com/2023/09/26/yarn-workflow/</id>
    <published>2023-09-26T13:39:42.000Z</published>
    <updated>2023-09-26T14:05:49.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop核心组件—Yarn的工作流程"><a href="#Hadoop核心组件—Yarn的工作流程" class="headerlink" title="Hadoop核心组件—Yarn的工作流程"></a>Hadoop核心组件—Yarn的工作流程</h1><h3 id="一、作业提交阶段"><a href="#一、作业提交阶段" class="headerlink" title="一、作业提交阶段"></a>一、作业提交阶段</h3><ol><li><strong>Client</strong> 向整个集群提交 <strong>Job</strong>，同时申请一个 <strong>job_id</strong></li><li><strong>ResourceManager</strong> 收到 Client 的请求后，给 Client 返回该 <strong>job 资源的提交路径</strong>、<strong>hdfs 路径</strong>、<strong>job_id</strong> （每一个 job 都有一个唯一的 job_id）</li><li>Client 收到 ResourceManager 的响应后，将 <strong>Jar包</strong>、<strong>Configuration信息</strong>、<strong>InputSplit（数据分片信息）等</strong>数据到指定的资源提交路径</li><li>Client 向 ResourceManager 发送<strong>执行作业请求</strong></li></ol><h3 id="二、作业初始化阶段"><a href="#二、作业初始化阶段" class="headerlink" title="二、作业初始化阶段"></a>二、作业初始化阶段</h3><ol><li><strong>ApplicationManager</strong> 将 Job 添加到 <strong>ResourceScheduler</strong>（资源调度器），其维护了一个 <strong>job队列</strong></li><li>当轮到任务执行，ResourceScheduler 通知 ApplicationManager 有空闲的 <strong>NodeManager</strong> 可以用来执行当前任务</li><li>ApplicationManager 调用分配给它的 NodeManager，在其中开辟一个 <strong>Container</strong>，并在容器中启动需要被执行的Job的 <strong>ApplicationMaster</strong>，ApplicationMaster 获取 hdfs 上提交的文件，根据分片信息生成 <strong>Task</strong></li></ol><h3 id="三、任务分配阶段"><a href="#三、任务分配阶段" class="headerlink" title="三、任务分配阶段"></a>三、任务分配阶段</h3><ol><li>ApplicationMaster 向 ResourceManager <strong>申请运行 Task 任务的资源</strong></li><li>ResourceManager 将需要运行的 Task 任务分配给空闲的 NodeManager，NodeManager <strong>领取任务</strong>并<strong>创建用于执行任务的 Container</strong></li></ol><h3 id="四、任务运行阶段"><a href="#四、任务运行阶段" class="headerlink" title="四、任务运行阶段"></a>四、任务运行阶段</h3><ol><li>ApplicationMaster <strong>通知</strong>所有接收到任务的 NodeManager 启动计算</li><li>NodeManager <strong>启动计算</strong></li><li>如果任务执行完有后续的 Task，则向 ResourceManager 申请 Container <strong>执行后续 Task</strong></li><li>所有的 job 执行完后，<strong>ApplicationMaster 向 ResourceManager 申请注销自己</strong></li></ol><h3 id="五、任务完成阶段"><a href="#五、任务完成阶段" class="headerlink" title="五、任务完成阶段"></a>五、任务完成阶段</h3><ol><li>框架<strong>更新计算的进度和状态</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hadoop核心组件—Yarn的工作流程&quot;&gt;&lt;a href=&quot;#Hadoop核心组件—Yarn的工作流程&quot; class=&quot;headerlink&quot; title=&quot;Hadoop核心组件—Yarn的工作流程&quot;&gt;&lt;/a&gt;Hadoop核心组件—Yarn的工作流程&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Yarn" scheme="http://example.com/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>关于加密解密的小小总结</title>
    <link href="http://example.com/2023/08/23/crypt/"/>
    <id>http://example.com/2023/08/23/crypt/</id>
    <published>2023-08-23T12:51:33.000Z</published>
    <updated>2023-08-23T15:09:23.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于加密解密的小小总结"><a href="#关于加密解密的小小总结" class="headerlink" title="关于加密解密的小小总结"></a>关于加密解密的小小总结</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这篇文章不讲具体的加密算法，主要总结加密解密在项目中的具体应用，其中加密算法介绍内容来自</p><p>流程内容自于自己平常工作学习的总结，在这里小小记录一下。</p><h2 id="二、可逆加密与不可逆加密"><a href="#二、可逆加密与不可逆加密" class="headerlink" title="二、可逆加密与不可逆加密"></a>二、可逆加密与不可逆加密</h2><p>加密算法我们整体可以分为：<strong>可逆加密和不可逆加密</strong>，可逆加密又可以分为：<strong>对称加密和非对称加密</strong>。</p><h3 id="1、不可逆加密"><a href="#1、不可逆加密" class="headerlink" title="1、不可逆加密"></a>1、不可逆加密</h3><p>常见的不可逆加密算法有<strong>MD5</strong>，HMAC，SHA1、SHA-224、<strong>SHA-256</strong>、SHA-384，和SHA-512，其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为<strong>SHA2加密算法</strong>，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高。其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。</p><p>由于这些加密都是不可逆的，因此比较常用的场景就是<strong>用户密码加密</strong>，其验证过程就是<strong>通过比较两个加密后的字符串是否一样来确认身份的</strong>。网上也有很多自称是可以破解MD5密码的网站，其原理也是一样，就是有一个巨大的资源库，存放了许多字符串及对应的MD5加密后的字符串，通过你输入的MD5加密串来进行比较，如果过你的密码复杂度比较低，还是有很大机率验证出来的。</p><p>这里我们介绍一下SHA256，简单来说就是一个哈希函数。<strong>哈希函数，又称散列算法，是一种从任何一种数据中创建小的数字“指纹”的方法</strong>。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（或哈希值）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p><p><strong>对于任意长度的消息，SHA256都会产生一个256bit长的哈希值，称作消息摘要。</strong>这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的十六进制字符串来表示。</p><h3 id="2、对称加密算法"><a href="#2、对称加密算法" class="headerlink" title="2、对称加密算法"></a>2、对称加密算法</h3><p>对称加密算法是应用比较早的算法，<strong>在数据加密和解密的时用的都是同一个密钥</strong>，这就造成了密钥管理困难的问题。常见的对称加密算法有DES、3DES、AES128、AES192、<strong>AES256</strong> （默认安装的 JDK 尚不支持 AES256，需要安装对应的 jce 补丁进行升级 jce1.7，jce1.8）。其中AES后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适用的场景就是内网环境中的加解密。</p><h3 id="3、非对称加密算法"><a href="#3、非对称加密算法" class="headerlink" title="3、非对称加密算法"></a>3、非对称加密算法</h3><p>非对称加密算法有两个密钥，<strong>这两个密钥完全不同但又完全匹配</strong>。只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。常见的非对称加密有<strong>RSA、SM2</strong>等。</p><h3 id="4、加密盐"><a href="#4、加密盐" class="headerlink" title="4、加密盐"></a>4、加密盐</h3><p>加密盐也是比较常听到的一个概念，盐就是<strong>一个随机字符串</strong>用来和我们的加密串拼接后进行加密。加盐主要是为了提供加密字符串的安全性。假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串，而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><h3 id="1、注册登陆加密流程-SM2-SHA256"><a href="#1、注册登陆加密流程-SM2-SHA256" class="headerlink" title="1、注册登陆加密流程(SM2+SHA256)"></a>1、注册登陆加密流程(SM2+SHA256)</h3><p>注册：<br>  1、前端传入账号密码<br>  2、对密码使用SHA256哈希盐值加密(不可逆)，最终加密后的数据存入数据库<br>        可能格式：加密算法$迭代次数$盐值$最终密文<br>登陆：<br>  1、前端获取SM2公钥，对密码明文进行加密<br>  2、后端通过SM2私钥解密密码密文，之后从数据库获得用户的密码(盐值加密后的数据)，在密文中获得加密算法、盐值等数据，对SM2解密得到的密码明文进行盐值加密，比较两个数据是否一致</p><h3 id="2、API调用数据传输加密-RSA-AES、SM2-AES"><a href="#2、API调用数据传输加密-RSA-AES、SM2-AES" class="headerlink" title="2、API调用数据传输加密(RSA+AES、SM2+AES)"></a>2、API调用数据传输加密(RSA+AES、SM2+AES)</h3><p>RSA+AES、SM2+AES用于<strong>传输加密</strong>，为<strong>请求/返回信息</strong>做加密处理，保障数据传输的安全性。</p><p>RSA和SM2为<strong>非对称加密算法</strong>，SM2算法是一种更先进安全的算法，在安全性能、速度性能等方面都优于RSA算法，在我国商用密码体系中被用来替换RSA算法。</p><p>AES是<strong>对称加密算法</strong>，使用<strong>非对称加密算法和对称加密算法混合模式</strong>，在支持对大量数据加解密的同时，保证了加解密速度，安全性更高，主要应用于一些用户信息、敏感信息加密的安全性要求较高的场景。</p><p><strong>RSA/SM2</strong>：在API调用过程中，为每位用户创建<strong>相互独立的RSA、SM2密钥对</strong>，“公钥加密、私钥解密，私钥加密、公钥解密”。RSA/SM2公钥对用户可见，<strong>私钥平台进行管理</strong>。 RSA/SM2公钥用途：<strong>对AES密钥进行加密处理</strong>。 RSA/SM2私钥用途：<strong>对RSA/SM2公钥加密后的AES密钥进行解密</strong>。</p><p><strong>AES</strong>：需调用者通过程序手动生成AES密钥。 AES密钥用途：<strong>对请求/返回信息进行加密/解密处理</strong>。 </p><p>下面是传输加密的具体流程。</p><p>客户端：</p><ol><li>主动生成 AES主密钥</li><li>使用 AES主密钥 加密 请求信息</li><li>使用 RSA公钥(由私钥平台管理/提供) 加密 AES主密钥</li><li>发送 “RSA公钥加密后的AES主密钥” 和 由AES主密钥加密后的请求信息</li></ol><p>服务端：</p><ol><li>获取API的RSA公钥私钥信息(与上面的是同一对)，通过 RSA私钥 解密得到 AES主密钥</li><li>通过 AES主密钥 解密请求信息</li><li>通过 AES主密钥 加密返回数据，返回结果</li></ol><h3 id="3、AK-SK签名认证"><a href="#3、AK-SK签名认证" class="headerlink" title="3、AK/SK签名认证"></a>3、AK/SK签名认证</h3><p>AK/SK(AppKey+AppSecret/AccessKey+SecretAccessKey)签名是调用API的用户认证方式之一，常见的用户认证方式还有API-TOKEN、USER-TOKEN等，下面是具体流程。</p><p>客户端：</p><ol><li>使用AppSecret对请求内容计算得到签名(Signature)</li><li>发送请求，请求额外包含AppKey和Signature</li></ol><p>服务端：</p><ol><li>根据发送的AppKey查找数据库得到对应的AppSecret</li><li>使用同样的算法将请求内容和AppSecret一起计算签名（Signature）</li><li>对比用户发送的签名和服务端计算的签名，两者相同则认证通过，否则失败。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于加密解密的小小总结&quot;&gt;&lt;a href=&quot;#关于加密解密的小小总结&quot; class=&quot;headerlink&quot; title=&quot;关于加密解密的小小总结&quot;&gt;&lt;/a&gt;关于加密解密的小小总结&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="加密算法" scheme="http://example.com/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="加密算法" scheme="http://example.com/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="对称加密" scheme="http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
    <category term="签名认证" scheme="http://example.com/tags/%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 存储过程</title>
    <link href="http://example.com/2023/08/19/store-procedure/"/>
    <id>http://example.com/2023/08/19/store-procedure/</id>
    <published>2023-08-19T06:36:38.000Z</published>
    <updated>2023-08-23T15:12:10.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL-存储过程"><a href="#PostgreSQL-存储过程" class="headerlink" title="PostgreSQL 存储过程"></a>PostgreSQL 存储过程</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在实习期间遇到的一些问题，其实逻辑思路很简单，就是需要把关联表的一些脏数据清除，逻辑就是从原表获得所有id，再根据这个id去关系表中遍历所有数据，根据关系表中的数据进行判断更新。</p><p>理想的 sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> dt_app_user_rel r2</span><br><span class="line"><span class="keyword">set</span> r2.is_delete<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> r2.range_type<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> r2.data_key <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> r1.data_key</span><br><span class="line"><span class="keyword">from</span> dt_app_user_rel r1</span><br><span class="line"><span class="keyword">where</span> r1.app_id<span class="operator">=</span>r2.app_id <span class="keyword">and</span> r1.range_type<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> r1.is_delete<span class="operator">=</span><span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这过程中存在单表的自查询和更新，但这种情况是不被允许的，这个时候就需要用到存储过程了。</p><p>这里先附上存储过程的简单结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基础的存储过程语法模板</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">procedure</span> public.proc_check_data(check_period <span class="type">character</span>)</span><br><span class="line"><span class="keyword">language</span> <span class="string">&#x27;plpgsql&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> $BODY$</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 1、声明变量</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line"><span class="comment">-- 1.1、[声明变量]</span></span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">128</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 2、开始事务</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line"><span class="comment">-- 操作语句</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 3、结束事务</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$BODY$;</span><br></pre></td></tr></table></figure><p>其实会发现相当于只是把好几段 sql 放在一起，中间可以引入一些公共变量，从而完成一些靠单句查询无法完成的工作。</p><p>存储过程的优点除了这个，最重要的是可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>第二个则是存储过程可以提高性能。存储过程在创建的时候就进行了编译，将来使用的时候不用再重新编译。一般的SQL语句每执行一次就需要编译一次，所以使用存储过程提高了效率。</p><p>回到我们之前的问题，那么在依靠存储过程后，sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> &quot;public&quot;.&quot;process_dt_app_user_rel&quot;()</span><br><span class="line"> <span class="keyword">AS</span> $BODY$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    done <span class="type">BOOLEAN</span> :<span class="operator">=</span> <span class="literal">FALSE</span>;</span><br><span class="line">    app_id_val <span class="type">INT</span>;</span><br><span class="line">    cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> app_id <span class="keyword">FROM</span> dt_app_user_rel;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 临时表，存特定app_id下的所有可见用户id</span></span><br><span class="line">    <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_data_keys (data_key <span class="type">varchar</span>(<span class="number">255</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 打开游标</span></span><br><span class="line">    <span class="keyword">OPEN</span> cur;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 循环处理每个appId</span></span><br><span class="line">    LOOP</span><br><span class="line">        <span class="comment">-- 读取下一个appId</span></span><br><span class="line">        <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> app_id_val;</span><br><span class="line">        EXIT <span class="keyword">WHEN</span> <span class="keyword">NOT</span> FOUND;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 遍历app_id，查询对应的可见用户id</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_data_keys</span><br><span class="line">        <span class="keyword">SELECT</span> data_key</span><br><span class="line">        <span class="keyword">FROM</span> dt_app_user_rel</span><br><span class="line">        <span class="keyword">WHERE</span> range_type <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> is_delete <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">AND</span> app_id <span class="operator">=</span> app_id_val;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 执行UPDATE操作</span></span><br><span class="line">        <span class="keyword">UPDATE</span> dt_app_user_rel</span><br><span class="line">        <span class="keyword">SET</span> is_delete <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> range_type <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">AND</span> app_id <span class="operator">=</span> app_id_val</span><br><span class="line">        <span class="keyword">AND</span> data_key <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span> data_key</span><br><span class="line">            <span class="keyword">FROM</span> temp_data_keys</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 清空临时表</span></span><br><span class="line">        <span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> temp_data_keys;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">CLOSE</span> cur;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除临时表</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> temp_data_keys;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$BODY$</span><br><span class="line">  <span class="keyword">LANGUAGE</span> plpgsql</span><br></pre></td></tr></table></figure><p>最后这段 sql 编译后，就可以重复使用了，避免了下次脏数据清理时重复编写 sql。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PostgreSQL-存储过程&quot;&gt;&lt;a href=&quot;#PostgreSQL-存储过程&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL 存储过程&quot;&gt;&lt;/a&gt;PostgreSQL 存储过程&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="PostgreSQL" scheme="http://example.com/tags/PostgreSQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="存储过程" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Flink中TaskManager与Slots的关系</title>
    <link href="http://example.com/2023/07/19/flink-taskManager-slots/"/>
    <id>http://example.com/2023/07/19/flink-taskManager-slots/</id>
    <published>2023-07-19T06:44:31.000Z</published>
    <updated>2023-07-19T07:43:55.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flink中TaskManager与Slots的关系"><a href="#Flink中TaskManager与Slots的关系" class="headerlink" title="Flink中TaskManager与Slots的关系"></a>Flink中TaskManager与Slots的关系</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、TaskManager"><a href="#1、TaskManager" class="headerlink" title="1、TaskManager"></a>1、TaskManager</h3><p>Flink 采用 <strong>Master-Slave</strong> 主从架构，其中 <strong>JobManager</strong> 作为集群 <strong>Master节点</strong> ，主要负责<code>任务协调</code>和<code>资源分配</code>，<strong>TaskWorker</strong> （TaskManager） 作为<strong>Salve节点</strong>，用于<code>执行流task</code>。</p><p><code>JobManager</code>是<strong>控制</strong>一个<strong>应用程序执行</strong>的<code>主进程</code>，相当于集群的<strong>Master节点</strong>，且整个集群<code>有且只有一个</code><strong>活跃的 JobManager</strong> ，<strong>JobManager</strong> 负责整个 Flink 集群<code>任务的调度</code>以及<code>资源的管理</code>。</p><p>Flink  <code>TaskManager</code> 执行作业流的 task，并且缓存和交换数据流，TaskManager 负责执行用户代码。根据实际需求为 TaskManager 配置内存将有助于减少 Flink 的资源占用，增强作业运行的稳定性。</p><h3 id="2、Slots"><a href="#2、Slots" class="headerlink" title="2、Slots"></a>2、Slots</h3><p>Flink中每一个worker(TaskManager)都是一个 <strong>JVM进程</strong> ，它可能会在<strong>独立的线程</strong>上执行一个或多个subtask。为了控制一个TaskManager能接收多少个task，TaskManager通过task slot来进行控制（一个TaskManager至少有一个task slot）。</p><h2 id="二、TaskManager与Slots的关系"><a href="#二、TaskManager与Slots的关系" class="headerlink" title="二、TaskManager与Slots的关系"></a>二、TaskManager与Slots的关系</h2><p>每个task slot表示TaskManager<strong>拥有资源的一个固定大小的子集</strong>。假如一个TaskManager有三个slot，那么它会将<strong>其管理的内存</strong>分成三份给各个slot。资源slot化意味着<strong>一个<code>subtask</code>将不需要跟来自其他job的subtask竞争被管理的内存</strong>，取而代之的是它将拥有一定数量的内存储备。需要注意的是，这里<strong>不会涉及到CPU的隔离</strong>，slot目前仅仅用来隔离task的受管理的内存。</p><p>通过调整task slot的数量，允许用户定义subtask之间如何互相隔离。如果一个TaskManager一个slot，那将意味着每个task group运行在<strong>独立的JVM</strong>中（该JVM可能是通过一个特定的容器启动的），而一个TaskManager多个slot意味着更多的subtask可以共享同一个JVM。而在同一个JVM进程中的task将<strong>共享TCP连接</strong>（基于多路复用）和心跳消息。它们也可能共享数据集和数据结构，因此这减少了每个task的负载。</p><p>默认情况下，Flink允许<strong>子任务共享slot</strong>，即使它们是不同任务的子任务（前提是它们来自同一个job）。 这样的结果是，<strong>一个slot可以保存作业的整个管道</strong>。</p><p><strong>Task Slot是静态的概念，是指TaskManager具有的并发执行能力</strong>，可以通过参数taskmanager.numberOfTaskSlots进行配置；<strong>而并行度parallelism是动态概念，即TaskManager运行程序时实际使用的并发能力</strong>，可以通过参数parallelism.default进行配置。</p><p>假设现在有这样一个程序：</p><p><img src="/2023/07/19/flink-taskManager-slots/t1.png" alt="t1"></p><p>其任务划分大概如下图所示：</p><p><img src="/2023/07/19/flink-taskManager-slots/t2.png" alt="image-20230719150157728"></p><p>假设我们此时以集群部署三台TaskManager，每台TaskManager划分3个Slot，其执行流程图大致如下图所示：</p><p><img src="/2023/07/19/flink-taskManager-slots/t5.png" alt="image-20230719150310433"></p><p>比如此时我们的Job是 <strong>A(source+flatMap) —&gt; B(keyBy) —&gt; C(sum+print)</strong> 这样一个流，在单节点的情况下是一个<strong>串行流</strong>。但在分布式情况下，Job的执行流程可以大致理解为一个<strong>有向无环图</strong>，其执行流程可以如下图所示：</p><p><img src="/2023/07/19/flink-taskManager-slots/t4.png" alt="image-20230719152544567"></p><p>可以看到，Flink允许子任务共享Slot，即使它们是不同任务的子任务，如上图中的<strong>D —&gt; B —&gt; C</strong> 流，其与 <strong>A —&gt; B —&gt; C</strong> 流并不是同一个流，但它们仍能共享同一个 Slot。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flink中TaskManager与Slots的关系&quot;&gt;&lt;a href=&quot;#Flink中TaskManager与Slots的关系&quot; class=&quot;headerlink&quot; title=&quot;Flink中TaskManager与Slots的关系&quot;&gt;&lt;/a&gt;Flink中Ta</summary>
      
    
    
    
    <category term="Flink" scheme="http://example.com/categories/Flink/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Hadoop" scheme="http://example.com/tags/Hadoop/"/>
    
    <category term="Flink" scheme="http://example.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>怎么去实现动态扩展机制SPI</title>
    <link href="http://example.com/2023/06/18/extended-spi/"/>
    <id>http://example.com/2023/06/18/extended-spi/</id>
    <published>2023-06-18T02:30:24.000Z</published>
    <updated>2023-06-18T08:18:14.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么去实现动态扩展机制SPI"><a href="#怎么去实现动态扩展机制SPI" class="headerlink" title="怎么去实现动态扩展机制SPI"></a>怎么去实现动态扩展机制SPI</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>关于动态扩展机制SPI，在之前我有发过该类的文章，感兴趣的可以去看一下，或者可以自己去百度了解一下，在本篇文章中就不做过多的赘述了。</p><p>本篇主要是着重于怎么去实现SPI，参考于Dubbo SPI，感兴趣的可以去了解一下。</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p>Dubbo SPI的核心类在于ExtensionLoader，通过加载本地目录的配置文件以实现动态植入扩展类。</p><h4 id="1、配置类定义"><a href="#1、配置类定义" class="headerlink" title="1、配置类定义"></a>1、配置类定义</h4><p>我们这里仿照Dubbo里面对配置文件的定义，讲扩展接口的配置定义在资源路径下的 <strong>META-INF/extensions/</strong> 目录下，配置文件以对应扩展接口的类路径命名</p><p><img src="/2023/06/18/extended-spi/t1.png" alt="image-20230618104934725"></p><p>配置文件的内部以 <strong>Key-Value</strong> 键值对形式定义，key 由自己定义，value为对应实现类的类路径</p><p><img src="/2023/06/18/extended-spi/t2.png" alt="image-20230618104934725"></p><p>具体的结构如下图所示：</p><p><img src="/2023/06/18/extended-spi/t3.png" alt="image-20230618104934725"></p><p>基于上面的定义，给出获取实现类最简单的方式：</p><p><img src="/2023/06/18/extended-spi/t4.png" alt="image-20230618104934725"></p><p>程序运行情况：</p><p><img src="/2023/06/18/extended-spi/t5.png" alt="image-20230618104934725"></p><h4 id="2、模块化实现"><a href="#2、模块化实现" class="headerlink" title="2、模块化实现"></a>2、模块化实现</h4><p>基于上面的思路，已经可以简单的实现了，现在我们把它给完善一下。</p><ol><li><p>核心类属性</p><p><img src="/2023/06/18/extended-spi/t6.png" alt="image-20230618104934725"></p></li><li><p>内部方法 getExtensionLoader</p><p>首先传入<strong>扩展接口的类型</strong> ，以获取对应泛型的 <strong>ExtensionLoader</strong> 对象，在这里还可以做一些判别。此处引入了自定义的 @SPI 注解以判断该接口是否是扩展接口。</p><p><img src="/2023/06/18/extended-spi/t7.png" alt="t7"></p></li><li><p>内部方法 getExtension</p><p>getExtension 方法传入的是配置文件中的 <strong>Key</strong> 值，获取其对应的扩展实例，这里引入了泛型，其返回的是上一步中我们创建 ExtensionLoader 类时绑定的接口类型。</p><p><img src="/2023/06/18/extended-spi/t8.png" alt="t7"></p></li><li><p>内部方法 createExtension</p><p>当扩展实例还未被创建时，通过 <strong>double check</strong> 进行创建，然后调用 getExtensionsClasses 方法获取缓存，从缓存中获取对应的实现类。</p><p><img src="/2023/06/18/extended-spi/t9.png" alt="t7"></p></li><li><p>内部方法 getExtensionsClasses</p><p>一样用到了 <strong>double check</strong> ，通过调用 <strong>loadDirectory</strong> 方法去本地目录中加载扩展实现类，在这里传入了一个 Map，用于保存从配置文件中加载到的扩展实例对象。</p><p><img src="/2023/06/18/extended-spi/t10.png" alt="t7"></p></li><li><p>内部方法 loadDirectory</p><p>在本方法中组装我们真正要访问的某个配置文件，通过类加载器读取配置文件，调用 loadResource 解析配置文件，然后将加载到的类缓存起来。</p><p><img src="/2023/06/18/extended-spi/t11.png" alt="t7"></p></li><li><p>内部方法 loadResource</p><p>通过 <strong>BufferedReader</strong>  <strong>缓冲字符流</strong>按行读取配置文件，文件中以 <strong>Key-Value</strong> 的形式保存扩展信息，通过类加载器的 loadClass 方法加载对应的类，然后存入我们最初传入的缓存 Map 中。</p><p><img src="/2023/06/18/extended-spi/t12.png" alt="t7"></p></li></ol><h4 id="3、使用方式"><a href="#3、使用方式" class="headerlink" title="3、使用方式"></a>3、使用方式</h4><p><img src="/2023/06/18/extended-spi/t13.png" alt="t7"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么去实现动态扩展机制SPI&quot;&gt;&lt;a href=&quot;#怎么去实现动态扩展机制SPI&quot; class=&quot;headerlink&quot; title=&quot;怎么去实现动态扩展机制SPI&quot;&gt;&lt;/a&gt;怎么去实现动态扩展机制SPI&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="SPI" scheme="http://example.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo SPI</title>
    <link href="http://example.com/2023/06/13/dubbo-spi/"/>
    <id>http://example.com/2023/06/13/dubbo-spi/</id>
    <published>2023-06-13T01:54:18.000Z</published>
    <updated>2023-06-13T07:20:42.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><h2 id="一、什么是SPI机制？"><a href="#一、什么是SPI机制？" class="headerlink" title="一、什么是SPI机制？"></a>一、什么是SPI机制？</h2><p>SPI (Service Provider Interface)，主要用于扩展的作用。</p><p>举个例子来说，假如有一个框架有一个接口，他有自己默认的实现类，但是在代码运行的过程中，你不想用他的实现类或者想扩展一下他的实现类的功能，但是此时你又不能修改别人的源码，那么此时该怎么办？这时spi机制就有了用武之地。一般框架的作者在设计这种接口的时候不会直接去new这个接口的实现类，而是在Classpath路径底下将这个接口的实现类按作者约定的格式写在一个<strong>配置文件</strong>上，然后在运行的过程中通过java提供的api，从所有jar包中读取所有的这个指定文件中的内容，获取到实现类，用这个实现类，这样，如果你想自己替换原有的框架的实现，你就可以按照作者规定的方式配置实现，这样就能使用你自己写的实现类了。</p><p>spi机制其实体现了设计思想中的解耦思想，方便开发者对框架功能进行扩展。</p><h2 id="二、Spring中的SPI-SpringFactoriesLoader"><a href="#二、Spring中的SPI-SpringFactoriesLoader" class="headerlink" title="二、Spring中的SPI - SpringFactoriesLoader"></a>二、Spring中的SPI - SpringFactoriesLoader</h2><p>相信spring大家都不陌生，在spring扩展也是依赖spi机制完成的，只不过spring对于扩展文件约定在<strong>Classpath</strong> 路径下的 <strong>META-INF</strong> 目录底下，所有的文件名都是叫 <strong>spring.factories</strong>，文件里的内容是一个以一个个键值对的方式存储的，<strong>键为类的全限定名，值也为类的全限定名</strong>，如果有多个值，可以用逗号分割，有一点得注意的是，键和值本身约定并没有类与类之间的依赖关系（当然也可以有，得看使用场景的约定），也就是说键值可以没有任何关联，键仅仅是一种标识。</p><p>代表一种场景，最常见的自动装配的注解，**@EnableAutoConfiguration**，也就是代表自动装配的场景，当你需要你的类被自动装配，就可以以这个注解的权限定名键，你的类为名，这样springboot在进行自动装配的时候，就会拿这个键，找到你写的实现类来完成自动装配。</p><p>SpringBoot自动装配的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> &#123;</span><br><span class="line"><span class="comment">//selectImports</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//SpringBoot自动配置的入口方法</span></span><br><span class="line">        <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> autoConfigurationEntry.getConfigurations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot自动装配的核心原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取 annotationMetadata 的注解 @EnableAutoConfiguration 的属性</span></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.从资源类 spring.factories 中获取 EnableAutoConfiguration 对应的所有类</span></span><br><span class="line">List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.通过在注解 @EnableAutoConfiguration 设置exclude属性，可以排除指定的配置类</span></span><br><span class="line">configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line"><span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.根据注解 @Conditional 来判断是否需要排除某些配置类</span></span><br><span class="line">    configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.触发 AutoConfiguration 导入的相关事件</span></span><br><span class="line"><span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到，MybatisPlus也是按照Spring的规则来进行配置的，通过spring.factories中的键值org.springframework.boot.autoconfigure.EnableAutoConfiguration，以导入MybatisPlusAutoConfiguration完成SpringBoot与MybatisPlus的整合。</p><p><img src="/2023/06/13/dubbo-spi/t1.png"></p><h2 id="三、Dubbo中的SPI-ExtensionLoader"><a href="#三、Dubbo中的SPI-ExtensionLoader" class="headerlink" title="三、Dubbo中的SPI - ExtensionLoader"></a>三、Dubbo中的SPI - ExtensionLoader</h2><p>ExtensionLoader是dubbo的spi机制所实现的类，通过这个类来加载接口所有实现类，获取实现类的对象。同时每一个接口都会有一个自己的ExtensionLoader。</p><h3 id="1、Dubbo的配置文件约束"><a href="#1、Dubbo的配置文件约束" class="headerlink" title="1、Dubbo的配置文件约束"></a>1、Dubbo的配置文件约束</h3><p>dubbo会从四个目录读取文件META-INF/dubbo/internal/ 、META-INF/dubbo/ 、META-INF/services/、META-INF/dubbo/external/，文件名为接口的全限定名，内容为键值对，键为短名称（可以理解为spring中的对象的名称），值为实现类。</p><p><img src="/2023/06/13/dubbo-spi/t2.png"></p><p><img src="/2023/06/13/dubbo-spi/t3.png" alt="image-20230613112117030"></p><h3 id="2、-SPI注解的约束"><a href="#2、-SPI注解的约束" class="headerlink" title="2、@SPI注解的约束"></a>2、@SPI注解的约束</h3><p>dubbo中所有的扩展接口，都需要在接口上加@SPI注解，不然在创建ExtensionLoader的时候，会报错。</p><p><img src="/2023/06/13/dubbo-spi/t4.png" alt="image-20230613112117030"></p><p>顺便说说ExtensionDirector的作用，在3.0.3以前的版本，是没有这个类的，但是在之后的版本为了实现一些新的特性，就抽象出来了这个类，通过这个类来获取每个接口对应的ExtensionLoader。</p><h3 id="3、Dubbo中类的加载"><a href="#3、Dubbo中类的加载" class="headerlink" title="3、Dubbo中类的加载"></a>3、Dubbo中类的加载</h3><p>先说各种特性之前，先说一下这些实现类是如何加载的，类的加载是非常重要的一个环节，与后面的spi特性有重要的关系。</p><p>Dubbo中类加载依赖于<strong>ExtensionLoader</strong>类，默认是先调用getExtensionClasses这个方法的。</p><p><img src="/2023/06/13/dubbo-spi/t5.png" alt="image-20230613112117030"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        <span class="comment">//先判断缓存中是否存在</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        <span class="comment">//双重检查模式</span></span><br><span class="line">        <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                    <span class="comment">//加载拓展类</span></span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。</p><p><img src="/2023/06/13/dubbo-spi/t6.png" alt="image-20230613112117030"></p><p>loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。</p><p>下面研究下 loadDirectory方法：</p><p><img src="/2023/06/13/dubbo-spi/t7.png" alt="image-20230613112117030"></p><p>loadDirectory 通过 loadDirectoryInternal 方法加载资源。我们继续跟下去，在 loadDirectoryInternal 方法中最终通过调用 loadFromClass 方法，然后去加载在 loadDirectoryInternal 方法中用 classLoader 获取到的资源链接，我们再跟进 loadResource 方法</p><p><img src="/2023/06/13/dubbo-spi/t8.png" alt="image-20230613112117030"></p><p>下面是 loadResource 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, URL resourceURL, <span class="type">boolean</span> overridden, String[] includedPackages, String[] excludedPackages, String[] onlyExtensionClassLoaderPackages)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; newContentList = <span class="built_in">this</span>.getResourceContent(resourceURL);</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var10</span> <span class="operator">=</span> newContentList.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var10.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//按行读取配置文件</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> (String)var10.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="number">61</span>);</span><br><span class="line">                    String clazz;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                        clazz = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        clazz = line;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !<span class="built_in">this</span>.isExcluded(clazz, excludedPackages) &amp;&amp; <span class="built_in">this</span>.isIncluded(clazz, includedPackages) &amp;&amp; !<span class="built_in">this</span>.isExcludedByClassLoader(clazz, classLoader, onlyExtensionClassLoaderPackages)) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="literal">true</span>, classLoader), name, overridden);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var14) &#123;</span><br><span class="line">                    <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + <span class="built_in">this</span>.type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + var14.getMessage(), var14);</span><br><span class="line">                    <span class="built_in">this</span>.exceptions.put(line, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;0-15&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> + <span class="built_in">this</span>.type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, var15);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。</p><p>Dubbo加载扩展的整个流程如下：</p><p><img src="/2023/06/13/dubbo-spi/extension-load.png" alt="extension-load"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dubbo-SPI&quot;&gt;&lt;a href=&quot;#Dubbo-SPI&quot; class=&quot;headerlink&quot; title=&quot;Dubbo SPI&quot;&gt;&lt;/a&gt;Dubbo SPI&lt;/h1&gt;&lt;h2 id=&quot;一、什么是SPI机制？&quot;&gt;&lt;a href=&quot;#一、什么是SPI机制？&quot; c</summary>
      
    
    
    
    <category term="Dubbo" scheme="http://example.com/categories/Dubbo/"/>
    
    
    <category term="SPI" scheme="http://example.com/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://example.com/2023/06/10/design-pattern-builder/"/>
    <id>http://example.com/2023/06/10/design-pattern-builder/</id>
    <published>2023-06-10T07:58:34.000Z</published>
    <updated>2023-06-13T07:15:09.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-建造者模式"><a href="#设计模式-建造者模式" class="headerlink" title="设计模式 - 建造者模式"></a>设计模式 - 建造者模式</h1><p>建造模式是对象的创建模式。建造模式可以将一个产品的<strong>内部表象（internal representation）与产品的生产过程</strong>分割开来，从而可以使一个建造过程<strong>生成具有不同的内部表象的产品对象</strong>。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>建造者模式，相当于是对工厂生产产品的一种<strong>装配</strong>，由于这种装配可能随时改变，所以需要抽取出来，<strong>实现产品局部与整体的解耦</strong>（当然话又说回来，单个孤立产品还需要建造者？那就是多此一举）。着重理解装配的含义，对应在程序中就是相当于调用顺序，以及调用参数问题。理解起来还阔以哈，比起那几个工厂模式用的稍微少一丢丢。</p><p><strong>一般建造者模式都有以下几种固定的角色：</strong></p><p><strong>抽象建造者（Builder）角色</strong>：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，<strong>有多少零件，就有多少相应的建造方法。</strong></p><p><strong>具体建造者（ConcreteBuilder）角色</strong>：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。</p><p><strong>导演者（Director）角色</strong>：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</p><p><strong>产品（Product）角色</strong>：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</p><h2 id="二、用途"><a href="#二、用途" class="headerlink" title="二、用途"></a>二、用途</h2><p>1、需要生成的产品对象有<strong>复杂的内部结构</strong>，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。</p><p>2、需要生成的产品<strong>对象的属性相互依赖。</strong>建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。</p><p>3、在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。（<strong>满足跨平台修改扩展方便</strong>）</p><p>在框架中（Spring、Mybatis）的应用有：</p><ol><li>BeanDefinitionBuilder</li><li>RestTemplateBuilder</li><li>SpringApplicationBuilder</li><li>Mybatis中的XMLConfigBuilder</li><li>JPA中的CriteriaBuilder</li></ol><p>还有很多，比如HttpClient、Guava、Lombok等等，这里就不再一一列举了。</p><h2 id="三、场景"><a href="#三、场景" class="headerlink" title="三、场景"></a>三、场景</h2><p>假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅电子杂志，也可以通过网页结束订阅。当客户开始订阅时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。</p><p>这个系统含有<strong>客户端（Client）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder）、产品（WelcomeMessage和GoodbyeMessage）</strong>等角色。</p><p>抽象类AutoMessage源代码，send()操作仅仅是示意性的，并没有给出任何发送电子邮件的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AutoMessage</span> &#123;</span><br><span class="line">    <span class="comment">//收件人地址</span></span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="comment">//发件人地址</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="comment">//内容</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="comment">//发送日期</span></span><br><span class="line">    <span class="keyword">private</span> Date sendDate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收件人地址：&quot;</span> + to);</span><br><span class="line">        System.out.println(<span class="string">&quot;发件人地址：&quot;</span> + from);</span><br><span class="line">        System.out.println(<span class="string">&quot;标题：&quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + body);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送日期：&quot;</span> + sendDate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTo</span><span class="params">(String to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrom</span><span class="params">(String from)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSubject</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getSendDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sendDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSendDate</span><span class="params">(Date sendDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sendDate = sendDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类WelcomeMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeMessage</span> <span class="keyword">extends</span> <span class="title class_">AutoMessage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WelcomeMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送欢迎信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类GoodbyeMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodbyeMessage</span> <span class="keyword">extends</span> <span class="title class_">AutoMessage</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodbyeMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送欢送信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> AutoMessage msg;</span><br><span class="line">    <span class="comment">//标题零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//内容零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//收件人零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTo</span><span class="params">(String to)</span>&#123;</span><br><span class="line">        msg.setTo(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发件人零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrom</span><span class="params">(String from)</span>&#123;</span><br><span class="line">        msg.setFrom(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送时间零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSendDate</span><span class="params">()</span>&#123;</span><br><span class="line">        msg.setSendDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件产品完成后，用此方法发送邮件</span></span><br><span class="line"><span class="comment">     * 此方法相当于产品返还方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        msg.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者WelcomeBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WelcomeBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = <span class="keyword">new</span> <span class="title class_">WelcomeMessage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setBody(<span class="string">&quot;欢迎内容&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setSubject(<span class="string">&quot;欢迎标题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者GoodbyeBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodbyeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodbyeBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = <span class="keyword">new</span> <span class="title class_">GoodbyeMessage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setBody(<span class="string">&quot;欢送内容&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setSubject(<span class="string">&quot;欢送标题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导演者Director，这个类提供一个construct()方法，此方法调用建造者的建造方法，包括buildTo()、buildFrom()、buildSubject()、buildBody()、buildSendDate()等，从而一部分一部分地建造出产品对象，既AutoMessage对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    Builder builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，负责调用各零件的建造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">(String toAddress , String fromAddress)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.builder.buildTo(toAddress);</span><br><span class="line">        <span class="built_in">this</span>.builder.buildFrom(fromAddress);</span><br><span class="line">        <span class="built_in">this</span>.builder.buildSubject();</span><br><span class="line">        <span class="built_in">this</span>.builder.buildBody();</span><br><span class="line">        <span class="built_in">this</span>.builder.buildSendDate();</span><br><span class="line">        <span class="built_in">this</span>.builder.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomeBuilder</span>();</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        director.construct(<span class="string">&quot;toAddress@126.com&quot;</span>, <span class="string">&quot;fromAddress@126.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建造模式分成两个很重要的部分：</strong></p><ol><li>一个部分是<strong>Builder接口</strong>，这里是定义了<strong>如何构建各个部件</strong>，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</li><li>另外一个部分是<strong>Director</strong>，Director是知道<strong>如何组合来构建产品</strong>，也就是说Director负责<strong>整体的构建算法</strong>，而且通常是分步骤地来执行。</li></ol><p>不管如何变化，建造模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法。认识这点是很重要的，因为在建造模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。</p><p>再直白点说，建造模式的重心在于<strong>分离构建算法和具体的构造实现</strong>，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p><p>但对于建造者模式，还有另外一种简洁的写法，这里我们进行简单的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&quot;</span> + sex +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.sex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>此篇文章转载自CSDN博主「鼠晓」的文章，加上自己的一点总结<br>原文链接：<a href="https://blog.csdn.net/Small_Mouse0/article/details/66474580">https://blog.csdn.net/Small_Mouse0/article/details/66474580</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-建造者模式&quot;&gt;&lt;a href=&quot;#设计模式-建造者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式 - 建造者模式&quot;&gt;&lt;/a&gt;设计模式 - 建造者模式&lt;/h1&gt;&lt;p&gt;建造模式是对象的创建模式。建造模式可以将一个产品的&lt;strong&gt;内</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="建造者模式" scheme="http://example.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="http://example.com/2023/06/07/springLoopDependency/"/>
    <id>http://example.com/2023/06/07/springLoopDependency/</id>
    <published>2023-06-07T03:44:26.000Z</published>
    <updated>2023-06-13T07:38:39.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h3 id="1、为什么会出现循环依赖问题？"><a href="#1、为什么会出现循环依赖问题？" class="headerlink" title="1、为什么会出现循环依赖问题？"></a>1、为什么会出现循环依赖问题？</h3><p>​    在Spring中bean的生命周期大致为：</p><ol><li>从文件中得到UserService.class</li><li>推断使用的构造方法(有参或无参)</li><li>获得Class普通对象</li><li>依赖注入</li><li>初始化前(@PostConstruct)</li><li>初始化(afterPropertiesSet)</li><li>初始化后(AOP等操作)</li><li>若定义了AOP，生成代理对象(与原先的Class是两个不同的对象)</li><li>将对象或代理对象放入单例池</li></ol><p>​    依赖注入问题主要发生在依赖注入缓解，场景如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当AService依赖注入时，需要获取BService，由于BService尚未初始化，在单例池中找不到，需要创建，而BService中由依赖于AService，而此时AService正在创建，导致循环依赖。</p><h3 id="2、Spring是怎么解决循环依赖问题的？"><a href="#2、Spring是怎么解决循环依赖问题的？" class="headerlink" title="2、Spring是怎么解决循环依赖问题的？"></a>2、Spring是怎么解决循环依赖问题的？</h3><p>​    spring中通过三级缓存来解决循环依赖问题。</p><p>​    三级缓存就是三个Map，分别为：</p><ul><li><p>一级缓存：private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</p></li><li><p>二级缓存：private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16);</p><p>在出现循环依赖的情况下，保存进行提前AOP得到的代理对象</p></li><li><p>三级缓存：private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</p></li></ul><p>​        打破循环，存储&lt;beanName, ObjectFactory&gt;结构，ObjectFactory是一个lambda表达式，相当于一个回调函数</p><p>​    其流程大致如下：</p><p><img src="/2023/06/07/springLoopDependency/t1.png" alt="image-20230215172402999"></p><p>结论：三级缓存的作用是为了解决spring中Bean依赖注入时发生的循环依赖。如果不需要AOP，那么只需要二级缓存即可实现，如果有AOP，其实二级缓存也能够实现，但是会打破Bean的生命周期，不符合spring的原则，因为需要把AOP对象放入二级缓存中，那么就必须在所有需要AOP处理的Bean对象初始化之前就对Bean对象进行后置处理（生成AOP对象），即使没有发生循环依赖！这并不是spring想看到的，所以spring引入了三级缓存，而且存入的是&lt;beanName, ObjectFactory&gt;结构，ObjectFactory是一个lambda表达式，相当于一个回调函数，当发生循环依赖的时候，会进行lambda表达式的执行，获取到Bean对象或者 AOP代理对象，再将Bean对象或者 AOP代理对象存入二级缓存中，如果之后还有循环依赖指向该对象(类似 A 依赖 B , B 依赖 A和C ， C 依赖 A这种情况)，就直接从二级缓存里面获取，从而解决了循环依赖。（这里解释了为什么不直接在二级缓存里存放lambda表达式，因为同一个lambda表达式每执行一次，就会生成一个新的代理对象，不能保证单例）</p><h3 id="3、提前AOP代理对象的属性填充、初始化"><a href="#3、提前AOP代理对象的属性填充、初始化" class="headerlink" title="3、提前AOP代理对象的属性填充、初始化"></a>3、提前AOP代理对象的属性填充、初始化</h3><p>​    在Spring AOP提前代理后获得的代理对象没有经过属性填充和初始化。那么这个代理又是如何保证依赖属性的注入的呢？答案回到Spring AOP最早最早讲的JDK动态代理上找，JDK动态代理时，会将目标对象target保存在最后生成的代理$proxy中，当调用$proxy方法时会回调h.invoke，而h.invoke又会回调目标对象target的原始方法。</p><p>​        因此，其实在动态代理时，原始bean已经被保存在提前曝光代理中了。而后原始Bean继续完成属性填充和初始化操作。因为AOP代理$proxy中保存着traget也就是是原始bean的引用，因此后续原始bean的完善，也就相当于Spring AOP中的target的完善，这样就保证了Spring AOP的属性填充与初始化了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖&quot;&gt;&lt;a href=&quot;#Spring循环依赖&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖&quot;&gt;&lt;/a&gt;Spring循环依赖&lt;/h1&gt;&lt;h3 id=&quot;1、为什么会出现循环依赖问题？&quot;&gt;&lt;a href=&quot;#1、为什么会</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="循环依赖" scheme="http://example.com/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Feign远程调用原理</title>
    <link href="http://example.com/2023/06/07/principleOfFeign/"/>
    <id>http://example.com/2023/06/07/principleOfFeign/</id>
    <published>2023-06-07T03:38:40.000Z</published>
    <updated>2023-06-13T07:31:41.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign远程调用原理"><a href="#Feign远程调用原理" class="headerlink" title="Feign远程调用原理"></a>Feign远程调用原理</h1><h4 id="1、Feign远程调用流程图"><a href="#1、Feign远程调用流程图" class="headerlink" title="1、Feign远程调用流程图"></a>1、Feign远程调用流程图</h4><p><img src="/2023/06/07/principleOfFeign/t1.webp" alt="t1"></p><h4 id="2、基于面向接口的动态代理方式生成实现类"><a href="#2、基于面向接口的动态代理方式生成实现类" class="headerlink" title="2、基于面向接口的动态代理方式生成实现类"></a>2、基于面向接口的动态代理方式生成实现类</h4><p>​    在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p><p>​    在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，基本原理如下所示：</p><p><img src="/2023/06/07/principleOfFeign/t2.webp" alt="t1"></p><h4 id="3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现："><a href="#3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现：" class="headerlink" title="3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现："></a>3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现：</h4><p><img src="/2023/06/07/principleOfFeign/t3.webp" alt="t1"></p><h4 id="4、基于-RequestBean，动态生成Request"><a href="#4、基于-RequestBean，动态生成Request" class="headerlink" title="4、基于 RequestBean，动态生成Request"></a>4、基于 RequestBean，动态生成Request</h4><p>​    根据传入的Bean对象和注解信息，从中提取出相应的值，来构造Http Request 对象</p><h4 id="5、使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）"><a href="#5、使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）" class="headerlink" title="5、使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）"></a>5、使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）</h4><p>​    Feign 最终会将请求转换成http消息发送出去，传入的请求对象最终会解析成消息体，如下所示：</p><p><img src="/2023/06/07/principleOfFeign/t4.webp" alt="t1"></p><h4 id="6、拦截器负责对请求和返回进行装饰处理"><a href="#6、拦截器负责对请求和返回进行装饰处理" class="headerlink" title="6、拦截器负责对请求和返回进行装饰处理"></a>6、拦截器负责对请求和返回进行装饰处理</h4><p>​    在请求转换的过程中，Feign 抽象出来了拦截器接口，用于用户自定义对请求的操作，比如，如果希望Http消息传递过程中被压缩，可以定义一个请求拦截器。</p><h4 id="7、基于重试器发送HTTP请求"><a href="#7、基于重试器发送HTTP请求" class="headerlink" title="7、基于重试器发送HTTP请求"></a>7、基于重试器发送HTTP请求</h4><p>​    Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求</p><h4 id="8、发送Http请求"><a href="#8、发送Http请求" class="headerlink" title="8、发送Http请求"></a>8、发送Http请求</h4><p>​    Feign 真正发送HTTP请求是委托给 feign.Client 来做的。</p><p>​    Feign 默认底层通过JDK 的 java.net.HttpURLConnection 实现了feign.Client接口类,<strong>在每次发送请求的时候，都会创建新的HttpURLConnection 链接</strong>，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端。</p><p>Feign 整体框架非常小巧，在处理请求转换和消息解析的过程中，基本上没什么时间消耗。真正影响性能的，是处理Http请求的环节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Feign远程调用原理&quot;&gt;&lt;a href=&quot;#Feign远程调用原理&quot; class=&quot;headerlink&quot; title=&quot;Feign远程调用原理&quot;&gt;&lt;/a&gt;Feign远程调用原理&lt;/h1&gt;&lt;h4 id=&quot;1、Feign远程调用流程图&quot;&gt;&lt;a href=&quot;#1、F</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Feign" scheme="http://example.com/tags/Feign/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="远程调用" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
    <category term="原理" scheme="http://example.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>论@Configuration的实现原理</title>
    <link href="http://example.com/2023/06/07/principleOf-Configuration/"/>
    <id>http://example.com/2023/06/07/principleOf-Configuration/</id>
    <published>2023-06-07T03:35:54.000Z</published>
    <updated>2023-06-13T07:26:08.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration的实现原理"><a href="#Configuration的实现原理" class="headerlink" title="@Configuration的实现原理"></a>@Configuration的实现原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component(&quot;com.example.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource());</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，配置了JdbcTemplate的配置项，但没有@Configuration，也会出现一个事务失效问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">    jdbcTemplate.queryForList(<span class="string">&quot;update emp set name=&#x27;小明&#x27; where emp_id=2&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdbcTemplate.queryForList执行完直接提交，后续抛出异常也无法回滚数据。</p><p>​    再重温一遍事务的启动机制：</p><ol><li>事务管理器新建一个数据库连接conn，不用jdbcTemplate建连接，因为其默认autocommit=true，执行完会直接提交</li><li>设置conn.autocommit = false;</li><li>jdbc通过ThreadLocal&lt;Map&lt;DataSource, conn&gt;&gt;获取conn执行sql语句</li><li>如果一切正常，conn.commit()，否则conn.rollback()</li></ol><p>​    事务启动时事务管理器(PlatformTransactionManager)会新建一个数据库连接，将其存入ThreadLocal&lt;Map&lt;DataSource, conn&gt;&gt;中，然后取消事务自动提交，当jdbc需要时直接从ThreadLocal中获取。</p><p>​    此时的问题主要是，因为没有配置@Configuration，当代理对象执行到b()方法，然后执行jdbc数据库方法，此时jdbc获取conn的原理实际上是new JdbcTemplate(dataSource())，而事务管理器中transactionManager.setDataSource(dataSource())，相当于是两个不同的dataSource对象，而jdbc的dataSource对象默认autocommit=true，当执行完sql语句，直接提交，导致后续无法回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JdbcTemplate jdbcTemplate()&#123;</span><br><span class="line">    return new JdbcTemplate(dataSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public PlatformTransactionManager transactionManager()&#123;</span><br><span class="line">    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br><span class="line">    transactionManager.setDataSource(dataSource());</span><br><span class="line">    return transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    那么为什么标注了@Configuration之后，就能解决这个问题呢？其原理到底是什么？</p><p>​    @Configuration的原理也是基于动态代理的（AOP、@Lazy都是基于动态代理），底层原理大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class JdcbConfigProxy <span class="keyword">extends</span> <span class="title class_">JdbcConfig</span>&#123;</span><br><span class="line">JdbcConfig target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        .</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.jdbcTemplate();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//代理逻辑：先去ioc容器中找dataSource，若有直接return</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ioc.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="built_in">super</span>.dataSource();</span><br><span class="line">        ioc.putBean(dataSource);</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于动态代理，不论是jdbc还是transactionManager，其获取dataSource最终都要先去ioc容器中找，若找到</p><p>就直接返回，找不到在调用dataSource()方法创建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Configuration的实现原理&quot;&gt;&lt;a href=&quot;#Configuration的实现原理&quot; class=&quot;headerlink&quot; title=&quot;@Configuration的实现原理&quot;&gt;&lt;/a&gt;@Configuration的实现原理&lt;/h1&gt;&lt;figure</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="原理" scheme="http://example.com/tags/%E5%8E%9F%E7%90%86/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与RPC区别比较分析</title>
    <link href="http://example.com/2023/06/07/httpAndRpc/"/>
    <id>http://example.com/2023/06/07/httpAndRpc/</id>
    <published>2023-06-07T03:09:45.000Z</published>
    <updated>2023-06-13T07:24:49.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP与RPC区别比较分析"><a href="#HTTP与RPC区别比较分析" class="headerlink" title="HTTP与RPC区别比较分析"></a>HTTP与RPC区别比较分析</h1><h2 id="一、TCP的特点与问题"><a href="#一、TCP的特点与问题" class="headerlink" title="一、TCP的特点与问题"></a>一、TCP的特点与问题</h2><p>一想到TCP，我想大多数人第一时间想到的应该是：面向连接的、可靠的、基于字节流的。</p><p>如果我们需要使用TCP协议的话，就需要使用<strong>Socket编程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个Socket对象请求服务端的连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、从Socket对象中获取字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3、把字节输出流包装成打印流</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        ps.println(<span class="string">&quot;hello server!&quot;</span>);</span><br><span class="line">        <span class="comment">//4、刷新</span></span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1、定义一个ServerSocket对象进行服务端的端口注册</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、阻塞监听客户端的socket连接请求，当监听到一个连接请求后，执行后续代码</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3、从socket管道中得到一个字节输入流对象inputStream</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4、把字节输入流包装成 缓冲字符输入流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="comment">//5、按照通信的架构，对方怎么发，这里就要怎么收，服务端按行读取</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于bio是同步阻塞式，若接收不到客户端的一行数据，会一直阻塞</span></span><br><span class="line"><span class="comment">         * 读到一行数据后，继续循环阻塞等待</span></span><br><span class="line"><span class="comment">         * 客户端发完数据后宕机，socket关闭，此时服务端的socket也会跟着关闭，</span></span><br><span class="line"><span class="comment">         * 报Connection reset错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端接收到：&quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们简单演示了一下在Java中是如何基于BIO进行网络编程的，对于使用纯裸TCP存在的问题，我们关注点放在<strong>基于字节流上</strong>。</p><p>什么叫基于字节流？</p><p>就是当通信双方建立连接后，我们可以形象一点的看作，通信双方之间建立了一个“通信的管道”，想要通信的数据一个一个比特位在通信管道内传输。</p><blockquote><p>如果还不明白的话，我们可以打一个比方：<br>数据就像<strong>河流中的水</strong>一样；通信管道就是<strong>河道</strong>；河流中的水是由小的河流分支汇集而来（<strong>小分支</strong>就是一个一个用户发送数据）；最终河流汇入<strong>大海</strong>（大海就是数据接收方）。<br>大海收到河流中的水，但是收到的水并不是一批一批收到，而是不断的收到，这样大海无法确定对方在发送的时候一次发送了多少。所以在接收的时候，就可能一次收的比对方一次发的多，或者少。这就是大名鼎鼎的粘包问题</p></blockquote><p>总之，使用TCP就会有粘包问题，为了解决这个问题，我们就需要在TCP的上层（应用层）再设计一些自定义协议，解决粘包问题，最常见的就是HTTP，HTTP中的某一些字段就可以标识哪些属于同一个报文，这样就可以避免粘包问题。</p><h2 id="二、HTTP与RPC"><a href="#二、HTTP与RPC" class="headerlink" title="二、HTTP与RPC"></a>二、HTTP与RPC</h2><p>TCP是传输层的协议，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的应用层协议而已。</p><h3 id="1、HTTP协议"><a href="#1、HTTP协议" class="headerlink" title="1、HTTP协议"></a>1、HTTP协议</h3><p>HTTP协议【超文本传输协议】，平常我们用浏览器使用的就是HTTP一系列的协议，网上有很多详细的介绍，这里就不去展开了，以下是CSDN社区中的一位博主对HTTP的总结：</p><p><a href="https://blog.csdn.net/cdzg_zzk/article/details/127376175?spm=1001.2014.3001.5501">HTTP复习（一）</a><br><a href="https://blog.csdn.net/cdzg_zzk/article/details/127502145?spm=1001.2014.3001.5501">HTTP复习（二）</a></p><h3 id="2、RPC协议"><a href="#2、RPC协议" class="headerlink" title="2、RPC协议"></a>2、RPC协议</h3><p>而RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。</p><p>调用方法其实跟我们平常在代码中调用自定义方法（或者叫函数）差不多。只不过这个方法是远端服务器暴露出来的接口，我们通过这个接口去使用，就好像我们在调用本地函数一样，就屏蔽了底层网络细节，就方便了很多。需要完成一个任务就调用一个接口。简直不要太爽（回想一些基于TCP的socket通信）</p><p>虽然大部分RPC底层使用的是TCP，但是这也不被完全限制。RPC底层可以使用UDP/TCP，甚至是HTTP。</p><h3 id="3、有了HTTP，为什么还需要RPC？"><a href="#3、有了HTTP，为什么还需要RPC？" class="headerlink" title="3、有了HTTP，为什么还需要RPC？"></a>3、有了HTTP，为什么还需要RPC？</h3><p>其实RPC出现早于HTTP。TCP是上世纪70年代出现，HTTP是90年代才流行。但是TCP的粘包问题确实一直存在，这期间就要用各种各样的自定义应用层协议来解决粘包问题。</p><p>一些app，只需要客户端与自家的服务器进行消息传递【C/S架构】，这个时候各家使用各家的RPC协议就可以。</p><p>但是随着【B/S架构】发展，浏览器要访问各种服务器，这个使用每家的服务器都必须遵守统一的规则，所以HTTP应用越加广泛。</p><p>现在【B/S】【C/S】架构分割越来越不明显了，RPC一般只用于公司内部使用了。</p><h2 id="三、HTTP与RPC的区别"><a href="#三、HTTP与RPC的区别" class="headerlink" title="三、HTTP与RPC的区别"></a>三、HTTP与RPC的区别</h2><h3 id="1、服务发现"><a href="#1、服务发现" class="headerlink" title="1、服务发现"></a>1、服务发现</h3><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。</p><p>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，<strong>默认80端口</strong>。</p><p>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd</strong>，<strong>甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如CoreDNS。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h3 id="2、底层连接形式"><a href="#2、底层连接形式" class="headerlink" title="2、底层连接形式"></a>2、底层连接形式</h3><p>以主流的HTTP1.1协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。</p><p>而RPC协议，也跟HTTP类似，也是通过建立<strong>TCP长链接</strong>进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常高效。</p><p><img src="./httpAndRpc/t1.png" alt="t1"></p><h3 id="3、传输的内容"><a href="#3、传输的内容" class="headerlink" title="3、传输的内容"></a>3、传输的内容</h3><p>基于TCP传输的消息，说到底，无非都是<strong>消息头header</strong>和<strong>消息体body</strong>。</p><p>header：存储的是一些标志信息。可以传字符串也可以传二进制</p><p>body：实际传输的内容。一般采用JSON进行序列化</p><p><img src="./httpAndRpc/t2.png" alt="t1"></p><p>对于主流的HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但HTTP设计初是用于做网页文本展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用json来序列化结构体数据。</p><blockquote><p>对于HTTP/1.1来说，会有头部字段冗余，传输字符串而不是二进制，队头阻塞等等问题。但是HTTP/2进行了很好的改进。所以HTTP/2的性能不一定就比RPC差了。<br>甚至gRPC底层都是使用的HTTP/2</p></blockquote><p>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</p><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>本篇文章转载自CSDN社区博主 <strong>xiao zhou</strong>，原文总结自小林coding</p><p>原文连接：<a href="https://blog.csdn.net/cdzg_zzk/article/details/127564797">https://blog.csdn.net/cdzg_zzk/article/details/127564797</a></p><p>更多细节可以转至原文，也可以浏览小林coding</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP与RPC区别比较分析&quot;&gt;&lt;a href=&quot;#HTTP与RPC区别比较分析&quot; class=&quot;headerlink&quot; title=&quot;HTTP与RPC区别比较分析&quot;&gt;&lt;/a&gt;HTTP与RPC区别比较分析&lt;/h1&gt;&lt;h2 id=&quot;一、TCP的特点与问题&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Raft共识算法</title>
    <link href="http://example.com/2023/06/05/raft/"/>
    <id>http://example.com/2023/06/05/raft/</id>
    <published>2023-06-05T13:38:43.000Z</published>
    <updated>2023-06-13T07:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft共识算法"><a href="#Raft共识算法" class="headerlink" title="Raft共识算法"></a>Raft共识算法</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Raft是分布式系统中最经典且最为易理解的共识算法，共识指分布的多个参与者就值”value”达成一致。一旦参与者对某个值做出决定，这个决定将是最终的。当大多数参与者存活时，共识算法会在存活的参与者间达成值一致，这相当于全部参与者存活时达成的一致。故部分参与者达成的一致是整个系统有效的，这一特性使得分布式系统具备一定的容错能力。</p><p>更多细节可以阅读Raft官网文档：<a href="https://raft.github.io/">https://raft.github.io/</a></p><p>在讲解Raft算法的选举和故障转移过程之前，我们先引入Raft算法中的一些基本概念：</p><ol><li><p><strong>Follower</strong></p><p>Follower是请求的被动更新者，主要职责是从Leader接收更新请求，再将日志写入本地文件中。</p></li><li><p><strong>Candidate</strong></p><p>Leader选举中的候选者。如果Follower在一定的时间内，没有收到Leader的心跳，则判断Leader可能已经发生故障，此时启动Leader Election过程，本节点切换为Candidate参与Leader的竞选，直到选举结束。</p></li><li><p><strong>Leader</strong></p><p>所有请求的处理者，接收客户端发起的操作请求，写入本地日志后，同步至其他Follower节点。</p></li><li><p><strong>Term</strong></p><p>Raft把时间分为连续的任期(Term)，每个任期可以是任意时长，任期用连续的整数进行标号。每个任期首先进行Leader选举，选举时，多个Candidate竞争成为Leader，一旦某个节点成为Leader，其他节点则变回Follower，成为Leader的节点将在该任期内一直担任Leader，如果该Leader节点发生故障，其他节点会在新的任期内进行选举。任何一个任期内都不会有多个Leader。Raft系统中，任期是一个及其重要的概念，每个节点都维护着当前任期的值，每次节点间的通信都包含任期信息，每个节点在检测到自己的任期值低于其他节点时，都会更新自己的任期值，设置为检测到的较高的值。<strong>当Leader和Candidate发现自己的任期低于别的节点，则立即把自己转换为Follower。</strong></p><p>注意：任期与计时器是绑定到一起的。任何新任期的启动，必然伴随一个新计时器的启动。</p></li><li><p><strong>Raft RPC</strong></p><p>Raft核心部分只需要用到2个RPC：<strong>RequestVote</strong>和<strong>AppendEntries</strong>。每个Raft节点将会根据自己节点的状态数据来对这两种RPC请求进行处理。</p><p>RequestVote RPC是由Candidate发送给其他节点，请求其他节点为自己投票，如果一个Candidate获得了多数节点的投票，则该Candidate转变为Leader。</p><p>AppendEntries RPC是由Leader节点发送给其他节点，有两个作用，当其entries域为空时，该RPC作为Leader的心跳；当entries域不为空时，请求其他节点将entries域中的日志添加到自己的日志中。</p></li></ol><h2 id="二、Leader选举和Failover过程"><a href="#二、Leader选举和Failover过程" class="headerlink" title="二、Leader选举和Failover过程"></a>二、Leader选举和Failover过程</h2><h3 id="1、Leader的选举过程"><a href="#1、Leader的选举过程" class="headerlink" title="1、Leader的选举过程"></a>1、Leader的选举过程</h3><p>Raft采用心跳机制来触发Leader的选举。当系统启动时，所有的节点转化为Follower状态，设置任期（term）为0，并启动计时器（election timeout，即选举的超时时间），在超时时间内如果没有收到Leader节点的心跳，就会发起新一轮的选举，此时节点会从Follower转换为Candidate，而一旦转变为Candidate节点，就会做以下几件事情：</p><ol><li>增加自己的term任期数</li><li>启动一个新的election timeout计时器</li><li>给自己投一票</li><li>向集群中的每一个节点发送RequestVote RPC请求，并等待其他节点回复</li></ol><p>如果在新的计时器超时前收到多数节点（集群节点个数的一半）的同意投票，则转换为Leader。如果接收到的是其他节点的AppendEntries心跳RPC，说明其他节点早先与自己被选为Leader，则转换为Follower，同时将自己的任期更新为检测到的最高值。如果计时器超时的时候还没有接收到以上两种信息中的任何一种，则重复1-4步骤，进行新的选举。</p><p>节点在接受到多数节点的投票成为Leader后，会立即向所有节点发送AppendEntries 心跳RPC。所有Candidate收到心跳RPC后，转换为Follower，选举结束。</p><p>每个Follower在一个任期内只能投一票，采取先到先得的策略。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC，那说明Leader可能宕机或者是其他原因，则转换为Candidate，开始请求投票。</p><p>如果多个节点同时发起投票，每个节点都没有拿到多数票（这种情况成为Split Vote），则增加任期数，在新的任期内重新进行投票。有没有可能Split Vote反复发生，永远都选不出Leader呢？不会的。因为Raft采取随机超时时间，Raft系统有一个选举超时配置项，Follower和Candidate的计时器超时时间每次重新计算，随机选取配置时间的1倍到2倍之间。即使所有节点同时启动，由于随机超时时间的设置，各个节点一般不会同时转为Candidate，先转为Candidate的节点会先发起投票，从而获得多数票。因而在每个任期内，多个节点同时请求投票并且都只获得少数票的几率很小，连续多次发生这种情况几率更小，实际上可以认为完全不可能发生。一般情况下，基本上都在1-2个任期内选出Leader。</p><p>这里我们再细讲一下Leader的投票规则：</p><p>投票是一个<strong>first-come-first-serve</strong>的机制，即<strong>谁先找我我就给谁投票</strong>。我们想确保<strong>新的Leader在赢得选举的时候有所有已经提交（commit）的entry</strong>，因为这样就不需要向新Leader同步它不知道的已经同步信息。这就意味着<strong>所有entry只会向一个方向传递：从Leader到Follower</strong>。并且Leader也不会重写log里面已经存在的entry。<br>因此，当Candidate的log包含了所有已经提交的entry时，它才能赢得选举。为实现这点，Candidate需要获得集群中的大多数（超过集群server个数的一半）server的确认，当Candidate的log至少是“最新的”（up-to-date）时，则说明它的log中有所有的已经提交的entry。<br>因此，当投票者发现自己的log比Candidate的都新时，就会拒绝给该Candidate投票。<br>“最新的”（up-to-date） 定义：当Candidate发起RequestVote的RPC时，会包括上个log entry的index和term信息。投票者比较自己和Candidate的index和term，当term不同时，term越高则为越新；当term相同时，index越高则为越新。（lastTerm_v &gt; lastTerm_c) || (lastTerm_v &gt; lastTerm_c) &amp;&amp; (lastIndex_v &gt; lastIndex_c)</p><h3 id="2、Leader的Failover故障转移"><a href="#2、Leader的Failover故障转移" class="headerlink" title="2、Leader的Failover故障转移"></a>2、Leader的Failover故障转移</h3><p>Leader出现故障时，需要通过集群选举产生一个新的Leader。那怎么知道Leader是否出现了故障呢？这个我们其实在上面讲过了，Raft核心部分只需要用到2个RPC：<strong>RequestVote</strong>和<strong>AppendEntries</strong>。每个Raft节点将会根据自己节点的状态数据来对这两种RPC请求进行处理。当Candidate选举成Leader后，他会通过发送AppendEntries RPC请求，向其他节点推送持续的心跳。</p><p>如果Fellower节点在一定时间内未收到Leader发送的心跳信息（定期心跳信息包括不带日志的AppendEntriesRPC)，则认为Leader出现故障。所以和Leader存活有关的心跳时长，即Leader租约的长短时影响系统处理故障时长的一个因素。心跳时间不能太长(长了则不能今早的发现故障)，也不能太短（太短会频发触发选Leader的操作）从而影响效率。</p><h2 id="三、Raft算法的日志复制"><a href="#三、Raft算法的日志复制" class="headerlink" title="三、Raft算法的日志复制"></a>三、Raft算法的日志复制</h2><h4 id="1、日志复制的过程"><a href="#1、日志复制的过程" class="headerlink" title="1、日志复制的过程"></a>1、日志复制的过程</h4><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行地向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p><p>客户端的每一个请求都包含被复制状态机执行的指令。Leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让它们复制这条信息。假如这条日志被安全的复制，Leader就应用这条日志到自己的状态机中，并返回给客户端。如果Follower宕机或者运行缓慢或者丢包，Leader会不断的重试，直到所有的Follower最终都复制了所有的日志条目。</p><p><img src="/2023/06/05/raft/t1.jpg" alt="t1"></p><h4 id="2、日志的组成"><a href="#2、日志的组成" class="headerlink" title="2、日志的组成"></a>2、日志的组成</h4><p>日志由有序编号（log index）的日志条目所组成。每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了,如下图所示，共有 8 条日志，提交了 7 条。提交的日志都将通过状态机持久化到磁盘中，防止宕机。<br><img src="/2023/06/05/raft/t2.png" alt="t2"></p><h4 id="3、日志复制的详细介绍"><a href="#3、日志复制的详细介绍" class="headerlink" title="3、日志复制的详细介绍"></a>3、日志复制的详细介绍</h4><p>当Leader接收到由客户端发送的请求(请求中包含可以被复制状态机执行的命令)时，Leader将会把该请求作为新的内容添加到日志中(任期号为当前Leader所处的任期号，索引号为当前Leader本地存储的日志集合中的日志的最高索引号加1)。然后将该日志通过AppendEntries RPC消息发送到网络中其他的服务器(以下简称Follower)，从而复制该日志。在网络中Follower接收到该日志消息后则会返回复制成功的回复。</p><p>在Leader接收到网络中大部分的Follower的成功复制的回复之后，Leader便认为该日志可以被提交。此时Leader将会同时做三件事：</p><ol><li>将该日志应用到Leader本地的复制状态机</li><li>向所有Follower发送消息通知所有接收到该日志的Follower将该日志进行提交，然后应用到各自本地的复制状态机</li><li>将执行结果通知客户端</li></ol><p>当该日志消息成功在网络中大部分Follower本地的复制状态机执行过后，则可认为该日志已被提交。<strong>在当前日志被提交的过程中</strong>，<strong>如果Leader先前的某些日志还没有被提交，则将会一同提交</strong>。而网络中有些Follower可能由于网络状态原因反应缓慢或者崩溃，那么Leader将会无限次地尝试重复发送AppendEntries RPC消息到该Follower。直到成功为止。</p><h4 id="4、Leader切换导致的日志不一致性"><a href="#4、Leader切换导致的日志不一致性" class="headerlink" title="4、Leader切换导致的日志不一致性"></a>4、Leader切换导致的日志不一致性</h4><p><img src="/2023/06/05/raft/t3.png" alt="t2"></p><h4 id="5、日志的一致性检查"><a href="#5、日志的一致性检查" class="headerlink" title="5、日志的一致性检查"></a>5、日志的一致性检查</h4><p>如上所述，Follower在接收到AppendEntries RPC消息后则会返回复制成功的回复。实际上在接收到消息后会首先进行日志的一致性检查(正常情况下Leader与Follower的日志会保持一致，所以一致性检查不会失败)，一致性检查内容如下：</p><p>在Leader创建AppendEntries RPC消息时，消息中将会包含当前日志之前日志条目的任期号与索引号。Follower在接受到AppendEntries RPC消息后，将会检查之前日志的任期号与索引号是否匹配到。如果匹配则说明和Leader之前的日志是保持一致的，否则，如果没有匹配则会拒绝AppendEntries RPC消息。</p><p>一致性检查是一个归纳的过程。正常情况下，网络中第一条日志一定满足日志的一致性检查，然后第二条日志中包含第一条日志的任期号与索引号，所以只要Leader与Follower的第一条日志保持一致，那么第二条日志也会满足一致性检查，从而之后的每一条日志都会满足一致性检查。</p><p>从而得出了日志匹配属性:</p><ol><li>如果两个不同的日志实体具有相同的索引和任期号，那么它们存储有相同的命令。</li><li>如果两个不同的日志实体具有相同的索引和任期号，则所有先前条目中的日志都相同。(由一致性检查结果得出)</li></ol><h4 id="6、Raft日志不一致的解决方案"><a href="#6、Raft日志不一致的解决方案" class="headerlink" title="6、Raft日志不一致的解决方案"></a>6、Raft日志不一致的解决方案</h4><p>日志不一致的三种情况，网络不可能一直处于正常情况，因为Leader或者某个Follower有可能会崩溃，从而导致日志不能一直保持一致，因此存在以下三种情况：</p><ol><li>Follower缺失当前Leader上存在的日志条目。</li><li>Follower存在当前Leader不存在的日志条目。</li><li>Follower即缺失当前Leader上存在的日志条目，也存在当前Leader不存在的日志条目。</li></ol><p>比如，旧的Leader仅仅将AppendEntries RPC消息发送到一部分Follower就崩溃掉，然后新当选Leader的服务器恰好是没有收到该AppendEntries RPC消息的服务器)</p><p><img src="/2023/06/05/raft/t4.png" alt="t2"></p><p>备注：</p><ol><li>图中最上方是日志的索引号(1-12)，每个方块代表一条日志信息，方块内数字代表该日志所处的任期号。</li><li>图中当前Leader(图中最上方一行日志代表当前Leader日志)处于任期号为8的时刻。</li></ol><p>分析说明：<br>下面，以此图分析说明以上三种情况存在的原因：</p><ol><li>Follower a、Follower b满足以上说明的第一种情况：Follower崩溃没有接收到Leader发送的AppendEntries RPC消息。</li><li>Follower c在任期为6的时刻，Follower d在任期为7的时刻为Leader，但没有完全完成日志的发送便崩溃了，满足以上说明的第二种情况：Follower存在当前Leader不存在的日志条目。</li><li>Follower e在任期为4的时刻，Follower f在任期为2、3的时刻为Leader，但没有完全完成日志的发送便崩溃了，同时在其他服务器当选Leader时刻也没有接收到新的Leader发送的AppendEntries RPC消息，满足第三种情况：Follower即缺失当前Leader上存在的日志条目，也存在当前Leader不存在的日志条目。</li></ol><p><strong>如上文所示，根据日志的任期数目来判断节点是否为Leader，再次印证了任期的关键作用。</strong></p><p>Leader通过强迫Follower的日志重复自己的日志来处理不一致之处，这意味着Follower日志中的冲突日志将被Leader日志中的条目覆盖。这个过程如下：</p><ol><li>首先，Leader找到与Follower最开始日志发生冲突的位置，然后删除掉Follower上所有与Leader发生冲突的日志，最后将自己的日志发送给Follower以解决冲突。需要注意的是：Leader不会删除或覆盖自己本地的日志条目。</li><li>当发生日志冲突时，Follower将会拒绝由Leader发送的AppendEntries RPC消息，并返回一个响应消息告知Leader日志发生了冲突。</li><li>Leader为每一个Follower维护一个nextIndex值。该值用于确定需要发送给该Follower的下一条日志的位置索引。该值在当前服务器成功当选Leader后会重置为本地日志的最后一条索引号+1。</li><li>当Leader了解到日志发生冲突之后，便递减nextIndex值，并重新发送AppendEntries RPC到该Follower，不断重复这个过程，一直到Follower接受该消息。</li><li>一旦Follower接受了AppendEntries RPC消息，Leader则根据nextIndex值可以确定发生冲突的位置，从而强迫Follower的日志重复自己的日志以解决冲突问题。</li></ol><p><img src="/2023/06/05/raft/t5.png" alt="t2"></p><p>情况a：如上图，服务器S1在任期为2的时刻仅将日志index:2:2,term发送到了服务器S2便崩溃掉。</p><p>情况c：服务器S1在任期为4的时刻再次当选Leader(S1重启时，任期仍然为2，收到新的Leader S5发送的心跳信息后更新任期为3，而在Leader S5崩溃后，服务器S1为第一个计时器超时的，因此发起投票，任期更新为4，大于网络中其他服务器任期，成功当选Leader)，同时将日志index:2:2,term发送到了服务器S2和S3，但还没有通知服务器对日志进行提交便崩溃掉。</p><p>情况d：情况(a-&gt;d)如果在任期为2时服务器S1作为Leader崩溃掉，S5在任期为3的时刻当选Leader，由于日志index:2:2,term还没有被复制到大部分服务器上，并没有被提交，所以S5可以通过自己的日志index:2:3,term覆盖掉日志index:2:2,term。<br>情况e：情况(a-&gt;e)如果在任期为2时服务器S1作为Leader，并将index:2:2,term发送到S2和S3，成功复制到大多数成员服务器上。S1成功提交了该日志，那么即便S1崩溃掉，S5也无法成功当选Leader，因为S5不具备网络中最新的已被提交的日志条目，S5只有term为1的日志。</p><h2 id="四、Raft算法中成员变更过程解析"><a href="#四、Raft算法中成员变更过程解析" class="headerlink" title="四、Raft算法中成员变更过程解析"></a>四、Raft算法中成员变更过程解析</h2><h4 id="1、什么是成员变更？"><a href="#1、什么是成员变更？" class="headerlink" title="1、什么是成员变更？"></a>1、什么是成员变更？</h4><p>成员变更指的是系统成员变化，即服务器节点的上下线，这和由于宕机故障导致的上下线是不同的。宕机或者重启导致的上下线，是不会影响系统的注册的成员数量的，也就不会影响到一致性判断所依据的“多数派”的生成，众所周知，“多数派”是所有一致性的基础。成员变更时，会修改注册的成员数量，比如在实际应用中，为了提高安全等级，就很可能出现需要把备机数量由三台扩充到五台，在这种情况下，就发生了成员变更。</p><h4 id="2、直接变更存在的问题"><a href="#2、直接变更存在的问题" class="headerlink" title="2、直接变更存在的问题"></a>2、直接变更存在的问题</h4><p>在成员变更时，因为无法做到在同一个时刻使所有的节点从旧配置转换到新配置，那么直接从就配置向新配置切换就可能存在一个节点同时满足新旧配置的“超过半数”原则。</p><p>如下图，原集群由Server1、Server2、Server3，现在对集群做变更，增加Server4、Server5。如果采用直接从旧配置到新配置的切换，那么有一段时间存在两个不想交的“超过半数的集群”。</p><p><img src="/2023/06/05/raft/t6.png" alt="t2"></p><p>上图，中在中间位置Server1可以通过自身和Server2的选票成为Leader（满足旧配置下收到大多数选票的原则）；Server3可以通过自身和Server4、Server5的选票成为Leader（满足新配置线，即集群有5个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个Leader，这和协议是违背的。</p><h4 id="3、Raft的成员变更实现方案：分阶段变更"><a href="#3、Raft的成员变更实现方案：分阶段变更" class="headerlink" title="3、Raft的成员变更实现方案：分阶段变更"></a>3、Raft的成员变更实现方案：分阶段变更</h4><p>Raft提出了通过一个中间过渡阶段，即联合共识（joint consensus），逐步把数据写入的新的集群中。其具体做法是2阶段提交式的：</p><p>第一阶段：Leader收到C-old到C-new的配置变更请求时，创建C-old-new的日志并开始复制给其他节点，此日志和普通日志复制没有区别。此时做决策的仍然是C-old集群。</p><p>第二阶段：当只有C-old-new复制到大多数节点后，Leader以这个配置做决定，这个时候处于一个共同决定的过程，因为此时做决策的是C-old-new集群。</p><p>由于两阶段变更不存在一个阶段C-old和C-new可以同时根据自己的配置做出决定，所以不会出现上文描述的情况。</p><p><strong>原文链接：<a href="https://blog.csdn.net/qq_52668274/article/details/126898833?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_52668274/article/details/126898833?spm=1001.2014.3001.5506</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Raft共识算法&quot;&gt;&lt;a href=&quot;#Raft共识算法&quot; class=&quot;headerlink&quot; title=&quot;Raft共识算法&quot;&gt;&lt;/a&gt;Raft共识算法&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="共识算法" scheme="http://example.com/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 4</title>
    <link href="http://example.com/2023/05/15/rpc-framework-4/"/>
    <id>http://example.com/2023/05/15/rpc-framework-4/</id>
    <published>2023-05-15T11:44:29.000Z</published>
    <updated>2023-06-13T07:37:46.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-网络传输模块"><a href="#简易RPC框架-网络传输模块" class="headerlink" title="简易RPC框架 - 网络传输模块"></a>简易RPC框架 - 网络传输模块</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>我们在前面的文章中说到了客户端通过代理对象进行远程调用，其中通过Channel与服务端进行网络通信，其实就是通过网络请求来传递类信息、方法信息以及方法参数等数据到服务端。其中网络传输的具体实现在本项目中我们使用的是基于NIO的网络编程框架Netty。</p><h3 id="2、网络传输"><a href="#2、网络传输" class="headerlink" title="2、网络传输"></a>2、网络传输</h3><h4 id="1）网络传输实体类"><a href="#1）网络传输实体类" class="headerlink" title="1）网络传输实体类"></a>1）网络传输实体类</h4><p>在此我们先定义了一些在网络传输中的数据格式：</p><p>RpcRequest请求类，当你要调用远程方法时，需要将你要调用的方法的详细信息传输到服务器端，然后服务端就能根据这些信息去获取方法对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRpcServiceName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getInterfaceName() + getGroup() + getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcResponse响应类，服务端执行完请求后，就可以将响应信息封装成响应类传输给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">//response code</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">//response message</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//response body</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data, String requestId)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(RpcResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(RpcResponseCode.SUCCESS.getMessage());</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setData(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">fail</span><span class="params">(RpcResponseCodeEnum rpcResponseCodeEnum)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(rpcResponseCodeEnum.getCode());</span><br><span class="line">        response.setMessage(rpcResponseCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但真正在网络中传输不是仅仅是传输这个对象就行了，还有可能出现很多问题，比如在TCP传输过程中的黏包半包问题。</p><p>粘包和半包问题是数据传输中比较常见的问题，所谓的<strong>粘包问题是指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包。</strong>比如发送了两条消息，分别为“ABC”和“DEF”，那么正常情况下接收端也应该收到两条消息“ABC”和“DEF”，但接收端却收到的是“ABCD”，像这种情况就叫做粘包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/uuu.png" alt="uuu"></p><p>半包问题是指接收端只收到了部分数据，而非完整的数据的情况就叫做半包。比如发送了一条消息是“ABC”，而接收端却收到的是“AB”和“C”两条信息，这种情况就叫做半包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/yyy.png" alt="yyy"></p><p>为什么会出现黏包半包问题？粘包问题发生在 TCP/IP 协议中，<strong>因为 TCP 是面向连接的传输协议，它是以“流”的形式传输数据的，而“流”数据是没有明确的开始和结尾边界的，所以就会出现粘包问题</strong>。</p><h4 id="2）自定义传输协议"><a href="#2）自定义传输协议" class="headerlink" title="2）自定义传输协议"></a>2）自定义传输协议</h4><p>那要什么解决这个问题呢？我们采用自定义传输协议，并对数据进行相应的编码解码以解决这个问题。简单来说，我们通过设计传输协议，定义需要传输的数据以及其需要占多少字节的数据，当我们在收到传输数据后，就可以根据我们设计的传输协议去解析出正确的数据。</p><p>首先我们定义真正在网络中进行传输的对象，RpcMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessage</span> &#123;</span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> messageType;</span><br><span class="line">    <span class="comment">//序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> codec;</span><br><span class="line">    <span class="comment">//压缩类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> compress;</span><br><span class="line">    <span class="comment">//请求id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requestId;</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessage中的data就是上面的RpcRequest和RpcResponse，接下来我们详细讲解一下自定义的协议</p><p><img src="/2023/05/15/rpc-framework-4/aaa.png" alt="aaa"></p><ol><li>magic code 魔数：判断是否是遵循同一协议的数据，用来校验数据包有效性，占4byte</li><li>version 版本信息：后续可以用于协议的版本迭代，占1byte</li><li>full length 消息长度：请求头+请求体的总长度，占4byte</li><li>messageType 消息类型：消息可分为请求和相应两类，占1byte</li><li>compress 压缩类型：数据的压缩类型，占1byte</li><li>codec 序列化类型：RpcRequest和RpcResponse的序列化类型，占1byte</li><li>requestId 请求Id：请求Id，用于后续的消息跟踪，占4byte</li><li>body 请求体：RpcRequest或RpcResponse序列化后的byte数据</li></ol><h4 id="3）编解码器"><a href="#3）编解码器" class="headerlink" title="3）编解码器"></a>3）编解码器</h4><p>RpcMessageEncoder，自定义编码器，负责处理“出站”消息，将消息转换为字节数组然后写入到 <strong>ByteBuf</strong> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line">    <span class="comment">// 原子类，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ATOMIC_INTEGER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage rpcMessage, ByteBuf out)</span> &#123;</span><br><span class="line">        <span class="comment">//将RpcMessage对象转换为字节流，写入到ByteBuf中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入魔数</span></span><br><span class="line">            out.writeBytes(RpcConstants.MAGIC_NUMBER);</span><br><span class="line">            <span class="comment">//写入版本号</span></span><br><span class="line">            out.writeByte(RpcConstants.VERSION);</span><br><span class="line">            <span class="comment">//写入消息长度，先占位，后面再写入</span></span><br><span class="line">            out.writerIndex(out.writerIndex() + <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//写入消息类型</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> rpcMessage.getMessageType();</span><br><span class="line">            out.writeByte(messageType);</span><br><span class="line">            <span class="comment">//写入序列化类型</span></span><br><span class="line">            out.writeByte(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//写入压缩类型</span></span><br><span class="line">            out.writeByte(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">            <span class="comment">//写入requestId，相当于请求序号，为了全双工通信，提供异步能力</span></span><br><span class="line">            out.writeInt(ATOMIC_INTEGER.getAndIncrement());</span><br><span class="line">            <span class="comment">//获取消息长度和消息体</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//初始消息长度为消息头长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> RpcConstants.HEAD_LENGTH;</span><br><span class="line">            <span class="comment">//如果消息类型不是心跳包, fullLength = head length + body length</span></span><br><span class="line">            <span class="keyword">if</span> (messageType != RpcConstants.HEARTBEAT_REQUEST_TYPE</span><br><span class="line">                    &amp;&amp; messageType != RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">                <span class="comment">//获取序列化类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">                <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">                <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//                Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(codecName);</span></span><br><span class="line">                <span class="comment">//序列化消息体</span></span><br><span class="line">                bodyBytes = serializer.serialize(rpcMessage.getData());</span><br><span class="line">                <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">                <span class="comment">//获取压缩类型</span></span><br><span class="line"><span class="comment">//                String compressName = CompressTypeEnum.getName(rpcMessage.getCompress());</span></span><br><span class="line"><span class="comment">//                Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(compressName);</span></span><br><span class="line">                <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line">                <span class="comment">//压缩消息体</span></span><br><span class="line">                bodyBytes = compress.compress(bodyBytes);</span><br><span class="line">                <span class="comment">//最终消息长度 = 消息头长度 + 消息体长度</span></span><br><span class="line">                fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bodyBytes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//写入消息体</span></span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取写入索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> out.writerIndex();</span><br><span class="line">            <span class="comment">//回到消息长度的占位符位置：当前索引 - 消息长度占位符长度 + 魔数长度 + version长度</span></span><br><span class="line">            out.writerIndex(writeIndex - fullLength + RpcConstants.MAGIC_NUMBER.length + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//写入消息长度</span></span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            <span class="comment">//回到写入索引位置</span></span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Encode request error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessageDecoder，自定义解码器，负责“入站”数据，将 <strong>ByteBuf</strong> 中的字节数组转换为对应的消息数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// lengthFieldOffset = 魔数(4B) + 版本(1B) = 5B</span></span><br><span class="line">        <span class="comment">// lengthFieldLength = 消息长度 int(4B)</span></span><br><span class="line">        <span class="comment">// lengthAdjustment = -9，因为我们的长度域是从魔数开始的，所以我们需要调整长度域的偏移量</span></span><br><span class="line">        <span class="comment">// initialBytesToStrip = 0，我们会手动检查魔数和版本，所以不需要跳过任何字节</span></span><br><span class="line">        <span class="built_in">this</span>(RpcConstants.MAX_FRAME_LENGTH, <span class="number">5</span>, <span class="number">4</span>, -<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength      最大帧长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset   长度域(消息长度)的偏移量，简单而言就是偏移几个字节后才是长度域</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength   长度域的所占的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment    长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离值，Netty在解码时会根据该值计算消息体的开始位置，默认为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 最后解析结果中需要剥离的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">decoded</span> <span class="operator">=</span> <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decoded <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">frame</span> <span class="operator">=</span> (ByteBuf) decoded;</span><br><span class="line">            <span class="keyword">if</span> (frame.readableBytes() &gt;= RpcConstants.TOTAL_LENGTH) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> decodeFrame(frame);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Decode frame error!&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    frame.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> decoded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">decodeFrame</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序读取魔数、版本、消息长度</span></span><br><span class="line">        <span class="comment">//读取魔数并比较</span></span><br><span class="line">        checkMagicNumber(in);</span><br><span class="line">        <span class="comment">//读取版本并比较</span></span><br><span class="line">        checkVersion(in);</span><br><span class="line">        <span class="comment">//读取4字节消息长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//读取1字节消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节序列化类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">codecType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节压缩类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">compressType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取4字节请求ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//构建RpcMessage对象</span></span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder()</span><br><span class="line">                .codec(codecType)</span><br><span class="line">                .requestId(requestId)</span><br><span class="line">                .messageType(messageType).build();</span><br><span class="line">        <span class="comment">//根据消息类型解析消息</span></span><br><span class="line">        <span class="comment">//心跳消息</span></span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//普通消息</span></span><br><span class="line">        <span class="comment">//读取消息体长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> fullLength - RpcConstants.HEAD_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">            <span class="comment">//读取消息体</span></span><br><span class="line">            in.readBytes(bs);</span><br><span class="line">            <span class="comment">//解压缩</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">compressName</span> <span class="operator">=</span> CompressTypeEnum.getName(compressType);</span><br><span class="line">            <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">            <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line"><span class="comment">//            Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(compressName);</span></span><br><span class="line">            bs = compress.decompress(bs);</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">            <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//            Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(codecName);</span></span><br><span class="line">            <span class="comment">//根据消息类型反序列化</span></span><br><span class="line">            <span class="keyword">if</span> (messageType == RpcConstants.REQUEST_TYPE) &#123;</span><br><span class="line">                <span class="type">RpcRequest</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcRequest.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcResponse.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcMessage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkVersion</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取第5个字节，比较版本</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="keyword">if</span> (version != RpcConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;version isn&#x27;t compatible&quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkMagicNumber</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取前4个字节，比较魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> RpcConstants.MAGIC_NUMBER.length;</span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        in.readBytes(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] != RpcConstants.MAGIC_NUMBER[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Netty"><a href="#3、Netty" class="headerlink" title="3、Netty"></a>3、Netty</h3><h4 id="1）客户端"><a href="#1）客户端" class="headerlink" title="1）客户端"></a>1）客户端</h4><p>Netty客户端主要提供了以下方法：</p><ul><li>initClientApplication() 用于初始化客户端</li><li>doSubscribeService(Class serviceBean)  服务订阅，将标注了@Reference的属性缓存到本地，之后统一建立Channel</li><li>doConnectServer() 让客户端与@Reference对应的服务端建立Channel</li><li>sendRpcRequest() 发送RpcRequest数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcClient</span> <span class="keyword">implements</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> ClientConfig clientConfig;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bootstrap <span class="title function_">getBootstrap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initClientApplication</span><span class="params">()</span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        bootstrap.group(worker);</span><br><span class="line">        <span class="comment">//添加 ChannelHandler 以处理每个 Channel 的日志消息</span></span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//                ch.pipeline().addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                <span class="comment">//添加自定义的ChannelHandler</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcClientHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//TODO 从配置文件中读取服务发现类</span></span><br><span class="line">        <span class="built_in">this</span>.serviceDiscovery = <span class="keyword">new</span> <span class="title class_">ZkServiceDiscoveryImpl</span>();</span><br><span class="line"><span class="comment">//        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());</span></span><br><span class="line">        <span class="built_in">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">        <span class="built_in">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = PropertiesBootstrap.loadClientConfigFromLocal();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> <span class="title class_">ZkServiceRegistryImpl</span>();</span><br><span class="line">        CLIENT_CONFIG = clientConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务订阅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceBean 标注了<span class="doctag">@RpcReference</span>的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSubscribeService</span><span class="params">(Class serviceBean)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>();</span><br><span class="line">        url.setServiceName(serviceBean.getName());</span><br><span class="line">        url.setApplicationName(clientConfig.getApplicationName());</span><br><span class="line">        url.addParameter(<span class="string">&quot;host&quot;</span>, InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        <span class="comment">//subscribe：将URL存入SUBSCRIBE_SERVICE_LIST</span></span><br><span class="line">        serviceRegistry.subscribe(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始与各个provider建立连接，TODO 同时监听各个providerNode节点的变化（child变化和nodeData的变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnectServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//SUBSCRIBE_SERVICE_LIST 为所有标注了@RpcReference的属性的信息集合</span></span><br><span class="line">        <span class="keyword">for</span> (URL providerURL : SUBSCRIBE_SERVICE_LIST) &#123;</span><br><span class="line">            <span class="comment">//根据标注了@RpcReference的serviceName去Zookeeper上获取其对应的地址</span></span><br><span class="line">            List&lt;String&gt; providerIps = serviceDiscovery.lookupService(providerURL.getServiceName());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                相当于@RpcReference客户端与对应的每一个服务提供者建立连接</span></span><br><span class="line"><span class="comment">                @RpcReference</span></span><br><span class="line"><span class="comment">                OrderService orderService;</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8081</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8082</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String providerIp : providerIps) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ConnectionHandler.connect(providerURL.getServiceName(), providerIp);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据serviceName获取Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(rpcRequest.getInterfaceName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(channel.isActive())&#123;</span><br><span class="line">            <span class="comment">//将未处理的请求放入map中</span></span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            <span class="comment">//构建RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder().data(rpcRequest)</span><br><span class="line">                    .codec(SerializationTypeEnum.KYRO.getCode())</span><br><span class="line">                    .compress(CompressTypeEnum.GZIP.getCode())</span><br><span class="line">                    .messageType(RpcConstants.REQUEST_TYPE).build();</span><br><span class="line">            <span class="comment">//将请求发送给服务器</span></span><br><span class="line">            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;客户端发送消息: [&#123;&#125;]&quot;</span>, rpcMessage);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future.cause());</span><br><span class="line">                    log.error(<span class="string">&quot;发送消息时发生错误: &quot;</span>, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">(String interfaceName)</span>&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelProvider.get(interfaceName);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）服务端"><a href="#2）服务端" class="headerlink" title="2）服务端"></a>2）服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerConfig serverConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceProvider</span> <span class="variable">serviceProvider</span> <span class="operator">=</span> SingletonFactory.getInstance(ZkServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        CustomShutdownHook.getCustomShutdownHook().clearAll();</span><br><span class="line">        <span class="comment">//创建bossGroup和workerGroup</span></span><br><span class="line">        <span class="comment">//bossGroup只负责连接请求，workerGroup负责读写请求</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">//创建服务端启动对象</span></span><br><span class="line">        <span class="type">DefaultEventExecutorGroup</span> <span class="variable">serviceHandlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(</span><br><span class="line">                <span class="comment">//cpu核心数*2</span></span><br><span class="line">                Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">                <span class="comment">//创建线程工厂</span></span><br><span class="line">                ThreadPoolFactoryUtil.createThreadFactory(<span class="string">&quot;service-handler-group&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取本机ip</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line"><span class="comment">//                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span></span><br><span class="line">                    <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 当客户端第一次进行请求的时候才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="comment">//                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoEncoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoDecoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                            p.addLast(serviceHandlerGroup, <span class="keyword">new</span> <span class="title class_">NettyRpcServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//绑定端口，启动服务，sync()同步等待绑定成功，然后获取到ChannelFuture</span></span><br><span class="line">            bootstrap.bind(host, serverConfig.getServerPort()).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;启动NettyRpcServer服务时发生错误: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            log.info(<span class="string">&quot;断开NettyRpcServer服务&quot;</span>);</span><br><span class="line"><span class="comment">//            bossGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            workerGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            serviceHandlerGroup.shutdownGracefully();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴露服务 -- 如 127.0.0.1:8080 下的UserService、ProductService...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcServiceConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exposeService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        registerService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initServerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> PropertiesBootstrap.loadServerConfigFromLocal();</span><br><span class="line">        <span class="built_in">this</span>.setServerConfig(serverConfig);</span><br><span class="line">        SERVER_CONFIG = serverConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-网络传输模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-网络传输模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 网络传输模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 网络传输模块&lt;/h2&gt;&lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="RPC" scheme="http://example.com/categories/RPC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 3</title>
    <link href="http://example.com/2023/05/14/rpc-framework-3/"/>
    <id>http://example.com/2023/05/14/rpc-framework-3/</id>
    <published>2023-05-14T14:21:03.000Z</published>
    <updated>2023-06-13T07:37:40.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-服务订阅、发现模块"><a href="#简易RPC框架-服务订阅、发现模块" class="headerlink" title="简易RPC框架 - 服务订阅、发现模块"></a>简易RPC框架 - 服务订阅、发现模块</h2><h3 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h3><p>首先先看Rpc客户端的设计思路：</p><p><img src="/2023/05/14/rpc-framework-3/ttt.png" alt="ttt"></p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>这里也是直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyRpcClient client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">needInitClient</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasInitClientConfig</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = bean.getClass();</span><br><span class="line">        <span class="keyword">final</span> Field[] declaredFields = targetClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(RpcReference.class))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hasInitClientConfig) &#123;</span><br><span class="line">                    <span class="comment">//每个Reference对应一个RpcClient</span></span><br><span class="line">                    client = <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">                    client.initClientApplication();</span><br><span class="line">                    hasInitClientConfig = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                needInitClient = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcReference</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> RpcServiceConfig.builder()</span><br><span class="line">                        .group(annotation.group())</span><br><span class="line">                        .version(annotation.version())</span><br><span class="line">                        .build();</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">RpcClientProxy</span> <span class="variable">rpcClientProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClientProxy</span>(client, rpcServiceConfig);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> rpcClientProxy.getProxy(field.getType());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//代理类替换</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                    <span class="comment">//服务订阅</span></span><br><span class="line">                    client.doSubscribeService(field.getType());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务启动后，自动连接服务端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationReadyEvent 服务启动事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent applicationReadyEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needInitClient &amp;&amp; client != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot; ================== [&#123;&#125;] started success ================== &quot;</span>, client.getClass().getName());</span><br><span class="line">            ConnectionHandler.setBootstrap(client.getBootstrap());</span><br><span class="line">            <span class="comment">//将Client与每个服务提供者连接</span></span><br><span class="line">            client.doConnectServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们这里用到了ApplicationContext的事件机制，因为需要需要实现通道连接时保证所有的@Reference都已进行服务订阅，查了很多资料，学到了这个方法。首先该类实现了ApplicationListener，那么每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。我们这里监听的是ApplicationReadyEvent事件，当上下文已经准备完毕的时候触发onApplicationEvent()方法。</p><p>通过ApplicationContext的事件机制，我们就可以实现这个效果：Spring扫描整个类的@Reference属性，然后进行服务订阅，将@Reference对应的信息封装成URL对象。当上下文准备完毕，意味着所有的@Reference属性都已进行订阅，此时会触发onApplicationEvent()方法，将Client与每个@Reference属性对应的RpcServer建立一个Channel，之后当需要远程调用时，就可以在代理类中获取对应的Channel进行通信。</p><p>在这里，将URL和代理类贴出来，方便大家理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URL</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里面可以自定义不限进行扩展</span></span><br><span class="line"><span class="comment">     * 分组</span></span><br><span class="line"><span class="comment">     * 权重</span></span><br><span class="line"><span class="comment">     * 服务提供者的地址</span></span><br><span class="line"><span class="comment">     * 服务提供者的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParameter</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameters.putIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTERFACE_NAME</span> <span class="operator">=</span> <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestTransport rpcRequestTransport;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServiceConfig rpcServiceConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientProxy</span><span class="params">(RpcRequestTransport rpcRequestTransport, RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestTransport = rpcRequestTransport;</span><br><span class="line">        <span class="built_in">this</span>.rpcServiceConfig = rpcServiceConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 代理类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行方法: [&#123;&#125;]&quot;</span>, method.getName());</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .requestId(UUID.randomUUID().toString())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .group(rpcServiceConfig.getGroup())</span><br><span class="line">                .version(rpcServiceConfig.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">        RpcResponse&lt;Object&gt; rpcResponse = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//通过当前服务对应的唯一channel向服务器发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (rpcRequestTransport <span class="keyword">instanceof</span> NettyRpcClient) &#123;</span><br><span class="line">            CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">            rpcResponse = completableFuture.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcRequestTransport <span class="keyword">instanceof</span> SocketRpcClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!rpcResponse.getRequestId().equals(rpcRequest.getRequestId()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.REQUEST_NOT_MATCH_RESPONSE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse.getCode() == <span class="literal">null</span> || !rpcResponse.getCode().equals(RpcResponseCode.SUCCESS.getCode()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于服务订阅、通道连接的代码大家可以根据自己的需要进行设计，我这里就不再描述了。</p><p>至于负载均衡，可以在通道连接的时候设计，也可以按大家的想法来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-服务订阅、发现模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务订阅、发现模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务订阅、发现模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务订阅、发现模块&lt;/h2&gt;&lt;h3 id=&quot;1</summary>
      
    
    
    
    <category term="RPC" scheme="http://example.com/categories/RPC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 2</title>
    <link href="http://example.com/2023/05/12/rpc-framework-2/"/>
    <id>http://example.com/2023/05/12/rpc-framework-2/</id>
    <published>2023-05-12T06:18:57.000Z</published>
    <updated>2023-06-13T07:37:33.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-服务注册模块"><a href="#简易RPC框架-服务注册模块" class="headerlink" title="简易RPC框架 - 服务注册模块"></a>简易RPC框架 - 服务注册模块</h2><h3 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h3><p>紧接上文，结合框架结构图进行讲解：</p><p><img src="/2023/05/12/rpc-framework-2/xxx.jpg" alt="xxx"></p><p>本节主要讲解服务注册的细节，首先定义了三个注解：@RpcService、@RpcReference、@RpcScan</p><p>@RpcService用于标注服务提供者，@RpcReference用于标注服务消费者，@RpcScan用于扫描特定的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcScan &#123;</span><br><span class="line">    String[] basePackage() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>首先服务端执行的大致流程如下：</p><p><img src="/2023/05/12/rpc-framework-2/xxxx.png" alt="xxxx"></p><p>服务注册模块采用注解加包扫描的方式去实现，将标注了@RpcService服务的元信息注册到Zookeeper，然后客户端要向服务端发送消息时，就可以从Zookeeper中获取远程服务的信息完成服务的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; beanMap = applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span>(beanMap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明当前应用内部不需要对外暴露服务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NettyRpcServer</span> <span class="variable">nettyRpcServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">        nettyRpcServer.initServerConfig();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanMap.keySet()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;]&quot;</span>, beanName, RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">//build RpcServiceProperties</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanMap.get(beanName);</span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//构建暴露的服务的信息</span></span><br><span class="line">                rpcServiceConfig = RpcServiceConfig.builder()</span><br><span class="line">                        .host(InetAddress.getLocalHost().getHostAddress())</span><br><span class="line">                        .group(rpcService.group())</span><br><span class="line">                        .version(rpcService.version())</span><br><span class="line">                        .service(bean)</span><br><span class="line">                        .port(SERVER_CONFIG.getServerPort()).build();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            nettyRpcServer.exposeService(rpcServiceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动服务端，监听配置文件中定义的IP:PORT</span></span><br><span class="line">        nettyRpcServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中服务注册到Zookeeper的代码我就不放上来了，大家可以根据自己的需要自己定义规则。需要注意的是，在注册时我们还定义了一个服务端缓存类，用于存储服务端提供的类信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonServerCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServerConfig SERVER_CONFIG;</span><br><span class="line">    <span class="comment">//服务端发布的服务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; SERVICE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注册时需要把暴露的服务缓存到本地，后面才能为客户端提供服务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcServiceName</span> <span class="operator">=</span> rpcServiceConfig.getRpcServiceName();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> rpcServiceConfig.getService();</span><br><span class="line">    <span class="comment">//将服务名称和服务对象放入map中</span></span><br><span class="line">    <span class="keyword">if</span>(SERVICE_MAP.containsKey(rpcServiceName))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SERVICE_MAP.put(rpcServiceName, service);</span><br><span class="line">    log.info(<span class="string">&quot;服务注册 - 成功注册服务: &#123;&#125; 和接口: &#123;&#125;&quot;</span>, rpcServiceName, service.getClass().getInterfaces());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于客户端调用（服务订阅、服务发现）的细节我们会在后续的文章中进行讲解。</p><p>再来是包扫描的实现方式：</p><p>这里我们Bean注入方式是基于 <strong>ImportBeanDefinitionRegistrar</strong> 来实现的，这种方式是最灵活的，能在 <strong>registerBeanDefinitions</strong> 方法中获取到 <strong>BeanDefinitionRegistry</strong> 容器注册对象，可以手动控制 <strong>BeanDefinition</strong> 的创建和注册。</p><p>在此还要再引入一个类，<strong>ResourceLoader</strong> ，官方对 ResourceLoader的解释是：</p><p><em>Spring ResourceLoader为我们提供了一个统一的getResource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>文件、属性文件或图像文件)加载到Spring应用程序上下文中的不同实现</em></p><p>个人能力有限，我个人浅薄的理解大概是用于加载资源配置，有其他不同解释的欢迎在评论区留言。</p><p>因为要进行包扫描，所以我们就需要一个扫描器，这里我们定义的是 <strong>CustomScanner</strong> ，它实现了 <strong>ClassPathBeanDefinitionScanner</strong> 接口，可以实现将特定路径下的Bean对象注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomScanner</span><span class="params">(BeanDefinitionRegistry registry, Class&lt;? extends Annotation&gt; annoType)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(registry);</span><br><span class="line">        <span class="comment">//添加注解过滤器，只扫描标注了特定注解的Bean对象</span></span><br><span class="line">        <span class="built_in">super</span>.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(annoType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.scan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 registerBeanDefinitions() 方法中，我们先获取到 @RpcScan 的  <strong>AnnotationAttributes</strong> 注解属性，然后读取注解的 <strong>basePackage</strong> 的值，然后创建扫描器对象，把 <strong>BeanDefinitionRegistry</strong> 和注解类型传入扫描器中，然后就能通过执行扫描器里对应的 scan(basePackage) 方法进行扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line">    <span class="comment">//扫描框架项目的bean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_BEAN_BASE_PACKAGE</span> <span class="operator">=</span> <span class="string">&quot;com.hurried1y&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PACKAGE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">&quot;basePackage&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注解属性</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(RpcScan.class.getName()));</span><br><span class="line">        <span class="comment">//获取注解属性中的basePackage</span></span><br><span class="line">        String[] rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(annotationAttributes != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = annotationAttributes.getStringArray(BASE_PACKAGE_ATTRIBUTE_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有指定扫描包，则默认扫描当前类所在的包</span></span><br><span class="line">        <span class="keyword">if</span>(rpcScanBasePackages.length == <span class="number">0</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) importingClassMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, RpcService.class);</span><br><span class="line">        <span class="comment">//扫描 Component 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">componentScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, Component.class);</span><br><span class="line">        <span class="comment">//设置扫描包</span></span><br><span class="line">        <span class="keyword">if</span>(resourceLoader != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(resourceLoader);</span><br><span class="line">            componentScanner.setResourceLoader(resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">springBeanAmount</span> <span class="operator">=</span> componentScanner.scan(SPRING_BEAN_BASE_PACKAGE);</span><br><span class="line">        log.info(<span class="string">&quot;springBeanScanner扫描的数量 [&#123;&#125;]&quot;</span>, springBeanAmount);</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rpcServiceCount</span> <span class="operator">=</span> rpcServiceScanner.scan(rpcScanBasePackages);</span><br><span class="line">        log.info(<span class="string">&quot;rpcServiceScanner扫描的数量 [&#123;&#125;]&quot;</span>, rpcServiceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们有了实现了 ImportBeanDefinitionRegistrar 的类还不行，我们还得把它注册到容器中，这一步就在 @RpcScan 注解里通过 @<strong>Import</strong> 实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcScan &#123;</span><br><span class="line">    String[] basePackage() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-服务注册模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务注册模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务注册模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务注册模块&lt;/h2&gt;&lt;h3 id=&quot;1、结构设计&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="RPC" scheme="http://example.com/categories/RPC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 1</title>
    <link href="http://example.com/2023/05/12/rpc-framework-1/"/>
    <id>http://example.com/2023/05/12/rpc-framework-1/</id>
    <published>2023-05-12T05:24:57.000Z</published>
    <updated>2023-06-13T07:36:49.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-前言"><a href="#简易RPC框架-前言" class="headerlink" title="简易RPC框架 - 前言"></a>简易RPC框架 - 前言</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>Rpc框架想必大家都不陌生，常见的开源RPC框架如Dubbo、gRpc、Thrift等，为啥想到要手动实现一个Rpc框架，主要是本人对网络编程很感兴趣，想通过这个来加强自己对Java以及网络编程的理解，也能体验一下钻研的快乐。</p><h3 id="2、基础设计"><a href="#2、基础设计" class="headerlink" title="2、基础设计"></a>2、基础设计</h3><p>这个Rpc框架的最初设计大概如下图：</p><p><img src="/2023/05/12/rpc-framework-1/image-20230512133521798.png" alt="image-20230512133521798"></p><p>最初是尝试通过NIO去实现的，每个服务对应一个Client，即每个服务绑定一个Channel，然后通过Selector轮巡监听服务端的消息。服务端再这里扮演的是一个消息中转站的角色。显而易见的，这个设计存在着一个致命的问题，服务端怎么去分辨Selector上的每个通道对应的是哪个服务，查了很多资料都没有较好的办法，这个方案就不了了之了（最初测试的时候，我试过直接把服务端发布的服务对象序列化到Redis，但存在一些问题，比如当发布的服务中有不可序列化的属性时，就会出现问题）。</p><p>这个方案行不通，之后研究了一下Dubbo服务注册的大概思路，结合掘金里DannyIdea（小林）的<a href="https://juejin.cn/book/7047357110337667076/section">Java开发者的RPC实战课</a> 里对服务注册、订阅的讲解，对原本的设计进行了改进。</p><p>以下是Dubbo的基本架构图：</p><p><img src="/2023/05/12/rpc-framework-1/u=341734470,1171504543&fm=253&fmt=auto&app=138&f=JPEG.jpg" alt="u=341734470,1171504543&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG"></p><p>以下是现在对于框架的设计思路：</p><p><img src="/2023/05/12/rpc-framework-1/xxx.jpg" alt="xxx"></p><p>目前通信方式也由最初的NIO换成了Netty，实现自定义协议进行编码解码，解决了黏包半包等问题，后续可以扩展不同的序列化方式。</p><p>项目的地址在本人的gitee和github仓库：<a href="https://github.com/Hurried1y/rpc-framework/%EF%BC%8Chttps://gitee.com/hurried1y/rpc-framework">https://github.com/Hurried1y/rpc-framework/，https://gitee.com/hurried1y/rpc-framework</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-前言&quot;&gt;&lt;a href=&quot;#简易RPC框架-前言&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 前言&quot;&gt;&lt;/a&gt;简易RPC框架 - 前言&lt;/h2&gt;&lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="RPC" scheme="http://example.com/categories/RPC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring本地事务失效问题</title>
    <link href="http://example.com/2023/01/14/local-transaction-logs/"/>
    <id>http://example.com/2023/01/14/local-transaction-logs/</id>
    <published>2023-01-14T13:01:16.000Z</published>
    <updated>2023-06-13T07:25:32.456Z</updated>
    
    <content type="html"><![CDATA[<p>​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在spring中，事务的默认传播模式是propagation = Propagation.REQUIRED，即当b()方法需要一个事务，a()方法的事务会默认传递给b()方法，那么当a()方法中任何一处抛出异常，都会连同b()方法一起回滚。但存在的问题是。此时在b()方法中不论对事务做了什么设置，都是无效的，因为用的是a()方法的事务。再看c()方法，声明了propagation = Propagation.REQUIRES_NEW，即使用一个新事务，这样虽然配置能生效，但当a()方法抛出异常时，c()方法不会跟着一起回滚，显然达不到业务需求。</p><p>​        造成上面的原因是，同一个对象内的事务方法互相调用，绕过了代理对象。因为spring中的事务是通过代理对象实现的，那么能不能这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过代理对象调用方法，虽然配置会生效，但这会出现循环依赖问题，显然也不行。</p><p>正确的解决方法是使用代理对象来解决：</p><ol><li><p>引入aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在启动类标注@EnableAspectJAutoProxy(exposeProxy = true)</p><p>spring aop中有两种代理模式，一种是jdk动态代理，另外一种是cglib代理。</p><p>​        jdk动态代理是<code>JDK</code>原生的，不需要任何依赖即可使用，缺点是如果要使用<code>JDK</code>动态代理，被代理的类必须实现了接口，否则无法代理；<code>JDK</code>动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，<code>Spring</code>仍然会使用<code>JDK</code>的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。<code>JDK</code>动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低。</p><p>​        cglib代理的优点是，使用<code>CGLib</code>代理的类，不需要实现接口，因为<code>CGLib</code>生成的代理类是直接继承自需要被代理的类；<code>CGLib</code>生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；<code>CGLib</code>生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理。</p><p>​        在这里我们使用cglib代理，并配置对外暴露代理对象</p></li></ol><p>做好这些配置后，回到我们最初的场景，这时候我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Service&#123;</span><br><span class="line">@Transactional(timeout = 30)</span><br><span class="line">    public void a()&#123;</span><br><span class="line">    //拿到当前类的代理对象</span><br><span class="line">    Service service = (Service)AopContext.currentProxy();</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void b()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void c()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Bug" scheme="http://example.com/tags/Bug/"/>
    
  </entry>
  
</feed>
