<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hurried1y</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-13T07:05:01.128Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hurried1y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo SPI</title>
    <link href="http://example.com/2023/06/13/dubbo-spi/"/>
    <id>http://example.com/2023/06/13/dubbo-spi/</id>
    <published>2023-06-13T01:54:18.000Z</published>
    <updated>2023-06-13T07:05:01.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><h2 id="一、什么是SPI机制？"><a href="#一、什么是SPI机制？" class="headerlink" title="一、什么是SPI机制？"></a>一、什么是SPI机制？</h2><p>SPI (Service Provider Interface)，主要用于扩展的作用。</p><p>举个例子来说，假如有一个框架有一个接口，他有自己默认的实现类，但是在代码运行的过程中，你不想用他的实现类或者想扩展一下他的实现类的功能，但是此时你又不能修改别人的源码，那么此时该怎么办？这时spi机制就有了用武之地。一般框架的作者在设计这种接口的时候不会直接去new这个接口的实现类，而是在Classpath路径底下将这个接口的实现类按作者约定的格式写在一个<strong>配置文件</strong>上，然后在运行的过程中通过java提供的api，从所有jar包中读取所有的这个指定文件中的内容，获取到实现类，用这个实现类，这样，如果你想自己替换原有的框架的实现，你就可以按照作者规定的方式配置实现，这样就能使用你自己写的实现类了。</p><p>spi机制其实体现了设计思想中的解耦思想，方便开发者对框架功能进行扩展。</p><h2 id="二、Spring中的SPI-SpringFactoriesLoader"><a href="#二、Spring中的SPI-SpringFactoriesLoader" class="headerlink" title="二、Spring中的SPI - SpringFactoriesLoader"></a>二、Spring中的SPI - SpringFactoriesLoader</h2><p>相信spring大家都不陌生，在spring扩展也是依赖spi机制完成的，只不过spring对于扩展文件约定在<strong>Classpath</strong> 路径下的 <strong>META-INF</strong> 目录底下，所有的文件名都是叫 <strong>spring.factories</strong>，文件里的内容是一个以一个个键值对的方式存储的，<strong>键为类的全限定名，值也为类的全限定名</strong>，如果有多个值，可以用逗号分割，有一点得注意的是，键和值本身约定并没有类与类之间的依赖关系（当然也可以有，得看使用场景的约定），也就是说键值可以没有任何关联，键仅仅是一种标识。</p><p>代表一种场景，最常见的自动装配的注解，**@EnableAutoConfiguration**，也就是代表自动装配的场景，当你需要你的类被自动装配，就可以以这个注解的权限定名键，你的类为名，这样springboot在进行自动装配的时候，就会拿这个键，找到你写的实现类来完成自动装配。</p><p>SpringBoot自动装配的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> &#123;</span><br><span class="line"><span class="comment">//selectImports</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">//SpringBoot自动配置的入口方法</span></span><br><span class="line">        <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> autoConfigurationEntry.getConfigurations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot自动装配的核心原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取 annotationMetadata 的注解 @EnableAutoConfiguration 的属性</span></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.从资源类 spring.factories 中获取 EnableAutoConfiguration 对应的所有类</span></span><br><span class="line">List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.通过在注解 @EnableAutoConfiguration 设置exclude属性，可以排除指定的配置类</span></span><br><span class="line">configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line"><span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.根据注解 @Conditional 来判断是否需要排除某些配置类</span></span><br><span class="line">    configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.触发 AutoConfiguration 导入的相关事件</span></span><br><span class="line"><span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到，MybatisPlus也是按照Spring的规则来进行配置的，通过spring.factories中的键值org.springframework.boot.autoconfigure.EnableAutoConfiguration，以导入MybatisPlusAutoConfiguration完成SpringBoot与MybatisPlus的整合。</p><p><img src="/2023/06/13/dubbo-spi/t1.png"></p><h2 id="三、Dubbo中的SPI-ExtensionLoader"><a href="#三、Dubbo中的SPI-ExtensionLoader" class="headerlink" title="三、Dubbo中的SPI - ExtensionLoader"></a>三、Dubbo中的SPI - ExtensionLoader</h2><p>ExtensionLoader是dubbo的spi机制所实现的类，通过这个类来加载接口所有实现类，获取实现类的对象。同时每一个接口都会有一个自己的ExtensionLoader。</p><h3 id="1、Dubbo的配置文件约束"><a href="#1、Dubbo的配置文件约束" class="headerlink" title="1、Dubbo的配置文件约束"></a>1、Dubbo的配置文件约束</h3><p>dubbo会从四个目录读取文件META-INF/dubbo/internal/ 、META-INF/dubbo/ 、META-INF/services/、META-INF/dubbo/external/，文件名为接口的全限定名，内容为键值对，键为短名称（可以理解为spring中的对象的名称），值为实现类。</p><p><img src="/2023/06/13/dubbo-spi/t2.png"></p><p><img src="/2023/06/13/dubbo-spi/t3.png" alt="image-20230613112117030"></p><h3 id="2、-SPI注解的约束"><a href="#2、-SPI注解的约束" class="headerlink" title="2、@SPI注解的约束"></a>2、@SPI注解的约束</h3><p>dubbo中所有的扩展接口，都需要在接口上加@SPI注解，不然在创建ExtensionLoader的时候，会报错。</p><p><img src="/2023/06/13/dubbo-spi/t4.png" alt="image-20230613112117030"></p><p>顺便说说ExtensionDirector的作用，在3.0.3以前的版本，是没有这个类的，但是在之后的版本为了实现一些新的特性，就抽象出来了这个类，通过这个类来获取每个接口对应的ExtensionLoader。</p><h3 id="3、Dubbo中类的加载"><a href="#3、Dubbo中类的加载" class="headerlink" title="3、Dubbo中类的加载"></a>3、Dubbo中类的加载</h3><p>先说各种特性之前，先说一下这些实现类是如何加载的，类的加载是非常重要的一个环节，与后面的spi特性有重要的关系。</p><p>Dubbo中类加载依赖于<strong>ExtensionLoader</strong>类，默认是先调用getExtensionClasses这个方法的。</p><p><img src="/2023/06/13/dubbo-spi/t5.png" alt="image-20230613112117030"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        <span class="comment">//先判断缓存中是否存在</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        <span class="comment">//双重检查模式</span></span><br><span class="line">        <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                    <span class="comment">//加载拓展类</span></span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。</p><p><img src="/2023/06/13/dubbo-spi/t6.png" alt="image-20230613112117030"></p><p>loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。</p><p>下面研究下 loadDirectory方法：</p><p><img src="/2023/06/13/dubbo-spi/t7.png" alt="image-20230613112117030"></p><p>loadDirectory 通过 loadDirectoryInternal 方法加载资源。我们继续跟下去，在 loadDirectoryInternal 方法中最终通过调用 loadFromClass 方法，然后去加载在 loadDirectoryInternal 方法中用 classLoader 获取到的资源链接，我们再跟进 loadResource 方法</p><p><img src="/2023/06/13/dubbo-spi/t8.png" alt="image-20230613112117030"></p><p>下面是 loadResource 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, URL resourceURL, <span class="type">boolean</span> overridden, String[] includedPackages, String[] excludedPackages, String[] onlyExtensionClassLoaderPackages)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; newContentList = <span class="built_in">this</span>.getResourceContent(resourceURL);</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var10</span> <span class="operator">=</span> newContentList.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var10.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//按行读取配置文件</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> (String)var10.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="number">61</span>);</span><br><span class="line">                    String clazz;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                        clazz = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        clazz = line;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !<span class="built_in">this</span>.isExcluded(clazz, excludedPackages) &amp;&amp; <span class="built_in">this</span>.isIncluded(clazz, includedPackages) &amp;&amp; !<span class="built_in">this</span>.isExcludedByClassLoader(clazz, classLoader, onlyExtensionClassLoaderPackages)) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="literal">true</span>, classLoader), name, overridden);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var14) &#123;</span><br><span class="line">                    <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + <span class="built_in">this</span>.type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + var14.getMessage(), var14);</span><br><span class="line">                    <span class="built_in">this</span>.exceptions.put(line, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;0-15&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> + <span class="built_in">this</span>.type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, var15);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。</p><p>Dubbo加载扩展的整个流程如下：</p><p><img src="/2023/06/13/dubbo-spi/extension-load.png" alt="extension-load"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dubbo-SPI&quot;&gt;&lt;a href=&quot;#Dubbo-SPI&quot; class=&quot;headerlink&quot; title=&quot;Dubbo SPI&quot;&gt;&lt;/a&gt;Dubbo SPI&lt;/h1&gt;&lt;h2 id=&quot;一、什么是SPI机制？&quot;&gt;&lt;a href=&quot;#一、什么是SPI机制？&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://example.com/2023/06/10/design-pattern-builder/"/>
    <id>http://example.com/2023/06/10/design-pattern-builder/</id>
    <published>2023-06-10T07:58:34.000Z</published>
    <updated>2023-06-10T08:33:07.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-建造者模式"><a href="#设计模式-建造者模式" class="headerlink" title="设计模式 - 建造者模式"></a>设计模式 - 建造者模式</h1><p>建造模式是对象的创建模式。建造模式可以将一个产品的<strong>内部表象（internal representation）与产品的生产过程</strong>分割开来，从而可以使一个建造过程<strong>生成具有不同的内部表象的产品对象</strong>。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>建造者模式，相当于是对工厂生产产品的一种<strong>装配</strong>，由于这种装配可能随时改变，所以需要抽取出来，<strong>实现产品局部与整体的解耦</strong>（当然话又说回来，单个孤立产品还需要建造者？那就是多此一举）。着重理解装配的含义，对应在程序中就是相当于调用顺序，以及调用参数问题。理解起来还阔以哈，比起那几个工厂模式用的稍微少一丢丢。</p><p><strong>一般建造者模式都有以下几种固定的角色：</strong></p><p><strong>抽象建造者（Builder）角色</strong>：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，<strong>有多少零件，就有多少相应的建造方法。</strong></p><p><strong>具体建造者（ConcreteBuilder）角色</strong>：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。</p><p><strong>导演者（Director）角色</strong>：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</p><p><strong>产品（Product）角色</strong>：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</p><h2 id="二、用途"><a href="#二、用途" class="headerlink" title="二、用途"></a>二、用途</h2><p>1、需要生成的产品对象有<strong>复杂的内部结构</strong>，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。</p><p>2、需要生成的产品<strong>对象的属性相互依赖。</strong>建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。</p><p>3、在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。（<strong>满足跨平台修改扩展方便</strong>）</p><p>在框架中（Spring、Mybatis）的应用有：</p><ol><li>BeanDefinitionBuilder</li><li>RestTemplateBuilder</li><li>SpringApplicationBuilder</li><li>Mybatis中的XMLConfigBuilder</li><li>JPA中的CriteriaBuilder</li></ol><p>还有很多，比如HttpClient、Guava、Lombok等等，这里就不再一一列举了。</p><h2 id="三、场景"><a href="#三、场景" class="headerlink" title="三、场景"></a>三、场景</h2><p>假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅电子杂志，也可以通过网页结束订阅。当客户开始订阅时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。</p><p>这个系统含有<strong>客户端（Client）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder）、产品（WelcomeMessage和GoodbyeMessage）</strong>等角色。</p><p>抽象类AutoMessage源代码，send()操作仅仅是示意性的，并没有给出任何发送电子邮件的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AutoMessage</span> &#123;</span><br><span class="line">    <span class="comment">//收件人地址</span></span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="comment">//发件人地址</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="comment">//内容</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="comment">//发送日期</span></span><br><span class="line">    <span class="keyword">private</span> Date sendDate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收件人地址：&quot;</span> + to);</span><br><span class="line">        System.out.println(<span class="string">&quot;发件人地址：&quot;</span> + from);</span><br><span class="line">        System.out.println(<span class="string">&quot;标题：&quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + body);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送日期：&quot;</span> + sendDate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTo</span><span class="params">(String to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrom</span><span class="params">(String from)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSubject</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getSendDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sendDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSendDate</span><span class="params">(Date sendDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sendDate = sendDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类WelcomeMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeMessage</span> <span class="keyword">extends</span> <span class="title class_">AutoMessage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WelcomeMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送欢迎信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类GoodbyeMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodbyeMessage</span> <span class="keyword">extends</span> <span class="title class_">AutoMessage</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodbyeMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送欢送信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> AutoMessage msg;</span><br><span class="line">    <span class="comment">//标题零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//内容零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//收件人零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTo</span><span class="params">(String to)</span>&#123;</span><br><span class="line">        msg.setTo(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发件人零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrom</span><span class="params">(String from)</span>&#123;</span><br><span class="line">        msg.setFrom(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送时间零件的建造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSendDate</span><span class="params">()</span>&#123;</span><br><span class="line">        msg.setSendDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件产品完成后，用此方法发送邮件</span></span><br><span class="line"><span class="comment">     * 此方法相当于产品返还方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        msg.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者WelcomeBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WelcomeBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = <span class="keyword">new</span> <span class="title class_">WelcomeMessage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setBody(<span class="string">&quot;欢迎内容&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setSubject(<span class="string">&quot;欢迎标题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者GoodbyeBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodbyeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodbyeBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        msg = <span class="keyword">new</span> <span class="title class_">GoodbyeMessage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setBody(<span class="string">&quot;欢送内容&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> 　　　　msg.setSubject(<span class="string">&quot;欢送标题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导演者Director，这个类提供一个construct()方法，此方法调用建造者的建造方法，包括buildTo()、buildFrom()、buildSubject()、buildBody()、buildSendDate()等，从而一部分一部分地建造出产品对象，既AutoMessage对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    Builder builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，负责调用各零件的建造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">(String toAddress , String fromAddress)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.builder.buildTo(toAddress);</span><br><span class="line">        <span class="built_in">this</span>.builder.buildFrom(fromAddress);</span><br><span class="line">        <span class="built_in">this</span>.builder.buildSubject();</span><br><span class="line">        <span class="built_in">this</span>.builder.buildBody();</span><br><span class="line">        <span class="built_in">this</span>.builder.buildSendDate();</span><br><span class="line">        <span class="built_in">this</span>.builder.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomeBuilder</span>();</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        director.construct(<span class="string">&quot;toAddress@126.com&quot;</span>, <span class="string">&quot;fromAddress@126.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建造模式分成两个很重要的部分：</strong></p><ol><li>一个部分是<strong>Builder接口</strong>，这里是定义了<strong>如何构建各个部件</strong>，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</li><li>另外一个部分是<strong>Director</strong>，Director是知道<strong>如何组合来构建产品</strong>，也就是说Director负责<strong>整体的构建算法</strong>，而且通常是分步骤地来执行。</li></ol><p>不管如何变化，建造模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法。认识这点是很重要的，因为在建造模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。</p><p>再直白点说，建造模式的重心在于<strong>分离构建算法和具体的构造实现</strong>，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p><p>但对于建造者模式，还有另外一种简洁的写法，这里我们进行简单的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&quot;</span> + sex +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.sex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>此篇文章转载自CSDN博主「鼠晓」的文章，加上自己的一点总结<br>原文链接：<a href="https://blog.csdn.net/Small_Mouse0/article/details/66474580">https://blog.csdn.net/Small_Mouse0/article/details/66474580</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-建造者模式&quot;&gt;&lt;a href=&quot;#设计模式-建造者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式 - 建造者模式&quot;&gt;&lt;/a&gt;设计模式 - 建造者模式&lt;/h1&gt;&lt;p&gt;建造模式是对象的创建模式。建造模式可以将一个产品的&lt;strong&gt;内</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="http://example.com/2023/06/07/springLoopDependency/"/>
    <id>http://example.com/2023/06/07/springLoopDependency/</id>
    <published>2023-06-07T03:44:26.000Z</published>
    <updated>2023-06-08T12:46:39.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><h3 id="1、为什么会出现循环依赖问题？"><a href="#1、为什么会出现循环依赖问题？" class="headerlink" title="1、为什么会出现循环依赖问题？"></a>1、为什么会出现循环依赖问题？</h3><p>​    在Spring中bean的生命周期大致为：</p><ol><li>从文件中得到UserService.class</li><li>推断使用的构造方法(有参或无参)</li><li>获得Class普通对象</li><li>依赖注入</li><li>初始化前(@PostConstruct)</li><li>初始化(afterPropertiesSet)</li><li>初始化后(AOP等操作)</li><li>若定义了AOP，生成代理对象(与原先的Class是两个不同的对象)</li><li>将对象或代理对象放入单例池</li></ol><p>​    依赖注入问题主要发生在依赖注入缓解，场景如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当AService依赖注入时，需要获取BService，由于BService尚未初始化，在单例池中找不到，需要创建，而BService中由依赖于AService，而此时AService正在创建，导致循环依赖。</p><h3 id="2、Spring是怎么解决循环依赖问题的？"><a href="#2、Spring是怎么解决循环依赖问题的？" class="headerlink" title="2、Spring是怎么解决循环依赖问题的？"></a>2、Spring是怎么解决循环依赖问题的？</h3><p>​    spring中通过三级缓存来解决循环依赖问题。</p><p>​    三级缓存就是三个Map，分别为：</p><ul><li><p>一级缓存：private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</p></li><li><p>二级缓存：private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16);</p><p>在出现循环依赖的情况下，保存进行提前AOP得到的代理对象</p></li><li><p>三级缓存：private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</p></li></ul><p>​        打破循环，存储&lt;beanName, ObjectFactory&gt;结构，ObjectFactory是一个lambda表达式，相当于一个回调函数</p><p>​    其流程大致如下：</p><p><img src="/2023/06/07/springLoopDependency/t1.png" alt="image-20230215172402999"></p><p>结论：三级缓存的作用是为了解决spring中Bean依赖注入时发生的循环依赖。如果不需要AOP，那么只需要二级缓存即可实现，如果有AOP，其实二级缓存也能够实现，但是会打破Bean的生命周期，不符合spring的原则，因为需要把AOP对象放入二级缓存中，那么就必须在所有需要AOP处理的Bean对象初始化之前就对Bean对象进行后置处理（生成AOP对象），即使没有发生循环依赖！这并不是spring想看到的，所以spring引入了三级缓存，而且存入的是&lt;beanName, ObjectFactory&gt;结构，ObjectFactory是一个lambda表达式，相当于一个回调函数，当发生循环依赖的时候，会进行lambda表达式的执行，获取到Bean对象或者 AOP代理对象，再将Bean对象或者 AOP代理对象存入二级缓存中，如果之后还有循环依赖指向该对象(类似 A 依赖 B , B 依赖 A和C ， C 依赖 A这种情况)，就直接从二级缓存里面获取，从而解决了循环依赖。（这里解释了为什么不直接在二级缓存里存放lambda表达式，因为同一个lambda表达式每执行一次，就会生成一个新的代理对象，不能保证单例）</p><h3 id="3、提前AOP代理对象的属性填充、初始化"><a href="#3、提前AOP代理对象的属性填充、初始化" class="headerlink" title="3、提前AOP代理对象的属性填充、初始化"></a>3、提前AOP代理对象的属性填充、初始化</h3><p>​    在Spring AOP提前代理后获得的代理对象没有经过属性填充和初始化。那么这个代理又是如何保证依赖属性的注入的呢？答案回到Spring AOP最早最早讲的JDK动态代理上找，JDK动态代理时，会将目标对象target保存在最后生成的代理$proxy中，当调用$proxy方法时会回调h.invoke，而h.invoke又会回调目标对象target的原始方法。</p><p>​        因此，其实在动态代理时，原始bean已经被保存在提前曝光代理中了。而后原始Bean继续完成属性填充和初始化操作。因为AOP代理$proxy中保存着traget也就是是原始bean的引用，因此后续原始bean的完善，也就相当于Spring AOP中的target的完善，这样就保证了Spring AOP的属性填充与初始化了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖&quot;&gt;&lt;a href=&quot;#Spring循环依赖&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖&quot;&gt;&lt;/a&gt;Spring循环依赖&lt;/h1&gt;&lt;h3 id=&quot;1、为什么会出现循环依赖问题？&quot;&gt;&lt;a href=&quot;#1、为什么会</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Feign远程调用原理</title>
    <link href="http://example.com/2023/06/07/principleOfFeign/"/>
    <id>http://example.com/2023/06/07/principleOfFeign/</id>
    <published>2023-06-07T03:38:40.000Z</published>
    <updated>2023-06-08T12:44:26.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign远程调用原理"><a href="#Feign远程调用原理" class="headerlink" title="Feign远程调用原理"></a>Feign远程调用原理</h1><h4 id="1、Feign远程调用流程图"><a href="#1、Feign远程调用流程图" class="headerlink" title="1、Feign远程调用流程图"></a>1、Feign远程调用流程图</h4><p><img src="/2023/06/07/principleOfFeign/t1.webp" alt="t1"></p><h4 id="2、基于面向接口的动态代理方式生成实现类"><a href="#2、基于面向接口的动态代理方式生成实现类" class="headerlink" title="2、基于面向接口的动态代理方式生成实现类"></a>2、基于面向接口的动态代理方式生成实现类</h4><p>​    在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息</p><p>​    在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，基本原理如下所示：</p><p><img src="/2023/06/07/principleOfFeign/t2.webp" alt="t1"></p><h4 id="3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现："><a href="#3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现：" class="headerlink" title="3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现："></a>3、根据Contract协议规则，解析接口类的注解信息，解析成内部表现：</h4><p><img src="/2023/06/07/principleOfFeign/t3.webp" alt="t1"></p><h4 id="4、基于-RequestBean，动态生成Request"><a href="#4、基于-RequestBean，动态生成Request" class="headerlink" title="4、基于 RequestBean，动态生成Request"></a>4、基于 RequestBean，动态生成Request</h4><p>​    根据传入的Bean对象和注解信息，从中提取出相应的值，来构造Http Request 对象</p><h4 id="5、使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）"><a href="#5、使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）" class="headerlink" title="5、使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）"></a>5、使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）</h4><p>​    Feign 最终会将请求转换成http消息发送出去，传入的请求对象最终会解析成消息体，如下所示：</p><p><img src="/2023/06/07/principleOfFeign/t4.webp" alt="t1"></p><h4 id="6、拦截器负责对请求和返回进行装饰处理"><a href="#6、拦截器负责对请求和返回进行装饰处理" class="headerlink" title="6、拦截器负责对请求和返回进行装饰处理"></a>6、拦截器负责对请求和返回进行装饰处理</h4><p>​    在请求转换的过程中，Feign 抽象出来了拦截器接口，用于用户自定义对请求的操作，比如，如果希望Http消息传递过程中被压缩，可以定义一个请求拦截器。</p><h4 id="7、基于重试器发送HTTP请求"><a href="#7、基于重试器发送HTTP请求" class="headerlink" title="7、基于重试器发送HTTP请求"></a>7、基于重试器发送HTTP请求</h4><p>​    Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求</p><h4 id="8、发送Http请求"><a href="#8、发送Http请求" class="headerlink" title="8、发送Http请求"></a>8、发送Http请求</h4><p>​    Feign 真正发送HTTP请求是委托给 feign.Client 来做的。</p><p>​    Feign 默认底层通过JDK 的 java.net.HttpURLConnection 实现了feign.Client接口类,<strong>在每次发送请求的时候，都会创建新的HttpURLConnection 链接</strong>，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端。</p><p>Feign 整体框架非常小巧，在处理请求转换和消息解析的过程中，基本上没什么时间消耗。真正影响性能的，是处理Http请求的环节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Feign远程调用原理&quot;&gt;&lt;a href=&quot;#Feign远程调用原理&quot; class=&quot;headerlink&quot; title=&quot;Feign远程调用原理&quot;&gt;&lt;/a&gt;Feign远程调用原理&lt;/h1&gt;&lt;h4 id=&quot;1、Feign远程调用流程图&quot;&gt;&lt;a href=&quot;#1、F</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论@Configuration的实现原理</title>
    <link href="http://example.com/2023/06/07/principleOf-Configuration/"/>
    <id>http://example.com/2023/06/07/principleOf-Configuration/</id>
    <published>2023-06-07T03:35:54.000Z</published>
    <updated>2023-06-08T12:47:14.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration的实现原理"><a href="#Configuration的实现原理" class="headerlink" title="@Configuration的实现原理"></a>@Configuration的实现原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component(&quot;com.example.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource());</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，配置了JdbcTemplate的配置项，但没有@Configuration，也会出现一个事务失效问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">    jdbcTemplate.queryForList(<span class="string">&quot;update emp set name=&#x27;小明&#x27; where emp_id=2&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdbcTemplate.queryForList执行完直接提交，后续抛出异常也无法回滚数据。</p><p>​    再重温一遍事务的启动机制：</p><ol><li>事务管理器新建一个数据库连接conn，不用jdbcTemplate建连接，因为其默认autocommit=true，执行完会直接提交</li><li>设置conn.autocommit = false;</li><li>jdbc通过ThreadLocal&lt;Map&lt;DataSource, conn&gt;&gt;获取conn执行sql语句</li><li>如果一切正常，conn.commit()，否则conn.rollback()</li></ol><p>​    事务启动时事务管理器(PlatformTransactionManager)会新建一个数据库连接，将其存入ThreadLocal&lt;Map&lt;DataSource, conn&gt;&gt;中，然后取消事务自动提交，当jdbc需要时直接从ThreadLocal中获取。</p><p>​    此时的问题主要是，因为没有配置@Configuration，当代理对象执行到b()方法，然后执行jdbc数据库方法，此时jdbc获取conn的原理实际上是new JdbcTemplate(dataSource())，而事务管理器中transactionManager.setDataSource(dataSource())，相当于是两个不同的dataSource对象，而jdbc的dataSource对象默认autocommit=true，当执行完sql语句，直接提交，导致后续无法回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public JdbcTemplate jdbcTemplate()&#123;</span><br><span class="line">    return new JdbcTemplate(dataSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public PlatformTransactionManager transactionManager()&#123;</span><br><span class="line">    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br><span class="line">    transactionManager.setDataSource(dataSource());</span><br><span class="line">    return transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    那么为什么标注了@Configuration之后，就能解决这个问题呢？其原理到底是什么？</p><p>​    @Configuration的原理也是基于动态代理的（AOP、@Lazy都是基于动态代理），底层原理大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class JdcbConfigProxy <span class="keyword">extends</span> <span class="title class_">JdbcConfig</span>&#123;</span><br><span class="line">JdbcConfig target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        .</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.jdbcTemplate();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//代理逻辑：先去ioc容器中找dataSource，若有直接return</span></span><br><span class="line">        <span class="keyword">if</span>(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ioc.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="built_in">super</span>.dataSource();</span><br><span class="line">        ioc.putBean(dataSource);</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于动态代理，不论是jdbc还是transactionManager，其获取dataSource最终都要先去ioc容器中找，若找到</p><p>就直接返回，找不到在调用dataSource()方法创建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Configuration的实现原理&quot;&gt;&lt;a href=&quot;#Configuration的实现原理&quot; class=&quot;headerlink&quot; title=&quot;@Configuration的实现原理&quot;&gt;&lt;/a&gt;@Configuration的实现原理&lt;/h1&gt;&lt;figure</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP与RPC区别比较分析</title>
    <link href="http://example.com/2023/06/07/httpAndRpc/"/>
    <id>http://example.com/2023/06/07/httpAndRpc/</id>
    <published>2023-06-07T03:09:45.000Z</published>
    <updated>2023-06-08T12:48:09.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP与RPC区别比较分析"><a href="#HTTP与RPC区别比较分析" class="headerlink" title="HTTP与RPC区别比较分析"></a>HTTP与RPC区别比较分析</h1><h2 id="一、TCP的特点与问题"><a href="#一、TCP的特点与问题" class="headerlink" title="一、TCP的特点与问题"></a>一、TCP的特点与问题</h2><p>一想到TCP，我想大多数人第一时间想到的应该是：面向连接的、可靠的、基于字节流的。</p><p>如果我们需要使用TCP协议的话，就需要使用<strong>Socket编程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个Socket对象请求服务端的连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、从Socket对象中获取字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3、把字节输出流包装成打印流</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        ps.println(<span class="string">&quot;hello server!&quot;</span>);</span><br><span class="line">        <span class="comment">//4、刷新</span></span><br><span class="line">        ps.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1、定义一个ServerSocket对象进行服务端的端口注册</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、阻塞监听客户端的socket连接请求，当监听到一个连接请求后，执行后续代码</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3、从socket管道中得到一个字节输入流对象inputStream</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4、把字节输入流包装成 缓冲字符输入流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="comment">//5、按照通信的架构，对方怎么发，这里就要怎么收，服务端按行读取</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于bio是同步阻塞式，若接收不到客户端的一行数据，会一直阻塞</span></span><br><span class="line"><span class="comment">         * 读到一行数据后，继续循环阻塞等待</span></span><br><span class="line"><span class="comment">         * 客户端发完数据后宕机，socket关闭，此时服务端的socket也会跟着关闭，</span></span><br><span class="line"><span class="comment">         * 报Connection reset错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端接收到：&quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们简单演示了一下在Java中是如何基于BIO进行网络编程的，对于使用纯裸TCP存在的问题，我们关注点放在<strong>基于字节流上</strong>。</p><p>什么叫基于字节流？</p><p>就是当通信双方建立连接后，我们可以形象一点的看作，通信双方之间建立了一个“通信的管道”，想要通信的数据一个一个比特位在通信管道内传输。</p><blockquote><p>如果还不明白的话，我们可以打一个比方：<br>数据就像<strong>河流中的水</strong>一样；通信管道就是<strong>河道</strong>；河流中的水是由小的河流分支汇集而来（<strong>小分支</strong>就是一个一个用户发送数据）；最终河流汇入<strong>大海</strong>（大海就是数据接收方）。<br>大海收到河流中的水，但是收到的水并不是一批一批收到，而是不断的收到，这样大海无法确定对方在发送的时候一次发送了多少。所以在接收的时候，就可能一次收的比对方一次发的多，或者少。这就是大名鼎鼎的粘包问题</p></blockquote><p>总之，使用TCP就会有粘包问题，为了解决这个问题，我们就需要在TCP的上层（应用层）再设计一些自定义协议，解决粘包问题，最常见的就是HTTP，HTTP中的某一些字段就可以标识哪些属于同一个报文，这样就可以避免粘包问题。</p><h2 id="二、HTTP与RPC"><a href="#二、HTTP与RPC" class="headerlink" title="二、HTTP与RPC"></a>二、HTTP与RPC</h2><p>TCP是传输层的协议，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的应用层协议而已。</p><h3 id="1、HTTP协议"><a href="#1、HTTP协议" class="headerlink" title="1、HTTP协议"></a>1、HTTP协议</h3><p>HTTP协议【超文本传输协议】，平常我们用浏览器使用的就是HTTP一系列的协议，网上有很多详细的介绍，这里就不去展开了，以下是CSDN社区中的一位博主对HTTP的总结：</p><p><a href="https://blog.csdn.net/cdzg_zzk/article/details/127376175?spm=1001.2014.3001.5501">HTTP复习（一）</a><br><a href="https://blog.csdn.net/cdzg_zzk/article/details/127502145?spm=1001.2014.3001.5501">HTTP复习（二）</a></p><h3 id="2、RPC协议"><a href="#2、RPC协议" class="headerlink" title="2、RPC协议"></a>2、RPC协议</h3><p>而RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。</p><p>调用方法其实跟我们平常在代码中调用自定义方法（或者叫函数）差不多。只不过这个方法是远端服务器暴露出来的接口，我们通过这个接口去使用，就好像我们在调用本地函数一样，就屏蔽了底层网络细节，就方便了很多。需要完成一个任务就调用一个接口。简直不要太爽（回想一些基于TCP的socket通信）</p><p>虽然大部分RPC底层使用的是TCP，但是这也不被完全限制。RPC底层可以使用UDP/TCP，甚至是HTTP。</p><h3 id="3、有了HTTP，为什么还需要RPC？"><a href="#3、有了HTTP，为什么还需要RPC？" class="headerlink" title="3、有了HTTP，为什么还需要RPC？"></a>3、有了HTTP，为什么还需要RPC？</h3><p>其实RPC出现早于HTTP。TCP是上世纪70年代出现，HTTP是90年代才流行。但是TCP的粘包问题确实一直存在，这期间就要用各种各样的自定义应用层协议来解决粘包问题。</p><p>一些app，只需要客户端与自家的服务器进行消息传递【C/S架构】，这个时候各家使用各家的RPC协议就可以。</p><p>但是随着【B/S架构】发展，浏览器要访问各种服务器，这个使用每家的服务器都必须遵守统一的规则，所以HTTP应用越加广泛。</p><p>现在【B/S】【C/S】架构分割越来越不明显了，RPC一般只用于公司内部使用了。</p><h2 id="三、HTTP与RPC的区别"><a href="#三、HTTP与RPC的区别" class="headerlink" title="三、HTTP与RPC的区别"></a>三、HTTP与RPC的区别</h2><h3 id="1、服务发现"><a href="#1、服务发现" class="headerlink" title="1、服务发现"></a>1、服务发现</h3><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。</p><p>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，<strong>默认80端口</strong>。</p><p>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd</strong>，<strong>甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如CoreDNS。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h3 id="2、底层连接形式"><a href="#2、底层连接形式" class="headerlink" title="2、底层连接形式"></a>2、底层连接形式</h3><p>以主流的HTTP1.1协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。</p><p>而RPC协议，也跟HTTP类似，也是通过建立<strong>TCP长链接</strong>进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常高效。</p><p><img src="./httpAndRpc/t1.png" alt="t1"></p><h3 id="3、传输的内容"><a href="#3、传输的内容" class="headerlink" title="3、传输的内容"></a>3、传输的内容</h3><p>基于TCP传输的消息，说到底，无非都是<strong>消息头header</strong>和<strong>消息体body</strong>。</p><p>header：存储的是一些标志信息。可以传字符串也可以传二进制</p><p>body：实际传输的内容。一般采用JSON进行序列化</p><p><img src="./httpAndRpc/t2.png" alt="t1"></p><p>对于主流的HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但HTTP设计初是用于做网页文本展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用json来序列化结构体数据。</p><blockquote><p>对于HTTP/1.1来说，会有头部字段冗余，传输字符串而不是二进制，队头阻塞等等问题。但是HTTP/2进行了很好的改进。所以HTTP/2的性能不一定就比RPC差了。<br>甚至gRPC底层都是使用的HTTP/2</p></blockquote><p>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</p><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>本篇文章转载自CSDN社区博主 <strong>xiao zhou</strong>，原文总结自小林coding</p><p>原文连接：<a href="https://blog.csdn.net/cdzg_zzk/article/details/127564797">https://blog.csdn.net/cdzg_zzk/article/details/127564797</a></p><p>更多细节可以转至原文，也可以浏览小林coding</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP与RPC区别比较分析&quot;&gt;&lt;a href=&quot;#HTTP与RPC区别比较分析&quot; class=&quot;headerlink&quot; title=&quot;HTTP与RPC区别比较分析&quot;&gt;&lt;/a&gt;HTTP与RPC区别比较分析&lt;/h1&gt;&lt;h2 id=&quot;一、TCP的特点与问题&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Raft共识算法</title>
    <link href="http://example.com/2023/06/05/raft/"/>
    <id>http://example.com/2023/06/05/raft/</id>
    <published>2023-06-05T13:38:43.000Z</published>
    <updated>2023-06-09T03:29:06.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft共识算法"><a href="#Raft共识算法" class="headerlink" title="Raft共识算法"></a>Raft共识算法</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Raft是分布式系统中最经典且最为易理解的共识算法，共识指分布的多个参与者就值”value”达成一致。一旦参与者对某个值做出决定，这个决定将是最终的。当大多数参与者存活时，共识算法会在存活的参与者间达成值一致，这相当于全部参与者存活时达成的一致。故部分参与者达成的一致是整个系统有效的，这一特性使得分布式系统具备一定的容错能力。</p><p>更多细节可以阅读Raft官网文档：<a href="https://raft.github.io/">https://raft.github.io/</a></p><p>在讲解Raft算法的选举和故障转移过程之前，我们先引入Raft算法中的一些基本概念：</p><ol><li><p><strong>Follower</strong></p><p>Follower是请求的被动更新者，主要职责是从Leader接收更新请求，再将日志写入本地文件中。</p></li><li><p><strong>Candidate</strong></p><p>Leader选举中的候选者。如果Follower在一定的时间内，没有收到Leader的心跳，则判断Leader可能已经发生故障，此时启动Leader Election过程，本节点切换为Candidate参与Leader的竞选，直到选举结束。</p></li><li><p><strong>Leader</strong></p><p>所有请求的处理者，接收客户端发起的操作请求，写入本地日志后，同步至其他Follower节点。</p></li><li><p><strong>Term</strong></p><p>Raft把时间分为连续的任期(Term)，每个任期可以是任意时长，任期用连续的整数进行标号。每个任期首先进行Leader选举，选举时，多个Candidate竞争成为Leader，一旦某个节点成为Leader，其他节点则变回Follower，成为Leader的节点将在该任期内一直担任Leader，如果该Leader节点发生故障，其他节点会在新的任期内进行选举。任何一个任期内都不会有多个Leader。Raft系统中，任期是一个及其重要的概念，每个节点都维护着当前任期的值，每次节点间的通信都包含任期信息，每个节点在检测到自己的任期值低于其他节点时，都会更新自己的任期值，设置为检测到的较高的值。<strong>当Leader和Candidate发现自己的任期低于别的节点，则立即把自己转换为Follower。</strong></p><p>注意：任期与计时器是绑定到一起的。任何新任期的启动，必然伴随一个新计时器的启动。</p></li><li><p><strong>Raft RPC</strong></p><p>Raft核心部分只需要用到2个RPC：<strong>RequestVote</strong>和<strong>AppendEntries</strong>。每个Raft节点将会根据自己节点的状态数据来对这两种RPC请求进行处理。</p><p>RequestVote RPC是由Candidate发送给其他节点，请求其他节点为自己投票，如果一个Candidate获得了多数节点的投票，则该Candidate转变为Leader。</p><p>AppendEntries RPC是由Leader节点发送给其他节点，有两个作用，当其entries域为空时，该RPC作为Leader的心跳；当entries域不为空时，请求其他节点将entries域中的日志添加到自己的日志中。</p></li></ol><h2 id="二、Leader选举和Failover过程"><a href="#二、Leader选举和Failover过程" class="headerlink" title="二、Leader选举和Failover过程"></a>二、Leader选举和Failover过程</h2><h3 id="1、Leader的选举过程"><a href="#1、Leader的选举过程" class="headerlink" title="1、Leader的选举过程"></a>1、Leader的选举过程</h3><p>Raft采用心跳机制来触发Leader的选举。当系统启动时，所有的节点转化为Follower状态，设置任期（term）为0，并启动计时器（election timeout，即选举的超时时间），在超时时间内如果没有收到Leader节点的心跳，就会发起新一轮的选举，此时节点会从Follower转换为Candidate，而一旦转变为Candidate节点，就会做以下几件事情：</p><ol><li>增加自己的term任期数</li><li>启动一个新的election timeout计时器</li><li>给自己投一票</li><li>向集群中的每一个节点发送RequestVote RPC请求，并等待其他节点回复</li></ol><p>如果在新的计时器超时前收到多数节点（集群节点个数的一半）的同意投票，则转换为Leader。如果接收到的是其他节点的AppendEntries心跳RPC，说明其他节点早先与自己被选为Leader，则转换为Follower，同时将自己的任期更新为检测到的最高值。如果计时器超时的时候还没有接收到以上两种信息中的任何一种，则重复1-4步骤，进行新的选举。</p><p>节点在接受到多数节点的投票成为Leader后，会立即向所有节点发送AppendEntries 心跳RPC。所有Candidate收到心跳RPC后，转换为Follower，选举结束。</p><p>每个Follower在一个任期内只能投一票，采取先到先得的策略。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC，那说明Leader可能宕机或者是其他原因，则转换为Candidate，开始请求投票。</p><p>如果多个节点同时发起投票，每个节点都没有拿到多数票（这种情况成为Split Vote），则增加任期数，在新的任期内重新进行投票。有没有可能Split Vote反复发生，永远都选不出Leader呢？不会的。因为Raft采取随机超时时间，Raft系统有一个选举超时配置项，Follower和Candidate的计时器超时时间每次重新计算，随机选取配置时间的1倍到2倍之间。即使所有节点同时启动，由于随机超时时间的设置，各个节点一般不会同时转为Candidate，先转为Candidate的节点会先发起投票，从而获得多数票。因而在每个任期内，多个节点同时请求投票并且都只获得少数票的几率很小，连续多次发生这种情况几率更小，实际上可以认为完全不可能发生。一般情况下，基本上都在1-2个任期内选出Leader。</p><p>这里我们再细讲一下Leader的投票规则：</p><p>投票是一个<strong>first-come-first-serve</strong>的机制，即<strong>谁先找我我就给谁投票</strong>。我们想确保<strong>新的Leader在赢得选举的时候有所有已经提交（commit）的entry</strong>，因为这样就不需要向新Leader同步它不知道的已经同步信息。这就意味着<strong>所有entry只会向一个方向传递：从Leader到Follower</strong>。并且Leader也不会重写log里面已经存在的entry。<br>因此，当Candidate的log包含了所有已经提交的entry时，它才能赢得选举。为实现这点，Candidate需要获得集群中的大多数（超过集群server个数的一半）server的确认，当Candidate的log至少是“最新的”（up-to-date）时，则说明它的log中有所有的已经提交的entry。<br>因此，当投票者发现自己的log比Candidate的都新时，就会拒绝给该Candidate投票。<br>“最新的”（up-to-date） 定义：当Candidate发起RequestVote的RPC时，会包括上个log entry的index和term信息。投票者比较自己和Candidate的index和term，当term不同时，term越高则为越新；当term相同时，index越高则为越新。（lastTerm_v &gt; lastTerm_c) || (lastTerm_v &gt; lastTerm_c) &amp;&amp; (lastIndex_v &gt; lastIndex_c)</p><h3 id="2、Leader的Failover故障转移"><a href="#2、Leader的Failover故障转移" class="headerlink" title="2、Leader的Failover故障转移"></a>2、Leader的Failover故障转移</h3><p>Leader出现故障时，需要通过集群选举产生一个新的Leader。那怎么知道Leader是否出现了故障呢？这个我们其实在上面讲过了，Raft核心部分只需要用到2个RPC：<strong>RequestVote</strong>和<strong>AppendEntries</strong>。每个Raft节点将会根据自己节点的状态数据来对这两种RPC请求进行处理。当Candidate选举成Leader后，他会通过发送AppendEntries RPC请求，向其他节点推送持续的心跳。</p><p>如果Fellower节点在一定时间内未收到Leader发送的心跳信息（定期心跳信息包括不带日志的AppendEntriesRPC)，则认为Leader出现故障。所以和Leader存活有关的心跳时长，即Leader租约的长短时影响系统处理故障时长的一个因素。心跳时间不能太长(长了则不能今早的发现故障)，也不能太短（太短会频发触发选Leader的操作）从而影响效率。</p><h2 id="三、Raft算法的日志复制"><a href="#三、Raft算法的日志复制" class="headerlink" title="三、Raft算法的日志复制"></a>三、Raft算法的日志复制</h2><h4 id="1、日志复制的过程"><a href="#1、日志复制的过程" class="headerlink" title="1、日志复制的过程"></a>1、日志复制的过程</h4><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行地向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p><p>客户端的每一个请求都包含被复制状态机执行的指令。Leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让它们复制这条信息。假如这条日志被安全的复制，Leader就应用这条日志到自己的状态机中，并返回给客户端。如果Follower宕机或者运行缓慢或者丢包，Leader会不断的重试，直到所有的Follower最终都复制了所有的日志条目。</p><p><img src="/2023/06/05/raft/t1.jpg" alt="t1"></p><h4 id="2、日志的组成"><a href="#2、日志的组成" class="headerlink" title="2、日志的组成"></a>2、日志的组成</h4><p>日志由有序编号（log index）的日志条目所组成。每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了,如下图所示，共有 8 条日志，提交了 7 条。提交的日志都将通过状态机持久化到磁盘中，防止宕机。<br><img src="/2023/06/05/raft/t2.png" alt="t2"></p><h4 id="3、日志复制的详细介绍"><a href="#3、日志复制的详细介绍" class="headerlink" title="3、日志复制的详细介绍"></a>3、日志复制的详细介绍</h4><p>当Leader接收到由客户端发送的请求(请求中包含可以被复制状态机执行的命令)时，Leader将会把该请求作为新的内容添加到日志中(任期号为当前Leader所处的任期号，索引号为当前Leader本地存储的日志集合中的日志的最高索引号加1)。然后将该日志通过AppendEntries RPC消息发送到网络中其他的服务器(以下简称Follower)，从而复制该日志。在网络中Follower接收到该日志消息后则会返回复制成功的回复。</p><p>在Leader接收到网络中大部分的Follower的成功复制的回复之后，Leader便认为该日志可以被提交。此时Leader将会同时做三件事：</p><ol><li>将该日志应用到Leader本地的复制状态机</li><li>向所有Follower发送消息通知所有接收到该日志的Follower将该日志进行提交，然后应用到各自本地的复制状态机</li><li>将执行结果通知客户端</li></ol><p>当该日志消息成功在网络中大部分Follower本地的复制状态机执行过后，则可认为该日志已被提交。<strong>在当前日志被提交的过程中</strong>，<strong>如果Leader先前的某些日志还没有被提交，则将会一同提交</strong>。而网络中有些Follower可能由于网络状态原因反应缓慢或者崩溃，那么Leader将会无限次地尝试重复发送AppendEntries RPC消息到该Follower。直到成功为止。</p><h4 id="4、Leader切换导致的日志不一致性"><a href="#4、Leader切换导致的日志不一致性" class="headerlink" title="4、Leader切换导致的日志不一致性"></a>4、Leader切换导致的日志不一致性</h4><p><img src="/2023/06/05/raft/t3.png" alt="t2"></p><h4 id="5、日志的一致性检查"><a href="#5、日志的一致性检查" class="headerlink" title="5、日志的一致性检查"></a>5、日志的一致性检查</h4><p>如上所述，Follower在接收到AppendEntries RPC消息后则会返回复制成功的回复。实际上在接收到消息后会首先进行日志的一致性检查(正常情况下Leader与Follower的日志会保持一致，所以一致性检查不会失败)，一致性检查内容如下：</p><p>在Leader创建AppendEntries RPC消息时，消息中将会包含当前日志之前日志条目的任期号与索引号。Follower在接受到AppendEntries RPC消息后，将会检查之前日志的任期号与索引号是否匹配到。如果匹配则说明和Leader之前的日志是保持一致的，否则，如果没有匹配则会拒绝AppendEntries RPC消息。</p><p>一致性检查是一个归纳的过程。正常情况下，网络中第一条日志一定满足日志的一致性检查，然后第二条日志中包含第一条日志的任期号与索引号，所以只要Leader与Follower的第一条日志保持一致，那么第二条日志也会满足一致性检查，从而之后的每一条日志都会满足一致性检查。</p><p>从而得出了日志匹配属性:</p><ol><li>如果两个不同的日志实体具有相同的索引和任期号，那么它们存储有相同的命令。</li><li>如果两个不同的日志实体具有相同的索引和任期号，则所有先前条目中的日志都相同。(由一致性检查结果得出)</li></ol><h4 id="6、Raft日志不一致的解决方案"><a href="#6、Raft日志不一致的解决方案" class="headerlink" title="6、Raft日志不一致的解决方案"></a>6、Raft日志不一致的解决方案</h4><p>日志不一致的三种情况，网络不可能一直处于正常情况，因为Leader或者某个Follower有可能会崩溃，从而导致日志不能一直保持一致，因此存在以下三种情况：</p><ol><li>Follower缺失当前Leader上存在的日志条目。</li><li>Follower存在当前Leader不存在的日志条目。</li><li>Follower即缺失当前Leader上存在的日志条目，也存在当前Leader不存在的日志条目。</li></ol><p>比如，旧的Leader仅仅将AppendEntries RPC消息发送到一部分Follower就崩溃掉，然后新当选Leader的服务器恰好是没有收到该AppendEntries RPC消息的服务器)</p><p><img src="/2023/06/05/raft/t4.png" alt="t2"></p><p>备注：</p><ol><li>图中最上方是日志的索引号(1-12)，每个方块代表一条日志信息，方块内数字代表该日志所处的任期号。</li><li>图中当前Leader(图中最上方一行日志代表当前Leader日志)处于任期号为8的时刻。</li></ol><p>分析说明：<br>下面，以此图分析说明以上三种情况存在的原因：</p><ol><li>Follower a、Follower b满足以上说明的第一种情况：Follower崩溃没有接收到Leader发送的AppendEntries RPC消息。</li><li>Follower c在任期为6的时刻，Follower d在任期为7的时刻为Leader，但没有完全完成日志的发送便崩溃了，满足以上说明的第二种情况：Follower存在当前Leader不存在的日志条目。</li><li>Follower e在任期为4的时刻，Follower f在任期为2、3的时刻为Leader，但没有完全完成日志的发送便崩溃了，同时在其他服务器当选Leader时刻也没有接收到新的Leader发送的AppendEntries RPC消息，满足第三种情况：Follower即缺失当前Leader上存在的日志条目，也存在当前Leader不存在的日志条目。</li></ol><p><strong>如上文所示，根据日志的任期数目来判断节点是否为Leader，再次印证了任期的关键作用。</strong></p><p>Leader通过强迫Follower的日志重复自己的日志来处理不一致之处，这意味着Follower日志中的冲突日志将被Leader日志中的条目覆盖。这个过程如下：</p><ol><li>首先，Leader找到与Follower最开始日志发生冲突的位置，然后删除掉Follower上所有与Leader发生冲突的日志，最后将自己的日志发送给Follower以解决冲突。需要注意的是：Leader不会删除或覆盖自己本地的日志条目。</li><li>当发生日志冲突时，Follower将会拒绝由Leader发送的AppendEntries RPC消息，并返回一个响应消息告知Leader日志发生了冲突。</li><li>Leader为每一个Follower维护一个nextIndex值。该值用于确定需要发送给该Follower的下一条日志的位置索引。该值在当前服务器成功当选Leader后会重置为本地日志的最后一条索引号+1。</li><li>当Leader了解到日志发生冲突之后，便递减nextIndex值，并重新发送AppendEntries RPC到该Follower，不断重复这个过程，一直到Follower接受该消息。</li><li>一旦Follower接受了AppendEntries RPC消息，Leader则根据nextIndex值可以确定发生冲突的位置，从而强迫Follower的日志重复自己的日志以解决冲突问题。</li></ol><p><img src="/2023/06/05/raft/t5.png" alt="t2"></p><p>情况a：如上图，服务器S1在任期为2的时刻仅将日志index:2:2,term发送到了服务器S2便崩溃掉。</p><p>情况c：服务器S1在任期为4的时刻再次当选Leader(S1重启时，任期仍然为2，收到新的Leader S5发送的心跳信息后更新任期为3，而在Leader S5崩溃后，服务器S1为第一个计时器超时的，因此发起投票，任期更新为4，大于网络中其他服务器任期，成功当选Leader)，同时将日志index:2:2,term发送到了服务器S2和S3，但还没有通知服务器对日志进行提交便崩溃掉。</p><p>情况d：情况(a-&gt;d)如果在任期为2时服务器S1作为Leader崩溃掉，S5在任期为3的时刻当选Leader，由于日志index:2:2,term还没有被复制到大部分服务器上，并没有被提交，所以S5可以通过自己的日志index:2:3,term覆盖掉日志index:2:2,term。<br>情况e：情况(a-&gt;e)如果在任期为2时服务器S1作为Leader，并将index:2:2,term发送到S2和S3，成功复制到大多数成员服务器上。S1成功提交了该日志，那么即便S1崩溃掉，S5也无法成功当选Leader，因为S5不具备网络中最新的已被提交的日志条目，S5只有term为1的日志。</p><h2 id="四、Raft算法中成员变更过程解析"><a href="#四、Raft算法中成员变更过程解析" class="headerlink" title="四、Raft算法中成员变更过程解析"></a>四、Raft算法中成员变更过程解析</h2><h4 id="1、什么是成员变更？"><a href="#1、什么是成员变更？" class="headerlink" title="1、什么是成员变更？"></a>1、什么是成员变更？</h4><p>成员变更指的是系统成员变化，即服务器节点的上下线，这和由于宕机故障导致的上下线是不同的。宕机或者重启导致的上下线，是不会影响系统的注册的成员数量的，也就不会影响到一致性判断所依据的“多数派”的生成，众所周知，“多数派”是所有一致性的基础。成员变更时，会修改注册的成员数量，比如在实际应用中，为了提高安全等级，就很可能出现需要把备机数量由三台扩充到五台，在这种情况下，就发生了成员变更。</p><h4 id="2、直接变更存在的问题"><a href="#2、直接变更存在的问题" class="headerlink" title="2、直接变更存在的问题"></a>2、直接变更存在的问题</h4><p>在成员变更时，因为无法做到在同一个时刻使所有的节点从旧配置转换到新配置，那么直接从就配置向新配置切换就可能存在一个节点同时满足新旧配置的“超过半数”原则。</p><p>如下图，原集群由Server1、Server2、Server3，现在对集群做变更，增加Server4、Server5。如果采用直接从旧配置到新配置的切换，那么有一段时间存在两个不想交的“超过半数的集群”。</p><p><img src="/2023/06/05/raft/t6.png" alt="t2"></p><p>上图，中在中间位置Server1可以通过自身和Server2的选票成为Leader（满足旧配置下收到大多数选票的原则）；Server3可以通过自身和Server4、Server5的选票成为Leader（满足新配置线，即集群有5个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个Leader，这和协议是违背的。</p><h4 id="3、Raft的成员变更实现方案：分阶段变更"><a href="#3、Raft的成员变更实现方案：分阶段变更" class="headerlink" title="3、Raft的成员变更实现方案：分阶段变更"></a>3、Raft的成员变更实现方案：分阶段变更</h4><p>Raft提出了通过一个中间过渡阶段，即联合共识（joint consensus），逐步把数据写入的新的集群中。其具体做法是2阶段提交式的：</p><p>第一阶段：Leader收到C-old到C-new的配置变更请求时，创建C-old-new的日志并开始复制给其他节点，此日志和普通日志复制没有区别。此时做决策的仍然是C-old集群。</p><p>第二阶段：当只有C-old-new复制到大多数节点后，Leader以这个配置做决定，这个时候处于一个共同决定的过程，因为此时做决策的是C-old-new集群。</p><p>由于两阶段变更不存在一个阶段C-old和C-new可以同时根据自己的配置做出决定，所以不会出现上文描述的情况。</p><p><strong>原文链接：<a href="https://blog.csdn.net/qq_52668274/article/details/126898833?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_52668274/article/details/126898833?spm=1001.2014.3001.5506</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Raft共识算法&quot;&gt;&lt;a href=&quot;#Raft共识算法&quot; class=&quot;headerlink&quot; title=&quot;Raft共识算法&quot;&gt;&lt;/a&gt;Raft共识算法&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 4</title>
    <link href="http://example.com/2023/05/15/rpc-framework-4/"/>
    <id>http://example.com/2023/05/15/rpc-framework-4/</id>
    <published>2023-05-15T11:44:29.000Z</published>
    <updated>2023-05-16T01:01:49.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-网络传输模块"><a href="#简易RPC框架-网络传输模块" class="headerlink" title="简易RPC框架 - 网络传输模块"></a>简易RPC框架 - 网络传输模块</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>我们在前面的文章中说到了客户端通过代理对象进行远程调用，其中通过Channel与服务端进行网络通信，其实就是通过网络请求来传递类信息、方法信息以及方法参数等数据到服务端。其中网络传输的具体实现在本项目中我们使用的是基于NIO的网络编程框架Netty。</p><h3 id="2、网络传输"><a href="#2、网络传输" class="headerlink" title="2、网络传输"></a>2、网络传输</h3><h4 id="1）网络传输实体类"><a href="#1）网络传输实体类" class="headerlink" title="1）网络传输实体类"></a>1）网络传输实体类</h4><p>在此我们先定义了一些在网络传输中的数据格式：</p><p>RpcRequest请求类，当你要调用远程方法时，需要将你要调用的方法的详细信息传输到服务器端，然后服务端就能根据这些信息去获取方法对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRpcServiceName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getInterfaceName() + getGroup() + getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcResponse响应类，服务端执行完请求后，就可以将响应信息封装成响应类传输给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6672133783386466359L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">//response code</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">//response message</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//response body</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data, String requestId)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(RpcResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(RpcResponseCode.SUCCESS.getMessage());</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        <span class="keyword">if</span>(data != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setData(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RpcResponse&lt;T&gt; <span class="title function_">fail</span><span class="params">(RpcResponseCodeEnum rpcResponseCodeEnum)</span> &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RpcResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(rpcResponseCodeEnum.getCode());</span><br><span class="line">        response.setMessage(rpcResponseCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但真正在网络中传输不是仅仅是传输这个对象就行了，还有可能出现很多问题，比如在TCP传输过程中的黏包半包问题。</p><p>粘包和半包问题是数据传输中比较常见的问题，所谓的<strong>粘包问题是指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包。</strong>比如发送了两条消息，分别为“ABC”和“DEF”，那么正常情况下接收端也应该收到两条消息“ABC”和“DEF”，但接收端却收到的是“ABCD”，像这种情况就叫做粘包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/uuu.png" alt="uuu"></p><p>半包问题是指接收端只收到了部分数据，而非完整的数据的情况就叫做半包。比如发送了一条消息是“ABC”，而接收端却收到的是“AB”和“C”两条信息，这种情况就叫做半包，如下图所示：</p><p><img src="/2023/05/15/rpc-framework-4/yyy.png" alt="yyy"></p><p>为什么会出现黏包半包问题？粘包问题发生在 TCP/IP 协议中，<strong>因为 TCP 是面向连接的传输协议，它是以“流”的形式传输数据的，而“流”数据是没有明确的开始和结尾边界的，所以就会出现粘包问题</strong>。</p><h4 id="2）自定义传输协议"><a href="#2）自定义传输协议" class="headerlink" title="2）自定义传输协议"></a>2）自定义传输协议</h4><p>那要什么解决这个问题呢？我们采用自定义传输协议，并对数据进行相应的编码解码以解决这个问题。简单来说，我们通过设计传输协议，定义需要传输的数据以及其需要占多少字节的数据，当我们在收到传输数据后，就可以根据我们设计的传输协议去解析出正确的数据。</p><p>首先我们定义真正在网络中进行传输的对象，RpcMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessage</span> &#123;</span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> messageType;</span><br><span class="line">    <span class="comment">//序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> codec;</span><br><span class="line">    <span class="comment">//压缩类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> compress;</span><br><span class="line">    <span class="comment">//请求id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> requestId;</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessage中的data就是上面的RpcRequest和RpcResponse，接下来我们详细讲解一下自定义的协议</p><p><img src="/2023/05/15/rpc-framework-4/aaa.png" alt="aaa"></p><ol><li>magic code 魔数：判断是否是遵循同一协议的数据，用来校验数据包有效性，占4byte</li><li>version 版本信息：后续可以用于协议的版本迭代，占1byte</li><li>full length 消息长度：请求头+请求体的总长度，占4byte</li><li>messageType 消息类型：消息可分为请求和相应两类，占1byte</li><li>compress 压缩类型：数据的压缩类型，占1byte</li><li>codec 序列化类型：RpcRequest和RpcResponse的序列化类型，占1byte</li><li>requestId 请求Id：请求Id，用于后续的消息跟踪，占4byte</li><li>body 请求体：RpcRequest或RpcResponse序列化后的byte数据</li></ol><h4 id="3）编解码器"><a href="#3）编解码器" class="headerlink" title="3）编解码器"></a>3）编解码器</h4><p>RpcMessageEncoder，自定义编码器，负责处理“出站”消息，将消息转换为字节数组然后写入到 <strong>ByteBuf</strong> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line">    <span class="comment">// 原子类，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ATOMIC_INTEGER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage rpcMessage, ByteBuf out)</span> &#123;</span><br><span class="line">        <span class="comment">//将RpcMessage对象转换为字节流，写入到ByteBuf中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入魔数</span></span><br><span class="line">            out.writeBytes(RpcConstants.MAGIC_NUMBER);</span><br><span class="line">            <span class="comment">//写入版本号</span></span><br><span class="line">            out.writeByte(RpcConstants.VERSION);</span><br><span class="line">            <span class="comment">//写入消息长度，先占位，后面再写入</span></span><br><span class="line">            out.writerIndex(out.writerIndex() + <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//写入消息类型</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> rpcMessage.getMessageType();</span><br><span class="line">            out.writeByte(messageType);</span><br><span class="line">            <span class="comment">//写入序列化类型</span></span><br><span class="line">            out.writeByte(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//写入压缩类型</span></span><br><span class="line">            out.writeByte(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">            <span class="comment">//写入requestId，相当于请求序号，为了全双工通信，提供异步能力</span></span><br><span class="line">            out.writeInt(ATOMIC_INTEGER.getAndIncrement());</span><br><span class="line">            <span class="comment">//获取消息长度和消息体</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//初始消息长度为消息头长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> RpcConstants.HEAD_LENGTH;</span><br><span class="line">            <span class="comment">//如果消息类型不是心跳包, fullLength = head length + body length</span></span><br><span class="line">            <span class="keyword">if</span> (messageType != RpcConstants.HEARTBEAT_REQUEST_TYPE</span><br><span class="line">                    &amp;&amp; messageType != RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">                <span class="comment">//获取序列化类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">                <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">                <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//                Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(codecName);</span></span><br><span class="line">                <span class="comment">//序列化消息体</span></span><br><span class="line">                bodyBytes = serializer.serialize(rpcMessage.getData());</span><br><span class="line">                <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">                <span class="comment">//获取压缩类型</span></span><br><span class="line"><span class="comment">//                String compressName = CompressTypeEnum.getName(rpcMessage.getCompress());</span></span><br><span class="line"><span class="comment">//                Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                        .getExtension(compressName);</span></span><br><span class="line">                <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line">                <span class="comment">//压缩消息体</span></span><br><span class="line">                bodyBytes = compress.compress(bodyBytes);</span><br><span class="line">                <span class="comment">//最终消息长度 = 消息头长度 + 消息体长度</span></span><br><span class="line">                fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bodyBytes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//写入消息体</span></span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取写入索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> out.writerIndex();</span><br><span class="line">            <span class="comment">//回到消息长度的占位符位置：当前索引 - 消息长度占位符长度 + 魔数长度 + version长度</span></span><br><span class="line">            out.writerIndex(writeIndex - fullLength + RpcConstants.MAGIC_NUMBER.length + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//写入消息长度</span></span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            <span class="comment">//回到写入索引位置</span></span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Encode request error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcMessageDecoder，自定义解码器，负责“入站”数据，将 <strong>ByteBuf</strong> 中的字节数组转换为对应的消息数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// lengthFieldOffset = 魔数(4B) + 版本(1B) = 5B</span></span><br><span class="line">        <span class="comment">// lengthFieldLength = 消息长度 int(4B)</span></span><br><span class="line">        <span class="comment">// lengthAdjustment = -9，因为我们的长度域是从魔数开始的，所以我们需要调整长度域的偏移量</span></span><br><span class="line">        <span class="comment">// initialBytesToStrip = 0，我们会手动检查魔数和版本，所以不需要跳过任何字节</span></span><br><span class="line">        <span class="built_in">this</span>(RpcConstants.MAX_FRAME_LENGTH, <span class="number">5</span>, <span class="number">4</span>, -<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength      最大帧长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset   长度域(消息长度)的偏移量，简单而言就是偏移几个字节后才是长度域</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength   长度域的所占的字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment    长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离值，Netty在解码时会根据该值计算消息体的开始位置，默认为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 最后解析结果中需要剥离的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcMessageDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> lengthAdjustment, <span class="type">int</span> initialBytesToStrip)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">decoded</span> <span class="operator">=</span> <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (decoded <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">frame</span> <span class="operator">=</span> (ByteBuf) decoded;</span><br><span class="line">            <span class="keyword">if</span> (frame.readableBytes() &gt;= RpcConstants.TOTAL_LENGTH) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> decodeFrame(frame);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Decode frame error!&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    frame.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> decoded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">decodeFrame</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序读取魔数、版本、消息长度</span></span><br><span class="line">        <span class="comment">//读取魔数并比较</span></span><br><span class="line">        checkMagicNumber(in);</span><br><span class="line">        <span class="comment">//读取版本并比较</span></span><br><span class="line">        checkVersion(in);</span><br><span class="line">        <span class="comment">//读取4字节消息长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fullLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//读取1字节消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节序列化类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">codecType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取1字节压缩类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">compressType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="comment">//读取4字节请求ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="comment">//构建RpcMessage对象</span></span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder()</span><br><span class="line">                .codec(codecType)</span><br><span class="line">                .requestId(requestId)</span><br><span class="line">                .messageType(messageType).build();</span><br><span class="line">        <span class="comment">//根据消息类型解析消息</span></span><br><span class="line">        <span class="comment">//心跳消息</span></span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">            <span class="keyword">return</span> rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//普通消息</span></span><br><span class="line">        <span class="comment">//读取消息体长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> fullLength - RpcConstants.HEAD_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">            <span class="comment">//读取消息体</span></span><br><span class="line">            in.readBytes(bs);</span><br><span class="line">            <span class="comment">//解压缩</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">compressName</span> <span class="operator">=</span> CompressTypeEnum.getName(compressType);</span><br><span class="line">            <span class="comment">//TODO 根据压缩类型通过SPI机制获取压缩器</span></span><br><span class="line">            <span class="type">Compress</span> <span class="variable">compress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipCompress</span>();</span><br><span class="line"><span class="comment">//            Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(compressName);</span></span><br><span class="line">            bs = compress.decompress(bs);</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">codecName</span> <span class="operator">=</span> SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">            <span class="comment">//TODO 根据序列化类型通过SPI机制获取序列化器</span></span><br><span class="line">            <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>();</span><br><span class="line"><span class="comment">//            Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span></span><br><span class="line"><span class="comment">//                    .getExtension(codecName);</span></span><br><span class="line">            <span class="comment">//根据消息类型反序列化</span></span><br><span class="line">            <span class="keyword">if</span> (messageType == RpcConstants.REQUEST_TYPE) &#123;</span><br><span class="line">                <span class="type">RpcRequest</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcRequest.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">tmpValue</span> <span class="operator">=</span> serializer.deserialize(bs, RpcResponse.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcMessage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkVersion</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取第5个字节，比较版本</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="keyword">if</span> (version != RpcConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;version isn&#x27;t compatible&quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkMagicNumber</span><span class="params">(ByteBuf in)</span> &#123;</span><br><span class="line">        <span class="comment">//读取前4个字节，比较魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> RpcConstants.MAGIC_NUMBER.length;</span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        in.readBytes(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] != RpcConstants.MAGIC_NUMBER[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Netty"><a href="#3、Netty" class="headerlink" title="3、Netty"></a>3、Netty</h3><h4 id="1）客户端"><a href="#1）客户端" class="headerlink" title="1）客户端"></a>1）客户端</h4><p>Netty客户端主要提供了以下方法：</p><ul><li>initClientApplication() 用于初始化客户端</li><li>doSubscribeService(Class serviceBean)  服务订阅，将标注了@Reference的属性缓存到本地，之后统一建立Channel</li><li>doConnectServer() 让客户端与@Reference对应的服务端建立Channel</li><li>sendRpcRequest() 发送RpcRequest数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcClient</span> <span class="keyword">implements</span> <span class="title class_">RpcRequestTransport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> ClientConfig clientConfig;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bootstrap <span class="title function_">getBootstrap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initClientApplication</span><span class="params">()</span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        bootstrap.group(worker);</span><br><span class="line">        <span class="comment">//添加 ChannelHandler 以处理每个 Channel 的日志消息</span></span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//                ch.pipeline().addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                <span class="comment">//添加自定义的ChannelHandler</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcClientHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//TODO 从配置文件中读取服务发现类</span></span><br><span class="line">        <span class="built_in">this</span>.serviceDiscovery = <span class="keyword">new</span> <span class="title class_">ZkServiceDiscoveryImpl</span>();</span><br><span class="line"><span class="comment">//        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());</span></span><br><span class="line">        <span class="built_in">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">        <span class="built_in">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = PropertiesBootstrap.loadClientConfigFromLocal();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> <span class="title class_">ZkServiceRegistryImpl</span>();</span><br><span class="line">        CLIENT_CONFIG = clientConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务订阅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceBean 标注了<span class="doctag">@RpcReference</span>的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSubscribeService</span><span class="params">(Class serviceBean)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>();</span><br><span class="line">        url.setServiceName(serviceBean.getName());</span><br><span class="line">        url.setApplicationName(clientConfig.getApplicationName());</span><br><span class="line">        url.addParameter(<span class="string">&quot;host&quot;</span>, InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        <span class="comment">//subscribe：将URL存入SUBSCRIBE_SERVICE_LIST</span></span><br><span class="line">        serviceRegistry.subscribe(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始与各个provider建立连接，TODO 同时监听各个providerNode节点的变化（child变化和nodeData的变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnectServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//SUBSCRIBE_SERVICE_LIST 为所有标注了@RpcReference的属性的信息集合</span></span><br><span class="line">        <span class="keyword">for</span> (URL providerURL : SUBSCRIBE_SERVICE_LIST) &#123;</span><br><span class="line">            <span class="comment">//根据标注了@RpcReference的serviceName去Zookeeper上获取其对应的地址</span></span><br><span class="line">            List&lt;String&gt; providerIps = serviceDiscovery.lookupService(providerURL.getServiceName());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                相当于@RpcReference客户端与对应的每一个服务提供者建立连接</span></span><br><span class="line"><span class="comment">                @RpcReference</span></span><br><span class="line"><span class="comment">                OrderService orderService;</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8081</span></span><br><span class="line"><span class="comment">                -&gt; OrderApplication:8082</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (String providerIp : providerIps) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ConnectionHandler.connect(providerURL.getServiceName(), providerIp);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendRpcRequest</span><span class="params">(RpcRequest rpcRequest)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据serviceName获取Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(rpcRequest.getInterfaceName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(channel.isActive())&#123;</span><br><span class="line">            <span class="comment">//将未处理的请求放入map中</span></span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            <span class="comment">//构建RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> RpcMessage.builder().data(rpcRequest)</span><br><span class="line">                    .codec(SerializationTypeEnum.KYRO.getCode())</span><br><span class="line">                    .compress(CompressTypeEnum.GZIP.getCode())</span><br><span class="line">                    .messageType(RpcConstants.REQUEST_TYPE).build();</span><br><span class="line">            <span class="comment">//将请求发送给服务器</span></span><br><span class="line">            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;客户端发送消息: [&#123;&#125;]&quot;</span>, rpcMessage);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future.cause());</span><br><span class="line">                    log.error(<span class="string">&quot;发送消息时发生错误: &quot;</span>, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">(String interfaceName)</span>&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelProvider.get(interfaceName);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）服务端"><a href="#2）服务端" class="headerlink" title="2）服务端"></a>2）服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerConfig serverConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServiceProvider</span> <span class="variable">serviceProvider</span> <span class="operator">=</span> SingletonFactory.getInstance(ZkServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        serviceProvider.publishService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        CustomShutdownHook.getCustomShutdownHook().clearAll();</span><br><span class="line">        <span class="comment">//创建bossGroup和workerGroup</span></span><br><span class="line">        <span class="comment">//bossGroup只负责连接请求，workerGroup负责读写请求</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">//创建服务端启动对象</span></span><br><span class="line">        <span class="type">DefaultEventExecutorGroup</span> <span class="variable">serviceHandlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(</span><br><span class="line">                <span class="comment">//cpu核心数*2</span></span><br><span class="line">                Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">                <span class="comment">//创建线程工厂</span></span><br><span class="line">                ThreadPoolFactoryUtil.createThreadFactory(<span class="string">&quot;service-handler-group&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取本机ip</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line"><span class="comment">//                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span></span><br><span class="line">                    <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 当客户端第一次进行请求的时候才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="comment">//                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoEncoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line"><span class="comment">//                            p.addLast(new NettyKryoDecoder(new KyroSerializer(), RpcMessage.class));</span></span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageEncoder</span>());</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> <span class="title class_">RpcMessageDecoder</span>());</span><br><span class="line">                            p.addLast(serviceHandlerGroup, <span class="keyword">new</span> <span class="title class_">NettyRpcServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//绑定端口，启动服务，sync()同步等待绑定成功，然后获取到ChannelFuture</span></span><br><span class="line">            bootstrap.bind(host, serverConfig.getServerPort()).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;启动NettyRpcServer服务时发生错误: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            log.info(<span class="string">&quot;断开NettyRpcServer服务&quot;</span>);</span><br><span class="line"><span class="comment">//            bossGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            workerGroup.shutdownGracefully();</span></span><br><span class="line"><span class="comment">//            serviceHandlerGroup.shutdownGracefully();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴露服务 -- 如 127.0.0.1:8080 下的UserService、ProductService...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcServiceConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exposeService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        registerService(rpcServiceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initServerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> PropertiesBootstrap.loadServerConfigFromLocal();</span><br><span class="line">        <span class="built_in">this</span>.setServerConfig(serverConfig);</span><br><span class="line">        SERVER_CONFIG = serverConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-网络传输模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-网络传输模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 网络传输模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 网络传输模块&lt;/h2&gt;&lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 3</title>
    <link href="http://example.com/2023/05/14/rpc-framework-3/"/>
    <id>http://example.com/2023/05/14/rpc-framework-3/</id>
    <published>2023-05-14T14:21:03.000Z</published>
    <updated>2023-05-16T01:01:08.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-服务订阅、发现模块"><a href="#简易RPC框架-服务订阅、发现模块" class="headerlink" title="简易RPC框架 - 服务订阅、发现模块"></a>简易RPC框架 - 服务订阅、发现模块</h2><h3 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h3><p>首先先看Rpc客户端的设计思路：</p><p><img src="/2023/05/14/rpc-framework-3/ttt.png" alt="ttt"></p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>这里也是直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyRpcClient client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">needInitClient</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasInitClientConfig</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = bean.getClass();</span><br><span class="line">        <span class="keyword">final</span> Field[] declaredFields = targetClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(RpcReference.class))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hasInitClientConfig) &#123;</span><br><span class="line">                    <span class="comment">//每个Reference对应一个RpcClient</span></span><br><span class="line">                    client = <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">                    client.initClientApplication();</span><br><span class="line">                    hasInitClientConfig = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                needInitClient = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcReference</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> RpcServiceConfig.builder()</span><br><span class="line">                        .group(annotation.group())</span><br><span class="line">                        .version(annotation.version())</span><br><span class="line">                        .build();</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">RpcClientProxy</span> <span class="variable">rpcClientProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClientProxy</span>(client, rpcServiceConfig);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> rpcClientProxy.getProxy(field.getType());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//代理类替换</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                    <span class="comment">//服务订阅</span></span><br><span class="line">                    client.doSubscribeService(field.getType());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务启动后，自动连接服务端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationReadyEvent 服务启动事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent applicationReadyEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needInitClient &amp;&amp; client != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot; ================== [&#123;&#125;] started success ================== &quot;</span>, client.getClass().getName());</span><br><span class="line">            ConnectionHandler.setBootstrap(client.getBootstrap());</span><br><span class="line">            <span class="comment">//将Client与每个服务提供者连接</span></span><br><span class="line">            client.doConnectServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，我们这里用到了ApplicationContext的事件机制，因为需要需要实现通道连接时保证所有的@Reference都已进行服务订阅，查了很多资料，学到了这个方法。首先该类实现了ApplicationListener，那么每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。我们这里监听的是ApplicationReadyEvent事件，当上下文已经准备完毕的时候触发onApplicationEvent()方法。</p><p>通过ApplicationContext的事件机制，我们就可以实现这个效果：Spring扫描整个类的@Reference属性，然后进行服务订阅，将@Reference对应的信息封装成URL对象。当上下文准备完毕，意味着所有的@Reference属性都已进行订阅，此时会触发onApplicationEvent()方法，将Client与每个@Reference属性对应的RpcServer建立一个Channel，之后当需要远程调用时，就可以在代理类中获取对应的Channel进行通信。</p><p>在这里，将URL和代理类贴出来，方便大家理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URL</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里面可以自定义不限进行扩展</span></span><br><span class="line"><span class="comment">     * 分组</span></span><br><span class="line"><span class="comment">     * 权重</span></span><br><span class="line"><span class="comment">     * 服务提供者的地址</span></span><br><span class="line"><span class="comment">     * 服务提供者的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addParameter</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameters.putIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTERFACE_NAME</span> <span class="operator">=</span> <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestTransport rpcRequestTransport;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServiceConfig rpcServiceConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientProxy</span><span class="params">(RpcRequestTransport rpcRequestTransport, RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestTransport = rpcRequestTransport;</span><br><span class="line">        <span class="built_in">this</span>.rpcServiceConfig = rpcServiceConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 代理类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行方法: [&#123;&#125;]&quot;</span>, method.getName());</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .requestId(UUID.randomUUID().toString())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .group(rpcServiceConfig.getGroup())</span><br><span class="line">                .version(rpcServiceConfig.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">        RpcResponse&lt;Object&gt; rpcResponse = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//通过当前服务对应的唯一channel向服务器发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (rpcRequestTransport <span class="keyword">instanceof</span> NettyRpcClient) &#123;</span><br><span class="line">            CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">            rpcResponse = completableFuture.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcRequestTransport <span class="keyword">instanceof</span> SocketRpcClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!rpcResponse.getRequestId().equals(rpcRequest.getRequestId()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.REQUEST_NOT_MATCH_RESPONSE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rpcResponse.getCode() == <span class="literal">null</span> || !rpcResponse.getCode().equals(RpcResponseCode.SUCCESS.getCode()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于服务订阅、通道连接的代码大家可以根据自己的需要进行设计，我这里就不再描述了。</p><p>至于负载均衡，可以在通道连接的时候设计，也可以按大家的想法来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-服务订阅、发现模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务订阅、发现模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务订阅、发现模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务订阅、发现模块&lt;/h2&gt;&lt;h3 id=&quot;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 2</title>
    <link href="http://example.com/2023/05/12/rpc-framework-2/"/>
    <id>http://example.com/2023/05/12/rpc-framework-2/</id>
    <published>2023-05-12T06:18:57.000Z</published>
    <updated>2023-05-19T05:48:32.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-服务注册模块"><a href="#简易RPC框架-服务注册模块" class="headerlink" title="简易RPC框架 - 服务注册模块"></a>简易RPC框架 - 服务注册模块</h2><h3 id="1、结构设计"><a href="#1、结构设计" class="headerlink" title="1、结构设计"></a>1、结构设计</h3><p>紧接上文，结合框架结构图进行讲解：</p><p><img src="/2023/05/12/rpc-framework-2/xxx.jpg" alt="xxx"></p><p>本节主要讲解服务注册的细节，首先定义了三个注解：@RpcService、@RpcReference、@RpcScan</p><p>@RpcService用于标注服务提供者，@RpcReference用于标注服务消费者，@RpcScan用于扫描特定的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcScan &#123;</span><br><span class="line">    String[] basePackage() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>首先服务端执行的大致流程如下：</p><p><img src="/2023/05/12/rpc-framework-2/xxxx.png" alt="xxxx"></p><p>服务注册模块采用注解加包扫描的方式去实现，将标注了@RpcService服务的元信息注册到Zookeeper，然后客户端要向服务端发送消息时，就可以从Zookeeper中获取远程服务的信息完成服务的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; beanMap = applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span>(beanMap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明当前应用内部不需要对外暴露服务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NettyRpcServer</span> <span class="variable">nettyRpcServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">        nettyRpcServer.initServerConfig();</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanMap.keySet()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;]&quot;</span>, beanName, RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">//build RpcServiceProperties</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanMap.get(beanName);</span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            <span class="type">RpcServiceConfig</span> <span class="variable">rpcServiceConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//构建暴露的服务的信息</span></span><br><span class="line">                rpcServiceConfig = RpcServiceConfig.builder()</span><br><span class="line">                        .host(InetAddress.getLocalHost().getHostAddress())</span><br><span class="line">                        .group(rpcService.group())</span><br><span class="line">                        .version(rpcService.version())</span><br><span class="line">                        .service(bean)</span><br><span class="line">                        .port(SERVER_CONFIG.getServerPort()).build();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务暴露</span></span><br><span class="line">            nettyRpcServer.exposeService(rpcServiceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动服务端，监听配置文件中定义的IP:PORT</span></span><br><span class="line">        nettyRpcServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中服务注册到Zookeeper的代码我就不放上来了，大家可以根据自己的需要自己定义规则。需要注意的是，在注册时我们还定义了一个服务端缓存类，用于存储服务端提供的类信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonServerCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServerConfig SERVER_CONFIG;</span><br><span class="line">    <span class="comment">//服务端发布的服务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; SERVICE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注册时需要把暴露的服务缓存到本地，后面才能为客户端提供服务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(RpcServiceConfig rpcServiceConfig)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rpcServiceName</span> <span class="operator">=</span> rpcServiceConfig.getRpcServiceName();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> rpcServiceConfig.getService();</span><br><span class="line">    <span class="comment">//将服务名称和服务对象放入map中</span></span><br><span class="line">    <span class="keyword">if</span>(SERVICE_MAP.containsKey(rpcServiceName))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SERVICE_MAP.put(rpcServiceName, service);</span><br><span class="line">    log.info(<span class="string">&quot;服务注册 - 成功注册服务: &#123;&#125; 和接口: &#123;&#125;&quot;</span>, rpcServiceName, service.getClass().getInterfaces());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于客户端调用（服务订阅、服务发现）的细节我们会在后续的文章中进行讲解。</p><p>再来是包扫描的实现方式：</p><p>这里我们Bean注入方式是基于 <strong>ImportBeanDefinitionRegistrar</strong> 来实现的，这种方式是最灵活的，能在 <strong>registerBeanDefinitions</strong> 方法中获取到 <strong>BeanDefinitionRegistry</strong> 容器注册对象，可以手动控制 <strong>BeanDefinition</strong> 的创建和注册。</p><p>在此还要再引入一个类，<strong>ResourceLoader</strong> ，官方对 ResourceLoader的解释是：</p><p><em>Spring ResourceLoader为我们提供了一个统一的getResource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>文件、属性文件或图像文件)加载到Spring应用程序上下文中的不同实现</em></p><p>个人能力有限，我个人浅薄的理解大概是用于加载资源配置，有其他不同解释的欢迎在评论区留言。</p><p>因为要进行包扫描，所以我们就需要一个扫描器，这里我们定义的是 <strong>CustomScanner</strong> ，它实现了 <strong>ClassPathBeanDefinitionScanner</strong> 接口，可以实现将特定路径下的Bean对象注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomScanner</span><span class="params">(BeanDefinitionRegistry registry, Class&lt;? extends Annotation&gt; annoType)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(registry);</span><br><span class="line">        <span class="comment">//添加注解过滤器，只扫描标注了特定注解的Bean对象</span></span><br><span class="line">        <span class="built_in">super</span>.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(annoType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.scan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 registerBeanDefinitions() 方法中，我们先获取到 @RpcScan 的  <strong>AnnotationAttributes</strong> 注解属性，然后读取注解的 <strong>basePackage</strong> 的值，然后创建扫描器对象，把 <strong>BeanDefinitionRegistry</strong> 和注解类型传入扫描器中，然后就能通过执行扫描器里对应的 scan(basePackage) 方法进行扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line">    <span class="comment">//扫描框架项目的bean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_BEAN_BASE_PACKAGE</span> <span class="operator">=</span> <span class="string">&quot;com.hurried1y&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PACKAGE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">&quot;basePackage&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注解属性</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(RpcScan.class.getName()));</span><br><span class="line">        <span class="comment">//获取注解属性中的basePackage</span></span><br><span class="line">        String[] rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(annotationAttributes != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = annotationAttributes.getStringArray(BASE_PACKAGE_ATTRIBUTE_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有指定扫描包，则默认扫描当前类所在的包</span></span><br><span class="line">        <span class="keyword">if</span>(rpcScanBasePackages.length == <span class="number">0</span>)&#123;</span><br><span class="line">            rpcScanBasePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) importingClassMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, RpcService.class);</span><br><span class="line">        <span class="comment">//扫描 Component 注解的扫描器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomScanner</span> <span class="variable">componentScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScanner</span>(registry, Component.class);</span><br><span class="line">        <span class="comment">//设置扫描包</span></span><br><span class="line">        <span class="keyword">if</span>(resourceLoader != <span class="literal">null</span>)&#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(resourceLoader);</span><br><span class="line">            componentScanner.setResourceLoader(resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">springBeanAmount</span> <span class="operator">=</span> componentScanner.scan(SPRING_BEAN_BASE_PACKAGE);</span><br><span class="line">        log.info(<span class="string">&quot;springBeanScanner扫描的数量 [&#123;&#125;]&quot;</span>, springBeanAmount);</span><br><span class="line">        <span class="comment">//扫描 RpcService 注解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rpcServiceCount</span> <span class="operator">=</span> rpcServiceScanner.scan(rpcScanBasePackages);</span><br><span class="line">        log.info(<span class="string">&quot;rpcServiceScanner扫描的数量 [&#123;&#125;]&quot;</span>, rpcServiceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们有了实现了 ImportBeanDefinitionRegistrar 的类还不行，我们还得把它注册到容器中，这一步就在 @RpcScan 注解里通过 @<strong>Import</strong> 实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(CustomScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcScan &#123;</span><br><span class="line">    String[] basePackage() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-服务注册模块&quot;&gt;&lt;a href=&quot;#简易RPC框架-服务注册模块&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 服务注册模块&quot;&gt;&lt;/a&gt;简易RPC框架 - 服务注册模块&lt;/h2&gt;&lt;h3 id=&quot;1、结构设计&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易RPC框架 - 1</title>
    <link href="http://example.com/2023/05/12/rpc-framework-1/"/>
    <id>http://example.com/2023/05/12/rpc-framework-1/</id>
    <published>2023-05-12T05:24:57.000Z</published>
    <updated>2023-05-16T01:00:45.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易RPC框架-前言"><a href="#简易RPC框架-前言" class="headerlink" title="简易RPC框架 - 前言"></a>简易RPC框架 - 前言</h2><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>Rpc框架想必大家都不陌生，常见的开源RPC框架如Dubbo、gRpc、Thrift等，为啥想到要手动实现一个Rpc框架，主要是本人对网络编程很感兴趣，想通过这个来加强自己对Java以及网络编程的理解，也能体验一下钻研的快乐。</p><h3 id="2、基础设计"><a href="#2、基础设计" class="headerlink" title="2、基础设计"></a>2、基础设计</h3><p>这个Rpc框架的最初设计大概如下图：</p><p><img src="/2023/05/12/rpc-framework-1/image-20230512133521798.png" alt="image-20230512133521798"></p><p>最初是尝试通过NIO去实现的，每个服务对应一个Client，即每个服务绑定一个Channel，然后通过Selector轮巡监听服务端的消息。服务端再这里扮演的是一个消息中转站的角色。显而易见的，这个设计存在着一个致命的问题，服务端怎么去分辨Selector上的每个通道对应的是哪个服务，查了很多资料都没有较好的办法，这个方案就不了了之了（最初测试的时候，我试过直接把服务端发布的服务对象序列化到Redis，但存在一些问题，比如当发布的服务中有不可序列化的属性时，就会出现问题）。</p><p>这个方案行不通，之后研究了一下Dubbo服务注册的大概思路，结合掘金里DannyIdea（小林）的<a href="https://juejin.cn/book/7047357110337667076/section">Java开发者的RPC实战课</a> 里对服务注册、订阅的讲解，对原本的设计进行了改进。</p><p>以下是Dubbo的基本架构图：</p><p><img src="/2023/05/12/rpc-framework-1/u=341734470,1171504543&fm=253&fmt=auto&app=138&f=JPEG.jpg" alt="u=341734470,1171504543&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG"></p><p>以下是现在对于框架的设计思路：</p><p><img src="/2023/05/12/rpc-framework-1/xxx.jpg" alt="xxx"></p><p>目前通信方式也由最初的NIO换成了Netty，实现自定义协议进行编码解码，解决了黏包半包等问题，后续可以扩展不同的序列化方式。</p><p>项目的地址在本人的gitee和github仓库：<a href="https://github.com/Hurried1y/rpc-framework/%EF%BC%8Chttps://gitee.com/hurried1y/rpc-framework">https://github.com/Hurried1y/rpc-framework/，https://gitee.com/hurried1y/rpc-framework</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简易RPC框架-前言&quot;&gt;&lt;a href=&quot;#简易RPC框架-前言&quot; class=&quot;headerlink&quot; title=&quot;简易RPC框架 - 前言&quot;&gt;&lt;/a&gt;简易RPC框架 - 前言&lt;/h2&gt;&lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring本地事务失效问题</title>
    <link href="http://example.com/2023/01/14/local-transaction-logs/"/>
    <id>http://example.com/2023/01/14/local-transaction-logs/</id>
    <published>2023-01-14T13:01:16.000Z</published>
    <updated>2023-06-08T12:50:27.646Z</updated>
    
    <content type="html"><![CDATA[<p>​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在spring中，事务的默认传播模式是propagation = Propagation.REQUIRED，即当b()方法需要一个事务，a()方法的事务会默认传递给b()方法，那么当a()方法中任何一处抛出异常，都会连同b()方法一起回滚。但存在的问题是。此时在b()方法中不论对事务做了什么设置，都是无效的，因为用的是a()方法的事务。再看c()方法，声明了propagation = Propagation.REQUIRES_NEW，即使用一个新事务，这样虽然配置能生效，但当a()方法抛出异常时，c()方法不会跟着一起回滚，显然达不到业务需求。</p><p>​        造成上面的原因是，同一个对象内的事务方法互相调用，绕过了代理对象。因为spring中的事务是通过代理对象实现的，那么能不能这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过代理对象调用方法，虽然配置会生效，但这会出现循环依赖问题，显然也不行。</p><p>正确的解决方法是使用代理对象来解决：</p><ol><li><p>引入aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在启动类标注@EnableAspectJAutoProxy(exposeProxy = true)</p><p>spring aop中有两种代理模式，一种是jdk动态代理，另外一种是cglib代理。</p><p>​        jdk动态代理是<code>JDK</code>原生的，不需要任何依赖即可使用，缺点是如果要使用<code>JDK</code>动态代理，被代理的类必须实现了接口，否则无法代理；<code>JDK</code>动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，<code>Spring</code>仍然会使用<code>JDK</code>的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。<code>JDK</code>动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低。</p><p>​        cglib代理的优点是，使用<code>CGLib</code>代理的类，不需要实现接口，因为<code>CGLib</code>生成的代理类是直接继承自需要被代理的类；<code>CGLib</code>生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；<code>CGLib</code>生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理。</p><p>​        在这里我们使用cglib代理，并配置对外暴露代理对象</p></li></ol><p>做好这些配置后，回到我们最初的场景，这时候我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Service&#123;</span><br><span class="line">@Transactional(timeout = 30)</span><br><span class="line">    public void a()&#123;</span><br><span class="line">    //拿到当前类的代理对象</span><br><span class="line">    Service service = (Service)AopContext.currentProxy();</span><br><span class="line">        service.b();</span><br><span class="line">        service.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void b()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED, timeout = 10)</span><br><span class="line">    public void c()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在SpringBoot框架中，当我们需要用到事务时，一般直接在方法上标注@Transactional，这样当方法内发生异常时，整个方法都会回滚。但Spring的事务存在一个问题，假设存在这么一个场景：&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Feign远程调用遇到的坑</title>
    <link href="http://example.com/2023/01/14/feign-logs/"/>
    <id>http://example.com/2023/01/14/feign-logs/</id>
    <published>2023-01-14T12:58:07.000Z</published>
    <updated>2023-06-08T12:44:13.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Feign远程调用丢失请求头问题"><a href="#1、Feign远程调用丢失请求头问题" class="headerlink" title="1、Feign远程调用丢失请求头问题"></a>1、Feign远程调用丢失请求头问题</h4><p>​    在订单服务向购物车服务发起远程调用时，在购物车服务中获取不到用户信息，原因是用户的信息是基于SpringSession保存在redis中，key存在于浏览器的cookie中，当在浏览器中发起请求时，由于请求会默认带上cookie，所以可以正常获取到数据信息，但在这个业务中是由Feign发起的远程调用走到购物车服务，Feign远程调用时会创建一个新的request，里面没有cookie数据，所以在购物车服务中获取不到用户数据。</p><p>​    解决办法，由于Feign在远程调用之前都会调用很多拦截器(默认没有拦截器)，可以写一个Feign的请求拦截器扩展Feign的功能，在新的request中加入cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">                <span class="comment">//通过上下文环境保持器拿到当前请求的所有属性RequestAttributes -&gt;</span></span><br><span class="line"><span class="comment">//                RequestAttributes attributes = RequestContextHolder.getRequestAttributes();</span></span><br><span class="line">                <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">                <span class="comment">//同步请求头数据</span></span><br><span class="line">                template.header(<span class="string">&quot;Cookie&quot;</span>, request.getHeader(<span class="string">&quot;Cookie&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、Feign异步情况丢失上下文问题"><a href="#2、Feign异步情况丢失上下文问题" class="headerlink" title="2、Feign异步情况丢失上下文问题"></a>2、Feign异步情况丢失上下文问题</h4><p>​    在上一个问题中，对于Feign的远程调用请求头丢失问题，引入了RequestInterceptor来解决，但这种办法只能针对同步问题，当使用异步编排发起Feign远程调用时，ServletRequestAttributes中就回去不到原来线程的request数据，就会报空指针异常。</p><p><img src="/2023/01/14/feign-logs/image-20230108205538489.png" alt="image-20230108205538489"></p><p>​    如上图所示，RequestContextHolder是利用ThreadLocal共享数据，所以会发生这种问题。</p><p>​    解决办法是在异步编排之前，先获取主线程的上下文，在进入新线程后再把主线程的上下文放到新线程里面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、Feign远程调用丢失请求头问题&quot;&gt;&lt;a href=&quot;#1、Feign远程调用丢失请求头问题&quot; class=&quot;headerlink&quot; title=&quot;1、Feign远程调用丢失请求头问题&quot;&gt;&lt;/a&gt;1、Feign远程调用丢失请求头问题&lt;/h4&gt;&lt;p&gt;​    在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>frp内网穿透</title>
    <link href="http://example.com/2023/01/14/frp/"/>
    <id>http://example.com/2023/01/14/frp/</id>
    <published>2023-01-14T12:54:16.000Z</published>
    <updated>2023-01-14T13:02:04.947Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​    简单介绍一下，frp主要有两个部分，客户端(frpc)和服务端(frps)，服务端需要部署在具有公网ip的机器上（也就是我们自己买的云服务器），客户端就是我们需要进行穿透的电脑（本地机器）。</p><h4 id="二、服务端配置"><a href="#二、服务端配置" class="headerlink" title="二、服务端配置"></a>二、服务端配置</h4><p>​    首先需要在服务端下载frp并解压。输入命令<code>arch</code>查看处理器架构，根据此去github下载对应的frp版本，然后下载解压完就行。</p><p>​    这里我们只需要修改frps.ini文件的配置就可以了，其他与frpc相关的文件都可删去。由于只需要进行Web服务的穿透访问，这里只配置Web，其他配置按需百度添加即可，重点是成功搭建并运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">#frp监听的端口，即与本地机器建立通信的端口，默认是7000，可以改成其他的（不建议动）</span><br><span class="line">bind_port = 7000</span><br><span class="line">#该端口就是以后访问web服务需要用到的端口，可自定义</span><br><span class="line">vhost_http_port = 3000</span><br><span class="line">#授权码，建议不要太简单。这个token之后在客户端会用到</span><br><span class="line">#注意:不要再token后面加#注释进行注释，也会被算上token内容，导致认证失败!写注释最好单独一行</span><br><span class="line">token = 123456</span><br><span class="line"></span><br><span class="line">#frp管理后台端口,请按自己需求更改，这个东西并不是一定要，这里还是提一下</span><br><span class="line">dashboard_ _port = 7508</span><br><span class="line">#frp管理后台用户名和密码,请改成自己的</span><br><span class="line">dashboard_user =</span><br><span class="line">dashboard_pwd =</span><br><span class="line">enable_prometheus = true</span><br></pre></td></tr></table></figure><p>配置好后就可以启动了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><p>这里可以用systemctl执行，附上配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps daemon</span><br><span class="line">After=syslog.target  network.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini</span><br><span class="line">Restart= always</span><br><span class="line">RestartSec=1min</span><br><span class="line">ExecStop=/usr/bin/killall frps</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="三、客户端配置"><a href="#三、客户端配置" class="headerlink" title="三、客户端配置"></a>三、客户端配置</h4><p>​    和服务端一样，下载解压。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">#服务器的ip地址</span><br><span class="line">server_addr =</span><br><span class="line">#服务器监听的端口，即frps.ini里的bind_port</span><br><span class="line">server_port = 7000</span><br><span class="line">#授权码</span><br><span class="line">token =</span><br><span class="line"></span><br><span class="line">#配置http服务，可用于第三方接口（java开发、小程序开发等）等远程调试</span><br><span class="line">[web]</span><br><span class="line">#服务类型</span><br><span class="line">type = http</span><br><span class="line">#需要被穿透的本地ip，不用改，相当于localhost</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">#本地项目运行服务提供的端口，根据项目自定义</span><br><span class="line">local_port = 3000</span><br><span class="line">#web域名</span><br><span class="line">custom_domains =</span><br><span class="line">#远程服务器监听web服务的端口，需要即frps.ini里的vhost_http_port</span><br><span class="line">remote_port = 3000</span><br></pre></td></tr></table></figure><p>客户端的话，以windows系统为例，在cmd终端cd进frp目录，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><p>也可以将执行命令打成bat脚本，这里也附上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;%1&quot; == &quot;h&quot; goto begin</span><br><span class="line">mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit</span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line">D:</span><br><span class="line">cd Tools\frp</span><br><span class="line">.\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;​    简单介绍一下，frp主要有两个部分，客户端(frpc)和服务端(frps)，服务端需要部署在具有公网ip的机器上（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建redis哨兵集群</title>
    <link href="http://example.com/2022/11/05/sentinel-colony/"/>
    <id>http://example.com/2022/11/05/sentinel-colony/</id>
    <published>2022-11-05T09:06:28.000Z</published>
    <updated>2023-06-08T12:52:31.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h1><h2 id="1-集群结构"><a href="#1-集群结构" class="headerlink" title="1.集群结构"></a>1.集群结构</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><h4 id="1-1哨兵的作用"><a href="#1-1哨兵的作用" class="headerlink" title="1.1哨兵的作用"></a>1.1哨兵的作用</h4><ul><li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p></li></ul><h4 id="1-2服务状态监控"><a href="#1-2服务状态监控" class="headerlink" title="1.2服务状态监控"></a>1.2服务状态监控</h4><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul><h4 id="1-3选举新的master"><a href="#1-3选举新的master" class="headerlink" title="1.3选举新的master"></a>1.3选举新的master</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><h4 id="1-2如何实现故障转移"><a href="#1-2如何实现故障转移" class="headerlink" title="1.2如何实现故障转移"></a>1.2如何实现故障转移</h4><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.237.131 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p><img src="/2022/11/05/sentinel-colony/image-20210701215227018.png" alt="image-20210701215227018"></p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.237.131</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.237.131</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.237.131</td><td align="center">27003</td></tr></tbody></table><h2 id="2-准备实例和配置"><a href="#2-准备实例和配置" class="headerlink" title="2.准备实例和配置"></a>2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在usr/local/redis-colony文件夹内创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> s1 s2 s3</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105170909619.png" alt="image-20221105170909619"></p><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.237.131</span><br><span class="line">sentinel monitor mymaster 192.168.237.131 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/usr/local/redis-colony/s1&quot;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.237.131 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.237.131 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值，此时配了3台sentinel，有两台以上就认为挂了</li></ul></li></ul><p>然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h2><p>先启动redis主从集群</p><p>7002</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190006728.png" alt="image-20221105190006728"></p><p>7003</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190038169.png" alt="image-20221105190038169"></p><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure><p>启动后：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105181013812.png" alt="image-20221105181013812"></p><p><img src="/2022/11/05/sentinel-colony/image-20221105181040781.png" alt="image-20221105181040781"></p><p><img src="/2022/11/05/sentinel-colony/image-20221105181059522.png" alt="image-20221105181059522"></p><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4.测试"></a>3.4.测试</h2><p>尝试让master节点7001宕机</p><p><img src="/2022/11/05/sentinel-colony/image-20221105181244740.png" alt="image-20221105181244740"></p><p>查看sentinel27002的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190717411.png" alt="image-20221105190717411"></p><ol><li>第一行，+sdown，sentinel主观认为7001下线</li><li>第三行，+vote-for-leader，sentinel选出一个leader，选出的sentinel实例去执行故障切换</li><li>第四行，+odown，quorum达标，sentinel客观认为7001下线</li><li>第七行，+switch-master，选7003为新的master</li></ol><p>查看27003的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190809034.png" alt="image-20221105190809034"></p><p>查看7002的日志：</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190856348.png" alt="image-20221105190856348"></p><ol><li>第一行，7002与其主机7001之间的连接断开</li><li>第三行，由于sentinel实例执行了故障切换，把7003选举为新的master，所以自动更改7002的配置</li><li>第四行，Connecting to master 192.168.237.131:7003 建立7002与其新master7003之间的连接</li><li>第八行，Trying a partial…，重新执行数据同步psync</li></ol><p>查看7003的日志</p><p><img src="/2022/11/05/sentinel-colony/image-20221105190927905.png" alt="image-20221105190927905"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建哨兵集群&quot;&gt;&lt;a href=&quot;#搭建哨兵集群&quot; class=&quot;headerlink&quot; title=&quot;搭建哨兵集群&quot;&gt;&lt;/a&gt;搭建哨兵集群&lt;/h1&gt;&lt;h2 id=&quot;1-集群结构&quot;&gt;&lt;a href=&quot;#1-集群结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建redis主从集群</title>
    <link href="http://example.com/2022/11/05/redis-colony/"/>
    <id>http://example.com/2022/11/05/redis-colony/</id>
    <published>2022-11-05T08:00:08.000Z</published>
    <updated>2023-06-08T12:52:09.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从集群"><a href="#Redis主从集群" class="headerlink" title="Redis主从集群"></a>Redis主从集群</h1><h2 id="1-集群结构"><a href="#1-集群结构" class="headerlink" title="1.集群结构"></a>1.集群结构</h2><p>我们搭建的主从集群结构如图：</p><p><img src="/2022/11/05/redis-colony/image-20210630111505799.png" alt="image-20210630111505799"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.237.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.237.101</td><td align="center">7002</td><td align="center">slave</td></tr><tr><td align="center">192.168.237.101</td><td align="center">7003</td><td align="center">slave</td></tr></tbody></table><h2 id="2-准备实例和配置"><a href="#2-准备实例和配置" class="headerlink" title="2.准备实例和配置"></a>2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在usr/local/redis-colony文件夹内创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/11/05/redis-colony/image-20221105162330778.png" alt="image-20221105162330778"></p><p>2）恢复原始配置</p><p>修改redis-5.0.5/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启RDB</span></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="attr">save</span> <span class="string">3600 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 100</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 关闭AOF</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-5.0.5/redis.conf文件拷贝到三个目录中（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7001</span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7002</span><br><span class="line"><span class="built_in">cp</span> redis-5.0.5/redis.conf 7003</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 | xargs -t -n 1 ../redis-5.0.5/redis.conf</span><br></pre></td></tr></table></figure><p>4）修改每个实例的端口、工作目录</p><p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/usr\/local\/redis-colony\/7003\//g&#x27;</span> 7003/redis.conf</span><br></pre></td></tr></table></figure><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># redis实例的声明 IP</span><br><span class="line">replica-announce-ip 192.168.237.131</span><br></pre></td></tr></table></figure><p>每个目录都要改，我们一键完成修改（在/redis-colony目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一执行</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者一键修改</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.237.131&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7001/redis.conf</span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line">redis-server 7003/redis.conf</span><br></pre></td></tr></table></figure><p>启动后：</p><p><img src="/2022/11/05/redis-colony/image-20221105163747112.png" alt="image-20221105163747112"></p><p>如果要一键停止，可以运行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure><h2 id="4-开启主从关系"><a href="#4-开启主从关系" class="headerlink" title="4.开启主从关系"></a>4.开启主从关系</h2><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure></li></ul><p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>这里我们为了演示方便，使用方式二。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7002</span></span><br><span class="line">redis-cli -p 7002</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure><p>通过redis-cli命令连接7003，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7003</span></span><br><span class="line">redis-cli -p 7003</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.237.131 7001</span><br></pre></td></tr></table></figure><p>然后连接 7001节点，查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/11/05/redis-colony/image-20221105165646834.png" alt="image-20221105165646834"></p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 100 </code></p><p><img src="/2022/11/05/redis-colony/image-20221105165820844.png" alt="image-20221105165820844"></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p><p><img src="/2022/11/05/redis-colony/image-20221105165907462.png" alt="image-20221105165907462"></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，而slave节点只能执行读操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis主从集群&quot;&gt;&lt;a href=&quot;#Redis主从集群&quot; class=&quot;headerlink&quot; title=&quot;Redis主从集群&quot;&gt;&lt;/a&gt;Redis主从集群&lt;/h1&gt;&lt;h2 id=&quot;1-集群结构&quot;&gt;&lt;a href=&quot;#1-集群结构&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>著名的三色标记法</title>
    <link href="http://example.com/2022/10/17/Tri-colour-marking/"/>
    <id>http://example.com/2022/10/17/Tri-colour-marking/</id>
    <published>2022-10-17T12:44:16.000Z</published>
    <updated>2022-10-17T13:57:38.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行（STW）。</p><p>在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。包含“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。</p><h2 id="二、三色标记法"><a href="#二、三色标记法" class="headerlink" title="二、三色标记法"></a>二、三色标记法</h2><p>顾名思义，用三种颜色进行标记，其用在CMS垃圾回收器工作的并发标记阶段。</p><hr><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达(白色对象会被当成垃圾对象)。</li></ul><ul><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用（子对象）都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象(黑色对象不会当成垃圾对象)。</li></ul><ul><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。当垃圾回收线程从暂停中再次回来，不会扫描灰色对象，而是直接扫描灰色对象的引用。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li><p>初始时，全部对象都是白色的</p></li><li><p>GC Roots直接引用的对象变成灰色</p></li><li><p>从灰色集合中获取元素：</p><p>3.1 将本对象直接引用的对象标记为灰色</p><p>3.2 将本对象标记为黑色</p></li><li><p>重复步骤3，直到灰色的对象集合变为空</p></li><li><p>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</p></li></ol><p>当Stop The Word时，对象间的引用是不会发生变化的，因为用户线程中断了，可以轻松完成标记，但是在并发标记的时候，标记期间用户线程还在跑，对象间的引用可能发生变化，多标和漏标的情况就可能会发生</p><p><strong>多标(又叫浮动垃圾)</strong></p><p>假设此时我们遍历到了D对象，此时D被标记成了灰色</p><p><img src="/2022/10/17/Tri-colour-marking/img1.png" alt="img1"></p><p> 此时线程发生B取消了对D的引用</p><p><img src="/2022/10/17/Tri-colour-marking/img4.png" alt="img4"></p><p>这时候B-&gt;D的引用没了，D应该是白色，但是因为先前D已经被标记成灰色了，所以D对象仍然会被当成存活对象遍历下去。最终结果：这部分对象仍然会被标记为存活对象，本轮GC不会回收他们的内存。这部分因为并发而造成的本应该回收但是没有回收的对象被称为”浮动垃圾”，我们稍微一想也能想到，<strong>浮动垃圾不会影响应用程序的正确性，只需要等到下一轮GC到来就会被回收了</strong>。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p>另外的，针对并发标记开始后产生的新对象，通常做法是直接标记为黑色，本轮不进行清除，这些对象即使会变成垃圾对象，这也算浮动垃圾一部分。</p><p><strong>漏标(读写屏障)</strong></p><p>假设GC线程已经遍历到D对象，此时D被标记为灰色 </p><p><img src="/2022/10/17/Tri-colour-marking/img2.png" alt="img2"></p><p>但是此时有代码执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/17/Tri-colour-marking/img3.png" alt="img3"></p><p>此时D到E的引用消失，B生成了对E的引用。当GC线程继续时，因为D已经没有了对E的引用，所以不会遍历到E，E也就不会标志为灰色，同时B已经标志为黑色了，不会再被遍历，那么也就导致E一直是白色的，最后被当成垃圾处理，这显然与事实不符，E是可打的，但是因为并发的影响漏标了E，使得E被垃圾回收，明显影响了应用程序的正确性，这是不可接受的。</p><p>分析一下，漏标只有同时满足以下两个条件时才会发生：</p><ol><li><p>灰色对象断开了白色对象的引用</p></li><li><p>黑色对象重新引用了该白色对象</p></li></ol><p>从代码角度看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">E</span> <span class="operator">=</span> D.next;</span><br><span class="line">D.next = <span class="literal">null</span>;</span><br><span class="line">B.next = E;</span><br></pre></td></tr></table></figure><p>只要在上面三步中修改任意一步就可以将丢失的E记录下来，然后当作灰色对象继续遍历</p><p>根据以上思路有两种解决办法：</p><h5 id="一、写屏障-阻止第二步和第三步"><a href="#一、写屏障-阻止第二步和第三步" class="headerlink" title="一、写屏障(阻止第二步和第三步)"></a>一、写屏障(阻止第二步和第三步)</h5><p>1.写屏障 + SATB</p><p>当对象D的引用发生变化时，利用写屏障，将D原来的引用对象记录下来，这样可以尝试保留开始时的对象图，保证标记依然按照原本的路线走</p><p>2.写屏障 + 增量更新</p><p>当对象B的引用发生变化时，利用写屏障，将B新的引用对象E记录下来</p><p>即当有新的引用插入进来时，记录下新的引用</p><p>这种思路不要求保留原始对象图，而是针对新的引用记录下来等待遍历即增量更新</p><h5 id="二、读屏障-阻止第一步"><a href="#二、读屏障-阻止第一步" class="headerlink" title="二、读屏障(阻止第一步)"></a>二、读屏障(阻止第一步)</h5><p>读屏障针对第一步，当读取引用对象的时候，一律记录下来，显然这种方法非常保守，但是安全。</p><p>将记录下的引用遍历就是了</p><p>在现代的垃圾回收器当中可达性分析算法的垃圾回收器几乎都借鉴了三色标记法的思想。</p><p>在Java HotSpot VM中</p><p>CMS采用的是：写屏障 + 增量更新</p><p>G1采用的是：写屏障 + SATB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用的垃圾回收算法和垃圾回收器</title>
    <link href="http://example.com/2022/10/17/GC/"/>
    <id>http://example.com/2022/10/17/GC/</id>
    <published>2022-10-17T10:07:37.000Z</published>
    <updated>2022-10-17T13:03:27.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收器，能实现内存垃圾的自动回收，虽然牺牲了一定的运行效率，但大大地提高了开发效率，那么问题来了，常用的GC都有哪些？常用的GC算法都有哪些？GC是如何定义和定位垃圾的呢？</p><h4 id="二、What-is-Garbage"><a href="#二、What-is-Garbage" class="headerlink" title="二、What is Garbage"></a>二、What is Garbage</h4><p>​        在谈论垃圾回收算法和垃圾回收器之前，我们得先了解一下垃圾的基本概念。</p><h5 id="（1）Garbage的定义"><a href="#（1）Garbage的定义" class="headerlink" title="（1）Garbage的定义"></a>（1）Garbage的定义</h5><p>​        在高级语言中通常将没有引用指向的内存定义为垃圾。</p><h5 id="（2）Garbage的定位"><a href="#（2）Garbage的定位" class="headerlink" title="（2）Garbage的定位"></a>（2）Garbage的定位</h5><p>​        在python中，采用的是垃圾定位算法是reference count引用计数法，即记录每块内存被引用指向的数量，当指向某块内存的数量为0时，就把这块内存定义为垃圾，被GC自动释放（这让我想起了拓扑排序0.0），但这种算法有一个弊端，其无法解决“闭环”的情况，即多块内存相互引用形成闭环，与其他内存块无依赖。</p><p>​        而在java中，则使用Root Searching根可达算法来定位垃圾，从程序的根（如main方法）开始，若无法抵达某块内存，就把该块内存判作垃圾，由GC进行释放，该算法很好的解决了”内存闭环“问题。</p><h4 id="三、GC-Algorithms"><a href="#三、GC-Algorithms" class="headerlink" title="三、GC Algorithms"></a>三、GC Algorithms</h4><h5 id="（1）Mark-Sweep"><a href="#（1）Mark-Sweep" class="headerlink" title="（1）Mark-Sweep"></a>（1）Mark-Sweep</h5><p>​        标记清除法，将某块内存标记为垃圾，然后清除。算法的缺点，会产生碎片空间。</p><p><img src="/2022/10/17/GC/Mark-Sweep.png" alt="Mark-Sweep"></p><h5 id="（2）Copying"><a href="#（2）Copying" class="headerlink" title="（2）Copying"></a>（2）Copying</h5><p>​        拷贝法，将内存区分两半，每次运行时在一半中找出所有存活对象，然后整体性的复制到另外半边，同时排列好，然后把原来半边整体回收。算法的缺点是浪费内存。</p><p><img src="/2022/10/17/GC/Copying.png" alt="Copying"></p><h5 id="（3）Mark-Compact"><a href="#（3）Mark-Compact" class="headerlink" title="（3）Mark-Compact"></a>（3）Mark-Compact</h5><p>​        标记压缩法，将标记为垃圾的内存回收，并且排列好。缺点是效率相对较低。</p><p><img src="/2022/10/17/GC/Mark-Compact.png" alt="Mark-Compact"></p><h4 id="四、Garbage-Collector"><a href="#四、Garbage-Collector" class="headerlink" title="四、Garbage Collector"></a>四、Garbage Collector</h4><p>​        三种GC算法都有自己的缺点和优点，三种的综合运用，诞生了各种各样的垃圾回收器。</p><p><img src="/2022/10/17/GC/Garbage-Collector.png" alt="Garbage-Collector"></p><h5 id="（1）Serial（单线程STW垃圾回收，处理-lt-100MB）"><a href="#（1）Serial（单线程STW垃圾回收，处理-lt-100MB）" class="headerlink" title="（1）Serial（单线程STW垃圾回收，处理&lt;100MB）"></a>（1）Serial（单线程STW垃圾回收，处理&lt;100MB）</h5><p>​        New：A stop-the-world（STW），copying collector which uses a single GC thread.<br>​        Old：A stop-the-world（STW），mark-sweep-compact collector that uses a single GC thread.</p><p>​        即当Serial工作时，内存中所有的业务线程都停止，等Serial清扫完后继续。</p><h5 id="（2）Parallel（并行多线程PS-PO，处理-lt-1G）"><a href="#（2）Parallel（并行多线程PS-PO，处理-lt-1G）" class="headerlink" title="（2）Parallel（并行多线程PS+PO，处理&lt;1G）"></a>（2）Parallel（并行多线程PS+PO，处理&lt;1G）</h5><p>​        Parallel Scavenge：A stop-the-world（STW），copying collector which uses multiple GC threads.</p><p>​        Parallel Old：A stop-the-world（STW），mark-sweep-compact collector that uses multiple GC threads.</p><p>​        与Serial的区别在于多个GC并行处理。</p><h5 id="（3）Concurrent-GC（处理几十G）"><a href="#（3）Concurrent-GC（处理几十G）" class="headerlink" title="（3）Concurrent GC（处理几十G）"></a>（3）Concurrent GC（处理几十G）</h5><p>​        从线程角度理解Concurrent GC，即GC和业务线程能同时运行。 </p><p>​        ParNew：A stop-the-world（STW），copying collector which uses multiple GC threads.<br>               It differs from “Parallel Scavenge” in that it has enhancements that make it useable with CMS<br>​<br>       CMS：垃圾回收历史的重要节点！</p><h4 id="五、java的垃圾回收机制"><a href="#五、java的垃圾回收机制" class="headerlink" title="五、java的垃圾回收机制"></a>五、java的垃圾回收机制</h4><p>​        如果要将一整块内存用统一的一种算法解决，其实是比较困难的，所以在jdk中，将内存划分为两个“年代”，new（新生代）和old（老年代），综合运用不同的垃圾回收器来管理内存空间。</p><p>​        一个内存块在诞生时会被优先划分到新生代的eden区，在新生代区使用的GC算法是Copying算法，其中一次年轻代的清扫被称为YGC，其中90%的垃圾都会被回收，所以划分两个Copying区域没必要按照1:1的比例，其采用8:1:1的比例，清扫不掉的垃圾会被划分到survivor区。</p><p>​        若某个垃圾很顽固，经历了多次清扫仍然存活，就会被划分到old老年区，因为老年区中的都是顽固垃圾，没必要再去一遍遍清扫，等到内存装不下了再用Mark Compact算法进行回收。</p><p><img src="/2022/10/17/GC/jdk-and-GC.png" alt="jdk-and-GC"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;​        相对于c/c++，java、python等高级语言引进了Garbage Collector（GC）垃圾回收</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从底层理解堆和栈的概念以及问题</title>
    <link href="http://example.com/2022/10/17/heap-and-stack/"/>
    <id>http://example.com/2022/10/17/heap-and-stack/</id>
    <published>2022-10-17T10:05:37.000Z</published>
    <updated>2022-10-17T10:07:13.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/17/heap-and-stack/img.jpg" alt="img">        </p><h4 id="（1）栈的概念"><a href="#（1）栈的概念" class="headerlink" title="（1）栈的概念"></a>（1）栈的概念</h4><p>​        在java程序中，存储main方法、Object o变量和m()方法的调用的结构，是一个先进后出的栈（每个线程单独占用一个栈），栈中的每块数据（m、main）由一个栈帧（stack frame指向）。</p><p>​        当每个程序块结束运行，会移到下一个栈帧，而栈中上一个程序块以及其里面的数据会被自动释放，如main方法中的Object o，虽然其会占用一定的空间，但当main程序执行完，不需要程序员手动释放。</p><h4 id="（2）堆的概念及其管理问题"><a href="#（2）堆的概念及其管理问题" class="headerlink" title="（2）堆的概念及其管理问题"></a>（2）堆的概念及其管理问题</h4><p>​        存储程序执行过程被手动new出来的对象的结构叫做堆。new出来的对象会占用堆的空间，若一直一直new对象，会产生爆内存的情况。堆与栈的最主要区别是，堆中的数据由程序员自己分配创建，而且得手动回收（将某处空间标记为可用）。</p><p>​        而对堆空间的处理，不同的语言使用不同的方法去管理，在对堆空间的处理过程中往往会伴随着两个最难调试的bug，野指针问题和并发问题。。</p><p>​        c/c++使用的是手工管理内存（malloc free/new delete）。若忘记释放，会产生memory leak内存泄漏问题（空间存在，但无法被使用），泄漏严重会演变为out of memory内存移除问题，可采用最朴素的调优方式–重启来解决；若多次释放，可能会产生并发线程问题，一个线程空间莫名其妙被另一个线程释放。</p><p>​        在java、python和go等高级语言中，引入了GC（Garbage Collector）垃圾回收器，用于管理堆中垃圾的释放问题，程序员只需要负责分配，而那些错综复杂互相依赖的空间将由GC进行释放，所以相对c/c++来说开发效率更高，大大地降低了程序员的门槛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/10/17/heap-and-stack/img.jpg&quot; alt=&quot;img&quot;&gt;        &lt;/p&gt;
&lt;h4 id=&quot;（1）栈的概念&quot;&gt;&lt;a href=&quot;#（1）栈的概念&quot; class=&quot;headerlink&quot; title=&quot;（1）栈的概</summary>
      
    
    
    
    
  </entry>
  
</feed>
