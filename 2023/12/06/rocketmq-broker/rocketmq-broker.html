<h1 id="RocketMQ源码解读-broker"><a href="#RocketMQ源码解读-broker" class="headerlink" title="RocketMQ源码解读 - broker"></a>RocketMQ源码解读 - broker</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>上一篇文章简单的过了一遍namesrv的流程，其中很多的细节都没有进行展开，整篇文章抓不住重点，权当流程速览了。在这篇文章中将会尝试对rocketmq的流程进行简单的分析。</p>
<h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="1、启动流程分析"><a href="#1、启动流程分析" class="headerlink" title="1、启动流程分析"></a>1、启动流程分析</h4><p>下图就是broker的启动类，在namesrv中，有着一个<code>NamesrvController</code>，负责<strong>管理Name Server节点的状态</strong>、<strong>消息的路由注册</strong>与<strong>查询</strong>等功能，在broker中也有类似的BrokerController，负责管理broker的核心逻辑和状态。在<code>brokerController</code>中，包含了对消息存储、消息发送和接收、消息队列管理等方面的处理逻辑。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i1.png" alt="image-20231201102505627"></p>
<p>broker的启动流程跟namesrv差不多，可以大致分为 <strong>initialize</strong>、<strong>start</strong>，我们先来看initialize初始化。</p>
<h5 id="1）BrokerController-initialize"><a href="#1）BrokerController-initialize" class="headerlink" title="1）BrokerController initialize"></a>1）BrokerController initialize</h5><p>initialize可以分为两部分，初始化broker的元数据和broker中的消息存储的一些配置(比如commitLog、storePath等)。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i20.png" alt="image-20231201103338259"></p>
<p>可以看到，第一步初始化元数据，就是从文件中加载配置信息，此处还分了<code>topicConfigManager</code>、<code>topicQueueMappingManager</code>、<code>consumerOffsetManager</code>等，主要做了职责细分，比如topicConfigManager.load()，topicConfigManager 会从磁盘上的存储文件（通常是<code>${ROCKETMQ_HOME}/store/config/topics.json</code>）中读取Topic的配置信息。这些配置信息包括Topic的名称、队列数、读写权限等。一旦加载完成，<code>TopicConfigManager</code>会将这些配置信息存储在内存中，以便快速访问和查询。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i3.png" alt="image-20231201104132856"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i4.png" alt="image-20231201104330642"></p>
<p>接下来我们看initializeMessageStore，<code>DefaultMessageStore</code>是Broker的核心组件之一，负责管理消息的存储和读取。<code>initializeMessageStore()</code>方法用于初始化消息存储相关的组件和数据结构，确保消息存储的正常运行。</p>
<p>其内部主要进行这几个工作，<strong>初始化消息钩子</strong>、<strong>加载存储插件</strong>等，主要就是初始化<code>messageStore</code>这个服务。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i5.png" alt="image-20231201104942256"></p>
<p>这些组件都创建完后就进入到<strong>存储组件配置的加载</strong>、<strong>消息加载</strong>等步骤。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i23.png" alt="image-20231205172720014"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i24.png" alt="image-20231205172741212"></p>
<h5 id="2）brokerController-start"><a href="#2）brokerController-start" class="headerlink" title="2）brokerController start"></a>2）brokerController start</h5><p>当调用 <code>brokerController.start()</code>时，会执行一系列的初始化操作和启动流程，包括但不限于：</p>
<ol>
<li><strong>加载配置文件</strong>：读取Broker的配置文件，包括Broker的角色、监听端口、存储路径等配置信息。</li>
<li><strong>初始化存储服务</strong>：根据配置信息初始化消息存储服务，包括创建存储目录、加载存储索引等操作。</li>
<li><strong>注册Broker</strong>：将当前Broker注册到NameServer，以便Client端可以发现和连接到该Broker。</li>
<li><strong>启动网络服务</strong>：启动监听端口，接收来自Producer和Consumer的请求。</li>
<li><strong>启动定时任务</strong>：启动定时任务服务，包括消息延时投递、定时消息等功能。</li>
<li><strong>启动消息消费服务</strong>：启动消息消费线程池，负责处理消息的消费和投递。</li>
<li><strong>启动消息拉取服务</strong>：启动消息拉取线程池，负责从存储中拉取消息给Consumer消费。</li>
</ol>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i6.png" alt="image-20231201110942999"></p>
<p>此处就先启动一系列的基础服务，如<strong>消息存储</strong>，<strong>定时存储</strong>、<strong>文件监听</strong>、<strong>心跳处理</strong>、<strong>路由管理</strong>等等。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i7.png" alt="image-20231201111635266"></p>
<p>之后启动一系列定时任务，如<strong>心跳维护</strong>、<strong>元数据刷新</strong>等。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i8.png" alt="image-20231201111954763"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i9.png" alt="image-20231201112011736"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i10.png" alt="image-20231201112020639"></p>
<h4 id="2、消息存储设计"><a href="#2、消息存储设计" class="headerlink" title="2、消息存储设计"></a>2、消息存储设计</h4><p>RocketMQ是一个高性能的消息中间件，其在消息写入时追求极致的效率，采用的策略是顺序写入，所有的消息都写入到<code>commitLog</code>文件中，再在文件内部去维护消息的详细信息，如topic、msgBody等等，这就区别于<code>Kafka</code>，kafka在topic之下还存在<code>分区(Partition)</code>，消息的写入会随着partition的增多而变得分散，这里便不再对其详细展开。除了<code>CommitLog</code>，rocketmq的消息存储系统还包括了<code>ConsumeQueue</code>、<code>IndexFile</code>和<code>Config</code>，下面我们逐一展开。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i17.png" alt="image-20231205170543849"></p>
<h5 id="1）CommitLog"><a href="#1）CommitLog" class="headerlink" title="1）CommitLog"></a>1）CommitLog</h5><p><code>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容</code>。消息存放的物理文件，每台broker上的commitLog被本机所有的queue共享，不做任何区分。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i11.png" alt="image-20231205163633045"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i30.png" alt="image-20231206104637478"></p>
<h5 id="2）ConsumeQueue"><a href="#2）ConsumeQueue" class="headerlink" title="2）ConsumeQueue"></a>2）ConsumeQueue</h5><p><code>consumeQueue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commitLog上的位置。</code>其中包含了这个MessageQueue在CommitLog中的起始物理位置偏移量offset，消息实体内容的大小和Message Tag的哈希值。从实际物理存储来说，<code>ConsumeQueue对应每个Topic和QueuId下面的文件</code>。单个文件大小约5.72M，每个文件由30W条数据组成，每个文件默认大小为600万个字节，当一个ConsumeQueue类型的文件写满了，则写入下一个文件。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i12.png" alt="image-20231205164252133"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i13.png" alt="image-20231205164315021"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i14.png" alt="image-20231205164358006"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i29.png" alt="image-20231206104451012"></p>
<h5 id="3）IndexFile"><a href="#3）IndexFile" class="headerlink" title="3）IndexFile"></a>3）IndexFile</h5><p><code>IndexFile：</code>用于为生成的索引文件提供访问服务，<code>通过消息Key值查询消息真正的实体内容</code>。在实际的物理存储上，文件名则是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i15.png" alt="image-20231205165922541"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i28.png" alt="image-20231206104307435"></p>
<h5 id="4）Config"><a href="#4）Config" class="headerlink" title="4）Config"></a>4）Config</h5><p>config 文件夹中 存储着Topic和Consumer等相关信息。主题和消费者群组相关的信息就存在在此。</p>
<ol>
<li><code>topics.json</code> ： topic 配置属性。</li>
<li><code>subscriptionGroup.json</code> ：消息消费组配置信息。</li>
<li><code>delayOffset.json </code>：延时消息队列拉取进度。</li>
<li><code>consumerOffset.json </code>：集群消费模式消息消进度。</li>
<li><code>consumerFilter.json</code> ：主题消息过滤信息。</li>
</ol>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i16.png" alt="image-20231205170306191"></p>
<h5 id="5）消息存储设计小结"><a href="#5）消息存储设计小结" class="headerlink" title="5）消息存储设计小结"></a>5）消息存储设计小结</h5><p>这些数据前面我们也隐晦的谈到过，比如config里面文件的加载就是发生在broker初始化的时候。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i20.png" alt="image-20231205171933084"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i18.png" alt="image-20231205170858242"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i19.png" alt="image-20231205170941739"></p>
<p>而对commitLog和ConsumeQueue的加载也可以从源码中看到。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i21.png" alt="image-20231205172101035"></p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i22.png" alt="image-20231205172129342"></p>
<p>值得注意的是，RocketMQ在对commitLog、IndexFile等文件进行数据读写的时候，除了用到了<code>读写锁</code>外 ，还用到了<code>零拷贝技术（MMAP）</code>。具体到代码里面就是利用JDK里面NIO的MapperByteBuffer的map()函数，来先将磁盘文件（CommitLog文件、consumeQueue文件等）映射到内存里来。</p>
<p>假如没有使用mmap技术的时候，使用最传统和基本普通文件进行io操作会产生数据多拷贝问题。比如<strong>从磁盘上把数据读取到内核IO缓冲区</strong>里面，然后再<strong>从内核IO缓冲区中读取到用户进程私有空间</strong>里去，然后我们才能拿到这个数据，如下图（以下两张图均来自<a href="https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#mmap-write">小林coding</a>）。</p>
<p>这里的DMA，指的是<code>直接内存访问（Direct Memory Access）</code> 技术，简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i32.png" alt="image-20231206102441861"></p>
<p>MMAP内存映射是在<strong>硬盘上文件的位置</strong>和<code>应用程序缓冲区(application buffers)</code>进行映射（建立一种对应关系），当应用进程调用了<code>mmap()</code>后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核共享这个缓冲区。由于mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。之后的写文件，应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，从这可以看到，实际上只用到了一次CPU拷贝。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i31.png" alt="image-20231206102441861"></p>
<p>在RocketMQ中，我们可以在DefaultMappedFile类中的init方法中看到其应用：</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i33.png" alt="image-20231206111036576"></p>
<h4 id="3、消息写入流程"><a href="#3、消息写入流程" class="headerlink" title="3、消息写入流程"></a>3、消息写入流程</h4><p>RocketMQ使用Netty处理网络，broker收到消息写入的请求就会进入<code>SendMessageProcessor</code>类中processRequest方法。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i25.png" alt="image-20231206102441861"></p>
<p>我们进入sendMessage中，就可以看到其逻辑，最终调用putMessage方法进行消息处理逻辑，当然如果开启了异步发送，就调用相应的异步处理逻辑。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i26.png" alt="image-20231206102749089"></p>
<p>我们再跟下去，就可以发现其最终是调用commitLog的写入逻辑，将消息存储到本地文件commitLog中。</p>
<p><img src="C:\Users\Administrator\Desktop\rocketmq-broker\i27.png" alt="image-20231206103055443"></p>
